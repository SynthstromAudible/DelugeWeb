/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var version = "3.7.1",

	rhtmlSuffix = /HTML$/i,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},


	// Retrieve the text value of an array of DOM nodes
	text: function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {

			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {

				// Do not traverse comment nodes
				ret += jQuery.text( node );
			}
		}
		if ( nodeType === 1 || nodeType === 11 ) {
			return elem.textContent;
		}
		if ( nodeType === 9 ) {
			return elem.documentElement.textContent;
		}
		if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}

		// Do not include comment or processing instruction nodes

		return ret;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem && elem.namespaceURI,
			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}


function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var pop = arr.pop;


var sort = arr.sort;


var splice = arr.splice;


var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




// Note: an element does not contain itself
jQuery.contains = function( a, b ) {
	var bup = b && b.parentNode;

	return a === bup || !!( bup && bup.nodeType === 1 && (

		// Support: IE 9 - 11+
		// IE doesn't have `contains` on SVG.
		a.contains ?
			a.contains( bup ) :
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

function fcssescape( ch, asCodePoint ) {
	if ( asCodePoint ) {

		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
		if ( ch === "\0" ) {
			return "\uFFFD";
		}

		// Control characters and (dependent upon position) numbers get escaped as code points
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Other potentially-special ASCII characters get backslash-escaped
	return "\\" + ch;
}

jQuery.escapeSelector = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};




var preferredDoc = document,
	pushNative = push;

( function() {

var i,
	Expr,
	outermostContext,
	sortInput,
	hasDuplicate,
	push = pushNative,

	// Local document vars
	document,
	documentElement,
	documentIsHTML,
	rbuggyQSA,
	matches,

	// Instance-specific data
	expando = jQuery.expando,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
		"loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		ID: new RegExp( "^#(" + identifier + ")" ),
		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
		TAG: new RegExp( "^(" + identifier + "|[*])" ),
		ATTR: new RegExp( "^" + attributes ),
		PSEUDO: new RegExp( "^" + pseudos ),
		CHILD: new RegExp(
			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		needsContext: new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		if ( nonHex ) {

			// Strip the backslash prefix from a non-hex escape sequence
			return nonHex;
		}

		// Replace a hexadecimal escape sequence with the encoded Unicode code point
		// Support: IE <=11+
		// For values outside the Basic Multilingual Plane (BMP), manually construct a
		// surrogate pair
		return high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes; see `setDocument`.
	// Support: IE 9 - 11+, Edge 12 - 18+
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE/Edge.
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && nodeName( elem, "fieldset" );
		},
		{ dir: "parentNode", next: "legend" }
	);

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android <=4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = {
		apply: function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		},
		call: function( target ) {
			pushNative.apply( target, slice.call( arguments, 1 ) );
		}
	};
}

function find( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE 9 only
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								push.call( results, elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE 9 only
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							find.contains( context, elem ) &&
							elem.id === m ) {

							push.call( results, elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( !nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when
					// strict-comparing two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( newContext != context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector( nid );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties
		// (see https://github.com/jquery/sizzle/issues/157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		return nodeName( elem, "input" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
			elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11+
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: iOS 7 only, IE 9 - 11+
	// Older browsers didn't support unprefixed `matches`.
	matches = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors
	// (see trac-13936).
	// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
	// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
	if ( documentElement.msMatchesSelector &&

		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 9 - 11+, Edge 12 - 18+
		subWindow.addEventListener( "unload", unloadHandler );
	}

	// Support: IE <10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		documentElement.appendChild( el ).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName( jQuery.expando ).length;
	} );

	// Support: IE 9 only
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node.
	support.disconnectedMatch = assert( function( el ) {
		return matches.call( el, "*" );
	} );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	support.scope = assert( function() {
		return document.querySelectorAll( ":scope" );
	} );

	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
	// Make sure the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter.ID = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter.ID =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find.TAG = function( tag, context ) {
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			return context.getElementsByTagName( tag );

		// DocumentFragment nodes don't have gEBTN
		} else {
			return context.querySelectorAll( tag );
		}
	};

	// Class
	Expr.find.CLASS = function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	rbuggyQSA = [];

	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert( function( el ) {

		var input;

		documentElement.appendChild( el ).innerHTML =
			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Support: iOS <=7 - 8 only
		// Boolean attributes and "value" are not treated correctly in some XML documents
		if ( !el.querySelectorAll( "[selected]" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
		}

		// Support: iOS <=7 - 8 only
		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Support: iOS 8 only
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// In-page `selector#id sibling-combinator selector` fails
		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		if ( !el.querySelectorAll( ":checked" ).length ) {
			rbuggyQSA.push( ":checked" );
		}

		// Support: Windows 8 Native Apps
		// The type and name attributes are restricted during .innerHTML assignment
		input = document.createElement( "input" );
		input.setAttribute( "type", "hidden" );
		el.appendChild( input ).setAttribute( "name", "D" );

		// Support: IE 9 - 11+
		// IE's :disabled selector does not pick up the children of disabled fieldsets
		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		documentElement.appendChild( el ).disabled = true;
		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
			rbuggyQSA.push( ":enabled", ":disabled" );
		}

		// Support: IE 11+, Edge 15 - 18+
		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
		// Adding a temporary attribute to the document before the selection works
		// around the issue.
		// Interestingly, IE 10 & older don't seem to have the issue.
		input = document.createElement( "input" );
		input.setAttribute( "name", "" );
		el.appendChild( input );
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
				whitespace + "*(?:''|\"\")" );
		}
	} );

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b === document || b.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	};

	return document;
}

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

find.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return jQuery.contains( context, elem );
};


find.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (see trac-13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	if ( val !== undefined ) {
		return val;
	}

	return elem.getAttribute( name );
};

find.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	//
	// Support: Android <=4.0+
	// Testing for detecting duplicates is unpredictable so instead assume we can't
	// depend on duplicate detection in all browsers without a stable sort.
	hasDuplicate = !support.sortStable;
	sortInput = !support.sortStable && slice.call( results, 0 );
	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			splice.call( results, duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

jQuery.fn.uniqueSort = function() {
	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					find.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				find.error( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = find.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element
					// (see https://github.com/jquery/sizzle/issues/299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		has: markFunction( function( selector ) {
			return function( elem ) {
				return find( selector, elem ).length > 0;
			};
		} ),

		contains: markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		lang: markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				find.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		target: function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		root: function( elem ) {
			return elem === documentElement;
		},

		focus: function( elem ) {
			return elem === safeActiveElement() &&
				document.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		enabled: createDisabledPseudo( false ),
		disabled: createDisabledPseudo( true ),

		checked: function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
				( nodeName( elem, "option" ) && !!elem.selected );
		},

		selected: function( elem ) {

			// Support: IE <=11+
			// Accessing the selectedIndex property
			// forces the browser to treat the default option as
			// selected when in an optgroup.
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		empty: function( elem ) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		parent: function( elem ) {
			return !Expr.pseudos.empty( elem );
		},

		// Element/input types
		header: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		input: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		button: function( elem ) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				nodeName( elem, "button" );
		},

		text: function( elem ) {
			var attr;
			return nodeName( elem, "input" ) && elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear
				// with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		first: createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		last: createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		even: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		odd: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i;

			if ( argument < 0 ) {
				i = argument + length;
			} else if ( argument > length ) {
				i = length;
			} else {
				i = argument;
			}

			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos.nth = Expr.pseudos.eq;

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrimCSS, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	if ( parseOnly ) {
		return soFar.length;
	}

	return soFar ?
		find.error( selector ) :

		// Cache the tokens
		tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						if ( skip && nodeName( elem, skip ) ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = outerCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							outerCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		find( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem, matcherOut,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed ||
				multipleContexts( selector || "*",
					context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems;

		if ( matcher ) {

			// If we have a postFinder, or filtered seed, or non-seed postFilter
			// or preexisting results,
			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results;

			// Find primary matches
			matcher( matcherIn, matcherOut, context, xml );
		} else {
			matcherOut = matcherIn;
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element
			// (see https://github.com/jquery/sizzle/issues/299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: iOS <=7 - 9 only
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
			// elements by id. (see trac-14142)
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							push.call( results, elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

function compile( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
}

/**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find.ID(
				token.matches[ 0 ].replace( runescape, funescape ),
				context
			) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) &&
						testContext( context.parentNode ) || context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Support: Android <=4.0 - 4.1+
// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Initialize against the default document
setDocument();

// Support: Android <=4.0 - 4.1+
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

jQuery.find = find;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// These have always been private, but they used to be documented as part of
// Sizzle so let's maintain them for now for backwards compatibility purposes.
find.compile = compile;
find.select = select;
find.setDocument = setDocument;
find.tokenize = tokenize;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* eslint-enable */

} )();


var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to jQuery#find
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.error );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the error, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getErrorHook ) {
									process.error = jQuery.Deferred.getErrorHook();

								// The deprecated alias of the above. While the name suggests
								// returning the stack, not an error instance, jQuery just passes
								// it directly to `console.warn` so both will work; an instance
								// just better cooperates with source maps.
								} else if ( jQuery.Deferred.getStackHook ) {
									process.error = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
// captured before the async barrier to get the original error cause
// which may otherwise be hidden.
jQuery.Deferred.exceptionHook = function( error, asyncError ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message,
			error.stack, asyncError );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", true );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, isSetup ) {

	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
	if ( !isSetup ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				if ( !saved ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					this[ type ]();
					result = dataPriv.get( this, type );
					dataPriv.set( this, type, false );

					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						return result;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering
				// the native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved ) {

				// ...and capture the result
				dataPriv.set( this, type, jQuery.event.trigger(
					saved[ 0 ],
					saved.slice( 1 ),
					this
				) );

				// Abort handling of the native event by all jQuery handlers while allowing
				// native handlers on the same element to run. On target, this is achieved
				// by stopping immediate propagation just on the jQuery event. However,
				// the native event is re-wrapped by a jQuery one on each level of the
				// propagation so the only way to stop it for jQuery is to stop it for
				// everyone via native `stopPropagation()`. This is not a problem for
				// focus/blur which don't bubble, but it does also stop click on checkboxes
				// and radios. We accept this limitation.
				event.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

	function focusMappedHandler( nativeEvent ) {
		if ( document.documentMode ) {

			// Support: IE 11+
			// Attach a single focusin/focusout handler on the document while someone wants
			// focus/blur. This is because the former are synchronous in IE while the latter
			// are async. In other browsers, all those handlers are invoked synchronously.

			// `handle` from private data would already wrap the event, but we need
			// to change the `type` here.
			var handle = dataPriv.get( this, "handle" ),
				event = jQuery.event.fix( nativeEvent );
			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
			event.isSimulated = true;

			// First, handle focusin/focusout
			handle( nativeEvent );

			// ...then, handle focus/blur
			//
			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
			// invoking the handler at the lower level.
			if ( event.target === event.currentTarget ) {

				// The setup part calls `leverageNative`, which, in turn, calls
				// `jQuery.event.add`, so event handle will already have been set
				// by this point.
				handle( event );
			}
		} else {

			// For non-IE browsers, attach a single capturing handler on the document
			// while someone wants focusin/focusout.
			jQuery.event.simulate( delegateType, nativeEvent.target,
				jQuery.event.fix( nativeEvent ) );
		}
	}

	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			var attaches;

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, true );

			if ( document.documentMode ) {

				// Support: IE 9 - 11+
				// We use the same native handler for focusin & focus (and focusout & blur)
				// so we need to coordinate setup & teardown parts between those events.
				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
				attaches = dataPriv.get( this, delegateType );
				if ( !attaches ) {
					this.addEventListener( delegateType, focusMappedHandler );
				}
				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
			} else {

				// Return false to allow normal processing in the caller
				return false;
			}
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		teardown: function() {
			var attaches;

			if ( document.documentMode ) {
				attaches = dataPriv.get( this, delegateType ) - 1;
				if ( !attaches ) {
					this.removeEventListener( delegateType, focusMappedHandler );
					dataPriv.remove( this, delegateType );
				} else {
					dataPriv.set( this, delegateType, attaches );
				}
			} else {

				// Return false to indicate standard teardown should be applied
				return false;
			}
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Support: IE 9 - 11+
	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
	// attach a single handler for both events in IE.
	jQuery.event.special[ delegateType ] = {
		setup: function() {

			// Handle: regular nodes (via `this.ownerDocument`), window
			// (via `this.document`) & document (via `this`).
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType );

			// Support: IE 9 - 11+
			// We use the same native handler for focusin & focus (and focusout & blur)
			// so we need to coordinate setup & teardown parts between those events.
			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
			if ( !attaches ) {
				if ( document.documentMode ) {
					this.addEventListener( delegateType, focusMappedHandler );
				} else {
					doc.addEventListener( type, focusMappedHandler, true );
				}
			}
			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
		},
		teardown: function() {
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

			if ( !attaches ) {
				if ( document.documentMode ) {
					this.removeEventListener( delegateType, focusMappedHandler );
				} else {
					doc.removeEventListener( type, focusMappedHandler, true );
				}
				dataPriv.remove( dataHolder, delegateType );
			} else {
				dataPriv.set( dataHolder, delegateType, attaches );
			}
		}
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Re-enable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew jQuery#find here for performance reasons:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "box-sizing:content-box;border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is `display: block`
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0,
		marginDelta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		// Count margin delta separately to only add it after scroll gutter adjustment.
		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
		if ( box === "margin" ) {
			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta + marginDelta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		animationIterationCount: true,
		aspectRatio: true,
		borderImageSlice: true,
		columnCount: true,
		flexGrow: true,
		flexShrink: true,
		fontWeight: true,
		gridArea: true,
		gridColumn: true,
		gridColumnEnd: true,
		gridColumnStart: true,
		gridRow: true,
		gridRowEnd: true,
		gridRowStart: true,
		lineHeight: true,
		opacity: true,
		order: true,
		orphans: true,
		scale: true,
		widows: true,
		zIndex: true,
		zoom: true,

		// SVG-related
		fillOpacity: true,
		floodOpacity: true,
		stopOpacity: true,
		strokeMiterlimit: true,
		strokeOpacity: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this
			.on( "mouseenter", fnOver )
			.on( "mouseleave", fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./src/jPlot.js":
/*!**********************!*\
  !*** ./src/jPlot.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   jPlot: () => (/* binding */ jPlot)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _js_tippy_all_min_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/tippy.all.min.js */ "./src/js/tippy.all.min.js");
/* harmony import */ var _js_tippy_all_min_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_js_tippy_all_min_js__WEBPACK_IMPORTED_MODULE_1__);




// Draws a line without using a canvas. Uses a long thin <div> that is rotated.
// from Craig Tab via https://stackoverflow.com/questions/14560302/html-line-drawing-without-canvas-just-js
// improved by Davide.
function linedraw(x1, y1, x2, y2) {
  if (x2 < x1) {
    var tmp;
    tmp = x2 ;
    x2 = x1 ;
    x1 = tmp;
    tmp = y2 ;
    y2 = y1 ;
    y1 = tmp;
  }

  var lineLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  var m = (y2 - y1) / (x2 - x1);

  var degree = Math.atan(m) * 180 / Math.PI;

  //let str = "<div class='line' style=\"transform-origin: top left; transform: rotate(' + degree + 'deg); width: ' + lineLength + 'px; height: 1px; background: black; position: absolute; top: ' + y1 + 'px; left: ' + x1 + 'px;\"></div>";
  let str = "<div class='line' style='transform-origin: top left; transform: rotate(" + degree + "deg); width: " + lineLength + "px; height: 1px; background: black; position: absolute; top: " + y1 + "px; left: " + x1 + "px;'></div>";
  //console.log(str); 
  return jquery__WEBPACK_IMPORTED_MODULE_0___default()(str);
}

var tippyActive = false;

function activateTippy() {
	return;
		_js_tippy_all_min_js__WEBPACK_IMPORTED_MODULE_1___default()('.evt', {
		arrow: true,
		html: '#tippytemp',
		onShow(pop) {
			if (!activeView) return;
			const content = this.querySelector('.tippy-content');
			let eventId = pop.reference.getAttribute('data-eid');
			if (eventId >= activeView.events.length) return;
			let evt = activeView.events[eventId];
			let evtStr = evt.tag + " ";
			if (evt.value) {
				evtStr = evt.value + " ";
			}
			evtStr += "t=" + (evt.absStart - activeView.firstTime) / 400000000;
			let duration = 0;
			if (evt.duration > 0.0){
				duration = evt.duration;
			} else if (evt.endEvent) {
				let px = activeView.searchForPreviousEvent(eventId, evt.tag);
				duration = evt.absStart - activeView.events[px].absStart;
			}
			let dur = duration / 400000000;
			if (dur > 0.0) evtStr += ", \u0394t=" + dur;
			evtStr += "<br>" + evt.body;
			content.innerHTML = evtStr;
		},
	});
}


class jPlot {

    constructor(viewer) {
  	this.viewer = viewer;
  	this.scaleFactor  = viewer.timeScale;
  }

  render() {
  	let performance = window.performance;
  	let rstart = performance.now();
  	let view = this.viewer;

    let firsttime = view.minAbsTime;
    let lastX = (view.maxAbsTime - view.minAbsTime) / view.timeScale;
    let timeline = jquery__WEBPACK_IMPORTED_MODULE_0___default()("<div/>");
    let lastXMap = new Map();
    let lastYMap = new Map();
    let lastEventForTag = new Map();
    timeline.addClass('timeline');
    let maxWidth = ((view.maxAbsTime - view.minAbsTime) / view.timeScale);
		timeline.css("width", maxWidth + "px");
		timeline.css("height", (view.maxY + view.laneHeight) + "px");
    for (let i = 0; i < view.events.length; ++i) {
      let evt = view.events[i];
      let relT = evt.absStart - firsttime;
      let tag = evt.tag;
      let item = jquery__WEBPACK_IMPORTED_MODULE_0___default()('<div/>');
      let y = view.trackMap.get(evt.tag);
      if (evt.value != undefined)
      {
        let minV = view.minRange.get(tag);
        let maxV = view.maxRange.get(tag);
        let range = (maxV - minV);
        if (range === 0) range = 1;
        y += view.plotHeight - (((evt.value - minV) * view.plotHeight) / range);
        let x = relT / view.timeScale;
        if (view.flipped) {
        	x = lastX - x;
        }
        if (lastXMap.has(tag)) {
        	 let x0 = lastXMap.get(tag);
        	 let y0 = lastYMap.get(tag);
           item = linedraw(x0, y0, x, y);
        }
  
        item.addClass('valueplot');
        lastXMap.set(tag, x);
        lastYMap.set(tag, y);
      } else {
        item.addClass('eventItem');
        let t1 = evt.absStart - firsttime;
        let t2;
        if (evt.duration > 0) {
   				t1 = evt.absStart - firsttime;
   				t2 = t1 + evt.duration;
        } else if (evt.endEvent) {
        // This is an "ending event", so draw the bar from the previous event to here.
        	let prevX = view.searchForPreviousEvent(view.events, i, evt.tag);
        	if (prevX < 0) continue;
          t2 = view.events[prevX].absStart - firsttime;
        } else {
        	t2 = t1;
        }

				let width = 2;
				if (t1 != t2) {
        	width = Math.abs(t2 - t1) / view.timeScale;
  			}
        if (width < 1) width = 1;
   
        let x = t1 /  view.timeScale;
        if (view.flipped) {
        	x = (lastX - x);
        } else {
        	x -= width;
        }
        item.css("width", width + "px");
        item.css("left", x + "px");
        item.css("top", y + "px");
      }

      item.css("background-color", evt.color);
      item.attr('data-eid', i);
      item.addClass('evt');
      timeline.append(item);
      lastEventForTag.set(tag, evt);
    }

    this.addTagLabelsTo(timeline);
    jquery__WEBPACK_IMPORTED_MODULE_0___default()("#plot").empty();
    jquery__WEBPACK_IMPORTED_MODULE_0___default()("#plot").append(timeline);
    /*
    let plot = $("#plot");
    plot.css("width", maxWidth + "px");
		plot.css("height", (this.maxY + this.laneHeight) + "px");css("width", );
		*/
		//if (!sysExRunning) activateTippy();
		//	else tippyActive = false;
    let rend = performance.now();
    console.log("Time to render: " + (rend - rstart));
  }

  addTagLabelsTo(timeline) {

	  let keyDiv = jquery__WEBPACK_IMPORTED_MODULE_0___default()("<div class='overlay' style='top: 0px;left:0px'></div");
	  let view = this.viewer;
	  for (let i = 0; i < view.trackOrder.length; ++i) {
	  	let tag = view.trackOrder[i];
	  	let y = view.trackMap.get(tag);
	  	let labline = jquery__WEBPACK_IMPORTED_MODULE_0___default()("<div class='linelabel'/>");
	  	labline.css("top", y + "px");
	  	labline.text(tag);
	  	keyDiv.append(labline);
	  }
		timeline.append(keyDiv);
  }

};




/***/ }),

/***/ "./src/js/quadtree.js":
/*!****************************!*\
  !*** ./src/js/quadtree.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Quadtree)
/* harmony export */ });
function pointWithin(px, py, rlft, rtop, rrgt, rbtm) {
    return px >= rlft && px <= rrgt && py >= rtop && py <= rbtm;
}

	const MAX_OBJECTS = 10;
	const MAX_LEVELS  = 4;

	class Quadtree
	{
		constructor(x, y, w, h, l) {
		let t = this;

		t.x = x;
		t.y = y;
		t.w = w;
		t.h = h;
		t.l = l || 0;
		t.o = [];
		t.q = null;
	 }


		split() {
			let t = this,
				x = t.x,
				y = t.y,
				w = t.w / 2,
				h = t.h / 2,
				l = t.l + 1;

			t.q = [
				// top right
				new Quadtree(x + w, y,     w, h, l),
				// top left
				new Quadtree(x,     y,     w, h, l),
				// bottom left
				new Quadtree(x,     y + h, w, h, l),
				// bottom right
				new Quadtree(x + w, y + h, w, h, l),
			];
		};

		// invokes callback with index of each overlapping quad
		quads(x, y, w, h, cb) {
			let t            = this,
				q            = t.q,
				hzMid        = t.x + t.w / 2,
				vtMid        = t.y + t.h / 2,
				startIsNorth = y     < vtMid,
				startIsWest  = x     < hzMid,
				endIsEast    = x + w > hzMid,
				endIsSouth   = y + h > vtMid;

			// top-right quad
			startIsNorth && endIsEast && cb(q[0]);
			// top-left quad
			startIsWest && startIsNorth && cb(q[1]);
			// bottom-left quad
			startIsWest && endIsSouth && cb(q[2]);
			// bottom-right quad
			endIsEast && endIsSouth && cb(q[3]);
		};

		add(o) {
			let t = this;

			if (t.q != null) {
				t.quads(o.x, o.y, o.w, o.h, q => {
					q.add(o);
				});
			}
			else {
				let os = t.o;

				os.push(o);

				if (os.length > MAX_OBJECTS && t.l < MAX_LEVELS) {
					t.split();

					for (let i = 0; i < os.length; i++) {
						let oi = os[i];

						t.quads(oi.x, oi.y, oi.w, oi.h, q => {
							q.add(oi);
						});
					}

					t.o.length = 0;
				}
			}
		};

		get(x, y, w, h, cb) {
			let t = this;
			let os = t.o;

			for (let i = 0; i < os.length; i++)
				cb(os[i]);

			if (t.q != null) {
				t.quads(x, y, w, h, q => {
					q.get(x, y, w, h, cb);
				});
			}
		};

		clear() {
			this.o.length = 0;
			this.q = null;
		};
	};


/***/ }),

/***/ "./src/js/tippy.all.min.js":
/*!*********************************!*\
  !*** ./src/js/tippy.all.min.js ***!
  \*********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

(function(t,e){ true?module.exports=e():0})(this,function(){'use strict';function t(t){return'[object Object]'===Object.prototype.toString.call(t)}function a(t){return[].slice.call(t)}function o(e){if(e instanceof Element||t(e))return[e];if(e instanceof NodeList)return a(e);if(Array.isArray(e))return e;try{return a(document.querySelectorAll(e))}catch(t){return[]}}function r(t){for(var e=[!1,'webkit'],a=t.charAt(0).toUpperCase()+t.slice(1),o=0;o<e.length;o++){var i=e[o],r=i?''+i+a:t;if('undefined'!=typeof document.body.style[r])return r}return null}function p(t,e,a){var i=a.arrow,o=a.arrowType,p=a.arrowTransform,n=a.animateFill,s=a.inertia,l=a.animation,d=a.size,c=a.theme,m=a.html,f=a.zIndex,h=a.interactive,b=a.maxWidth,u=document.createElement('div');u.setAttribute('class','tippy-popper'),u.setAttribute('role','tooltip'),u.setAttribute('id','tippy-'+t),u.style.zIndex=f,u.style.maxWidth=b;var y=document.createElement('div');if(y.setAttribute('class','tippy-tooltip'),y.setAttribute('data-size',d),y.setAttribute('data-animation',l),y.setAttribute('data-state','hidden'),c.split(' ').forEach(function(e){y.classList.add(e+'-theme')}),i){var g=document.createElement('div');g.style[r('transform')]=p,'round'===o?(g.classList.add('tippy-roundarrow'),g.innerHTML='<svg viewBox="0 0 24 8" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.414"><path d="M1 8s4.577-.019 7.253-4.218c2.357-3.698 5.175-3.721 7.508 0C18.404 7.997 23 8 23 8H1z"/></svg>'):g.classList.add('tippy-arrow'),y.appendChild(g)}if(n){y.setAttribute('data-animatefill','');var w=document.createElement('div');w.setAttribute('data-state','hidden'),w.classList.add('tippy-backdrop'),y.appendChild(w)}s&&y.setAttribute('data-inertia',''),h&&y.setAttribute('data-interactive','');var x=document.createElement('div');if(x.setAttribute('class','tippy-content'),m){var v;m instanceof Element?(x.appendChild(m),v='#'+m.id||0):(x.innerHTML=document.querySelector(m).innerHTML,v=m),u.setAttribute('data-html',''),h&&u.setAttribute('tabindex','-1'),y.setAttribute('data-template-id',v)}else x.innerHTML=e;return y.appendChild(x),u.appendChild(y),u}function n(t,e,a,i){var o=a.handleTrigger,r=a.handleMouseLeave,p=a.handleBlur,n=a.handleDelegateShow,s=a.handleDelegateHide,l=[];if('manual'===t)return l;var d=function(t,a){e.addEventListener(t,a),l.push({event:t,handler:a})};return i.target?(At.supportsTouch&&i.touchHold&&(d('touchstart',n),d('touchend',s)),'mouseenter'===t&&(d('mouseover',n),d('mouseout',s)),'focus'===t&&(d('focusin',n),d('focusout',s)),'click'===t&&d('click',n)):(d(t,o),At.supportsTouch&&i.touchHold&&(d('touchstart',o),d('touchend',r)),'mouseenter'===t&&d('mouseleave',r),'focus'===t&&d('blur',p)),l}function s(t,e){var a=Yt.reduce(function(a,i){var o=t.getAttribute('data-tippy-'+i.toLowerCase())||e[i];return'false'===o&&(o=!1),'true'===o&&(o=!0),isFinite(o)&&!isNaN(parseFloat(o))&&(o=parseFloat(o)),'target'!==i&&'string'==typeof o&&'['===o.trim().charAt(0)&&(o=JSON.parse(o)),a[i]=o,a},{});return It({},e,a)}function l(t,e){return e.arrow&&(e.animateFill=!1),e.appendTo&&'function'==typeof e.appendTo&&(e.appendTo=e.appendTo()),'function'==typeof e.html&&(e.html=e.html(t)),e}function d(t){return{tooltip:t.querySelector(Ct.TOOLTIP),backdrop:t.querySelector(Ct.BACKDROP),content:t.querySelector(Ct.CONTENT)}}function c(t){var e=t.getAttribute('title');e&&t.setAttribute('data-original-title',e),t.removeAttribute('title')}function m(t){return t&&'[object Function]'==={}.toString.call(t)}function f(t,e){if(1!==t.nodeType)return[];var a=getComputedStyle(t,null);return e?a[e]:a}function h(t){return'HTML'===t.nodeName?t:t.parentNode||t.host}function b(t){if(!t)return document.body;switch(t.nodeName){case'HTML':case'BODY':return t.ownerDocument.body;case'#document':return t.body;}var e=f(t),a=e.overflow,i=e.overflowX,o=e.overflowY;return /(auto|scroll)/.test(a+o+i)?t:b(h(t))}function u(t){var e=t&&t.offsetParent,a=e&&e.nodeName;return a&&'BODY'!==a&&'HTML'!==a?-1!==['TD','TABLE'].indexOf(e.nodeName)&&'static'===f(e,'position')?u(e):e:t?t.ownerDocument.documentElement:document.documentElement}function y(t){var e=t.nodeName;return'BODY'!==e&&('HTML'===e||u(t.firstElementChild)===t)}function g(t){return null===t.parentNode?t:g(t.parentNode)}function w(t,e){if(!t||!t.nodeType||!e||!e.nodeType)return document.documentElement;var a=t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_FOLLOWING,i=a?t:e,o=a?e:t,r=document.createRange();r.setStart(i,0),r.setEnd(o,0);var p=r.commonAncestorContainer;if(t!==p&&e!==p||i.contains(o))return y(p)?p:u(p);var n=g(t);return n.host?w(n.host,e):w(t,g(e).host)}function x(t){var e=1<arguments.length&&void 0!==arguments[1]?arguments[1]:'top',a='top'===e?'scrollTop':'scrollLeft',i=t.nodeName;if('BODY'===i||'HTML'===i){var o=t.ownerDocument.documentElement,r=t.ownerDocument.scrollingElement||o;return r[a]}return t[a]}function v(t,e){var a=2<arguments.length&&void 0!==arguments[2]&&arguments[2],i=x(e,'top'),o=x(e,'left'),r=a?-1:1;return t.top+=i*r,t.bottom+=i*r,t.left+=o*r,t.right+=o*r,t}function k(t,e){var a='x'===e?'Left':'Top',i='Left'==a?'Right':'Bottom';return parseFloat(t['border'+a+'Width'],10)+parseFloat(t['border'+i+'Width'],10)}function E(t,e,a,i){return Lt(e['offset'+t],e['scroll'+t],a['client'+t],a['offset'+t],a['scroll'+t],Bt()?a['offset'+t]+i['margin'+('Height'===t?'Top':'Left')]+i['margin'+('Height'===t?'Bottom':'Right')]:0)}function L(){var t=document.body,e=document.documentElement,a=Bt()&&getComputedStyle(e);return{height:E('Height',t,e,a),width:E('Width',t,e,a)}}function O(t){return qt({},t,{right:t.left+t.width,bottom:t.top+t.height})}function A(t){var e={};if(Bt())try{e=t.getBoundingClientRect();var a=x(t,'top'),i=x(t,'left');e.top+=a,e.left+=i,e.bottom+=a,e.right+=i}catch(t){}else e=t.getBoundingClientRect();var o={left:e.left,top:e.top,width:e.right-e.left,height:e.bottom-e.top},r='HTML'===t.nodeName?L():{},p=r.width||t.clientWidth||o.right-o.left,n=r.height||t.clientHeight||o.bottom-o.top,s=t.offsetWidth-p,l=t.offsetHeight-n;if(s||l){var d=f(t);s-=k(d,'x'),l-=k(d,'y'),o.width-=s,o.height-=l}return O(o)}function C(t,e){var a=Bt(),i='HTML'===e.nodeName,o=A(t),r=A(e),p=b(t),n=f(e),s=parseFloat(n.borderTopWidth,10),l=parseFloat(n.borderLeftWidth,10),d=O({top:o.top-r.top-s,left:o.left-r.left-l,width:o.width,height:o.height});if(d.marginTop=0,d.marginLeft=0,!a&&i){var c=parseFloat(n.marginTop,10),m=parseFloat(n.marginLeft,10);d.top-=s-c,d.bottom-=s-c,d.left-=l-m,d.right-=l-m,d.marginTop=c,d.marginLeft=m}return(a?e.contains(p):e===p&&'BODY'!==p.nodeName)&&(d=v(d,e)),d}function S(t){var e=t.ownerDocument.documentElement,a=C(t,e),i=Lt(e.clientWidth,window.innerWidth||0),o=Lt(e.clientHeight,window.innerHeight||0),r=x(e),p=x(e,'left'),n={top:r-a.top+a.marginTop,left:p-a.left+a.marginLeft,width:i,height:o};return O(n)}function Y(t){var e=t.nodeName;return'BODY'===e||'HTML'===e?!1:'fixed'===f(t,'position')||Y(h(t))}function X(t,e,a,i){var o={top:0,left:0},r=w(t,e);if('viewport'===i)o=S(r);else{var p;'scrollParent'===i?(p=b(h(e)),'BODY'===p.nodeName&&(p=t.ownerDocument.documentElement)):'window'===i?p=t.ownerDocument.documentElement:p=i;var n=C(p,r);if('HTML'===p.nodeName&&!Y(r)){var s=L(),l=s.height,d=s.width;o.top+=n.top-n.marginTop,o.bottom=l+n.top,o.left+=n.left-n.marginLeft,o.right=d+n.left}else o=n}return o.left+=a,o.top+=a,o.right-=a,o.bottom-=a,o}function _(t){var e=t.width,a=t.height;return e*a}function I(t,e,a,i,o){var r=5<arguments.length&&void 0!==arguments[5]?arguments[5]:0;if(-1===t.indexOf('auto'))return t;var p=X(a,i,r,o),n={top:{width:p.width,height:e.top-p.top},right:{width:p.right-e.right,height:p.height},bottom:{width:p.width,height:p.bottom-e.bottom},left:{width:e.left-p.left,height:p.height}},s=Object.keys(n).map(function(t){return qt({key:t},n[t],{area:_(n[t])})}).sort(function(t,e){return e.area-t.area}),l=s.filter(function(t){var e=t.width,i=t.height;return e>=a.clientWidth&&i>=a.clientHeight}),d=0<l.length?l[0].key:s[0].key,c=t.split('-')[1];return d+(c?'-'+c:'')}function P(t,e,a){var i=w(e,a);return C(a,i)}function D(t){var e=getComputedStyle(t),a=parseFloat(e.marginTop)+parseFloat(e.marginBottom),i=parseFloat(e.marginLeft)+parseFloat(e.marginRight),o={width:t.offsetWidth+i,height:t.offsetHeight+a};return o}function N(t){var e={left:'right',right:'left',bottom:'top',top:'bottom'};return t.replace(/left|right|bottom|top/g,function(t){return e[t]})}function H(t,e,a){a=a.split('-')[0];var i=D(t),o={width:i.width,height:i.height},r=-1!==['right','left'].indexOf(a),p=r?'top':'left',n=r?'left':'top',s=r?'height':'width',l=r?'width':'height';return o[p]=e[p]+e[s]/2-i[s]/2,o[n]=a===n?e[n]-i[l]:e[N(n)],o}function R(t,e){return Array.prototype.find?t.find(e):t.filter(e)[0]}function M(t,e,a){if(Array.prototype.findIndex)return t.findIndex(function(t){return t[e]===a});var i=R(t,function(t){return t[e]===a});return t.indexOf(i)}function B(t,e,a){var i=void 0===a?t:t.slice(0,M(t,'name',a));return i.forEach(function(t){t['function']&&console.warn('`modifier.function` is deprecated, use `modifier.fn`!');var a=t['function']||t.fn;t.enabled&&m(a)&&(e.offsets.popper=O(e.offsets.popper),e.offsets.reference=O(e.offsets.reference),e=a(e,t))}),e}function W(){if(!this.state.isDestroyed){var t={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};t.offsets.reference=P(this.state,this.popper,this.reference),t.placement=I(this.options.placement,t.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),t.originalPlacement=t.placement,t.offsets.popper=H(this.popper,t.offsets.reference,t.placement),t.offsets.popper.position='absolute',t=B(this.modifiers,t),this.state.isCreated?this.options.onUpdate(t):(this.state.isCreated=!0,this.options.onCreate(t))}}function z(t,e){return t.some(function(t){var a=t.name,i=t.enabled;return i&&a===e})}function U(t){for(var e=[!1,'ms','Webkit','Moz','O'],a=t.charAt(0).toUpperCase()+t.slice(1),o=0;o<e.length-1;o++){var i=e[o],r=i?''+i+a:t;if('undefined'!=typeof document.body.style[r])return r}return null}function q(){return this.state.isDestroyed=!0,z(this.modifiers,'applyStyle')&&(this.popper.removeAttribute('x-placement'),this.popper.style.left='',this.popper.style.position='',this.popper.style.top='',this.popper.style[U('transform')]=''),this.disableEventListeners(),this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}function F(t){var e=t.ownerDocument;return e?e.defaultView:window}function j(t,e,a,i){var o='BODY'===t.nodeName,r=o?t.ownerDocument.defaultView:t;r.addEventListener(e,a,{passive:!0}),o||j(b(r.parentNode),e,a,i),i.push(r)}function K(t,e,a,i){a.updateBound=i,F(t).addEventListener('resize',a.updateBound,{passive:!0});var o=b(t);return j(o,'scroll',a.updateBound,a.scrollParents),a.scrollElement=o,a.eventsEnabled=!0,a}function V(){this.state.eventsEnabled||(this.state=K(this.reference,this.options,this.state,this.scheduleUpdate))}function G(t,e){return F(t).removeEventListener('resize',e.updateBound),e.scrollParents.forEach(function(t){t.removeEventListener('scroll',e.updateBound)}),e.updateBound=null,e.scrollParents=[],e.scrollElement=null,e.eventsEnabled=!1,e}function Q(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=G(this.reference,this.state))}function J(t){return''!==t&&!isNaN(parseFloat(t))&&isFinite(t)}function Z(t,e){Object.keys(e).forEach(function(a){var i='';-1!==['width','height','top','right','bottom','left'].indexOf(a)&&J(e[a])&&(i='px'),t.style[a]=e[a]+i})}function $(t,e){Object.keys(e).forEach(function(a){var i=e[a];!1===i?t.removeAttribute(a):t.setAttribute(a,e[a])})}function tt(t,e,a){var i=R(t,function(t){var a=t.name;return a===e}),o=!!i&&t.some(function(t){return t.name===a&&t.enabled&&t.order<i.order});if(!o){var r='`'+e+'`';console.warn('`'+a+'`'+' modifier is required by '+r+' modifier in order to work, be sure to include it before '+r+'!')}return o}function et(t){return'end'===t?'start':'start'===t?'end':t}function at(t){var e=1<arguments.length&&void 0!==arguments[1]&&arguments[1],a=jt.indexOf(t),i=jt.slice(a+1).concat(jt.slice(0,a));return e?i.reverse():i}function it(t,e,a,i){var o=t.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),r=+o[1],p=o[2];if(!r)return t;if(0===p.indexOf('%')){var n;switch(p){case'%p':n=a;break;case'%':case'%r':default:n=i;}var s=O(n);return s[e]/100*r}if('vh'===p||'vw'===p){var l;return l='vh'===p?Lt(document.documentElement.clientHeight,window.innerHeight||0):Lt(document.documentElement.clientWidth,window.innerWidth||0),l/100*r}return r}function ot(t,e,a,i){var o=[0,0],r=-1!==['right','left'].indexOf(i),p=t.split(/(\+|\-)/).map(function(t){return t.trim()}),n=p.indexOf(R(p,function(t){return-1!==t.search(/,|\s/)}));p[n]&&-1===p[n].indexOf(',')&&console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');var s=/\s*,\s*|\s+/,l=-1===n?[p]:[p.slice(0,n).concat([p[n].split(s)[0]]),[p[n].split(s)[1],p.slice(n+1)]];return l=l.map(function(t,i){var o=(1===i?!r:r)?'height':'width',p=!1;return t.reduce(function(t,e){return''===t[t.length-1]&&-1!==['+','-'].indexOf(e)?(t[t.length-1]=e,p=!0,t):p?(t[t.length-1]+=e,p=!1,t):t.concat(e)},[]).map(function(t){return it(t,o,e,a)})}),l.forEach(function(t,e){t.forEach(function(a,i){J(a)&&(o[e]+=a*('-'===t[i-1]?-1:1))})}),o}function rt(t){return t.getAttribute('x-placement').replace(/-.+/,'')}function pt(t,e,a){if(!e.getAttribute('x-placement'))return!0;var i=t.clientX,o=t.clientY,r=a.interactiveBorder,p=a.distance,n=e.getBoundingClientRect(),s=rt(e),l=r+p,d={top:n.top-o>r,bottom:o-n.bottom>r,left:n.left-i>r,right:i-n.right>r};return'top'===s?d.top=n.top-o>l:'bottom'===s?d.bottom=o-n.bottom>l:'left'===s?d.left=n.left-i>l:'right'===s?d.right=i-n.right>l:void 0,d.top||d.bottom||d.left||d.right}function nt(t,e,a,i){if(!e.length)return'';var o={scale:function(){return 1===e.length?''+e[0]:a?e[0]+', '+e[1]:e[1]+', '+e[0]}(),translate:function(){return 1===e.length?i?-e[0]+'px':e[0]+'px':a?i?e[0]+'px, '+-e[1]+'px':e[0]+'px, '+e[1]+'px':i?-e[1]+'px, '+e[0]+'px':e[1]+'px, '+e[0]+'px'}()};return o[t]}function st(t,e){if(!t)return'';return e?t:{X:'Y',Y:'X'}[t]}function lt(t,e,a){var i=rt(t),o='top'===i||'bottom'===i,p='right'===i||'bottom'===i,n=function(t){var e=a.match(t);return e?e[1]:''},s=function(t){var e=a.match(t);return e?e[1].split(',').map(parseFloat):[]},l={translate:/translateX?Y?\(([^)]+)\)/,scale:/scaleX?Y?\(([^)]+)\)/},d={translate:{axis:n(/translate([XY])/),numbers:s(l.translate)},scale:{axis:n(/scale([XY])/),numbers:s(l.scale)}},c=a.replace(l.translate,'translate'+st(d.translate.axis,o)+'('+nt('translate',d.translate.numbers,o,p)+')').replace(l.scale,'scale'+st(d.scale.axis,o)+'('+nt('scale',d.scale.numbers,o,p)+')');e.style[r('transform')]=c}function dt(t){return-(t-St.distance)+'px'}function ct(t){requestAnimationFrame(function(){setTimeout(t,1)})}function mt(t,a){var i=Element.prototype.closest||function(t){for(var a=this;a;){if(e.call(a,t))return a;a=a.parentElement}};return i.call(t,a)}function ft(t,e){return Array.isArray(t)?t[e]:t}function ht(t,e){t.forEach(function(t){t&&t.setAttribute('data-state',e)})}function bt(t,e){t.forEach(function(t){t&&(t.style[r('transitionDuration')]=e+'ms')})}function ut(t){void t.offsetHeight}function yt(t){var e=window.scrollX||window.pageXOffset,a=window.scrollY||window.pageYOffset;t.focus(),scroll(e,a)}function gt(t,e){return t.reduce(function(t,a){var i=ee,o=l(a,e.performance?e:s(a,e)),r=a.getAttribute('title');if(!r&&!o.target&&!o.html&&!o.dynamicTitle)return t;a.setAttribute(o.target?'data-tippy-delegate':'data-tippy',''),c(a);var m=p(i,r,o),f=new T({id:i,reference:a,popper:m,options:o,title:r,popperInstance:null});o.createPopperInstanceOnInit&&(f.popperInstance=$t.call(f),f.popperInstance.disableEventListeners());var h=Zt.call(f);return f.listeners=o.trigger.trim().split(' ').reduce(function(t,e){return t.concat(n(e,a,h,o))},[]),o.dynamicTitle&&te.call(f,{target:a,callback:function(){var t=d(m),e=t.content,i=a.getAttribute('title');i&&(e.innerHTML=f.title=i,c(a))},options:{attributes:!0}}),a._tippy=f,m._tippy=f,m._reference=a,t.push(f),ee++,t},[])}function wt(t){var e=a(document.querySelectorAll(Ct.POPPER));e.forEach(function(e){var a=e._tippy,i=a.options;(!0===i.hideOnClick||-1<i.trigger.indexOf('focus'))&&(!t||e!==t.popper)&&a.hide()})}function xt(){var t=function(){At.usingTouch||(At.usingTouch=!0,At.iOS&&document.body.classList.add('tippy-touch'),At.dynamicInputDetection&&window.performance&&document.addEventListener('mousemove',a),At.onUserInputChange('touch'))},a=function(){var t;return function(){var e=performance.now();20>e-t&&(At.usingTouch=!1,document.removeEventListener('mousemove',a),!At.iOS&&document.body.classList.remove('tippy-touch'),At.onUserInputChange('mouse')),t=e}}();document.addEventListener('click',function(t){if(!(t.target instanceof Element))return wt();var e=mt(t.target,Ct.REFERENCE),a=mt(t.target,Ct.POPPER);if(!(a&&a._reference._tippy.options.interactive)){if(e){var i=e._tippy.options;if(!i.multiple&&At.usingTouch||!i.multiple&&-1<i.trigger.indexOf('click'))return wt(e._tippy);if(!0!==i.hideOnClick||-1<i.trigger.indexOf('click'))return}wt()}}),document.addEventListener('touchstart',t),window.addEventListener('blur',function(){var t=document,a=t.activeElement;a&&a.blur&&e.call(a,Ct.REFERENCE)&&a.blur()}),!At.supportsTouch&&(navigator.maxTouchPoints||navigator.msMaxTouchPoints)&&document.addEventListener('pointerdown',t)}function vt(e,a){return At.supported&&!At._eventListenersBound&&(xt(),At._eventListenersBound=!0),t(e)&&(e.refObj=!0,e.attributes=e.attributes||{},e.setAttribute=function(t,a){e.attributes[t]=a},e.getAttribute=function(t){return e.attributes[t]},e.removeAttribute=function(t){delete e.attributes[t]},e.addEventListener=function(){},e.removeEventListener=function(){},e.classList={classNames:{},add:function(t){return e.classList.classNames[t]=!0},remove:function(t){return delete e.classList.classNames[t],!0},contains:function(t){return!!e.classList.classNames[t]}}),a=It({},St,a),{selector:e,options:a,tooltips:At.supported?gt(o(e),a):[],destroyAll:function(){this.tooltips.forEach(function(t){return t.destroy()}),this.tooltips=[]}}}var kt=Math.round,Et=Math.min,Tt=Math.floor,Lt=Math.max,Ot='undefined'!=typeof window,At={};Ot&&(At.supported='requestAnimationFrame'in window,At.supportsTouch='ontouchstart'in window,At.usingTouch=!1,At.dynamicInputDetection=!0,At.iOS=/iPhone|iPad|iPod/.test(navigator.platform)&&!window.MSStream,At.onUserInputChange=function(){},At._eventListenersBound=!1);for(var Ct={POPPER:'.tippy-popper',TOOLTIP:'.tippy-tooltip',CONTENT:'.tippy-content',BACKDROP:'.tippy-backdrop',ARROW:'.tippy-arrow',ROUND_ARROW:'.tippy-roundarrow',REFERENCE:'[data-tippy]'},St={placement:'top',trigger:'mouseenter focus',animation:'shift-away',html:!1,animateFill:!0,arrow:!1,delay:0,duration:[350,300],interactive:!1,interactiveBorder:2,theme:'dark',size:'regular',distance:10,offset:0,hideOnClick:!0,multiple:!1,followCursor:!1,inertia:!1,updateDuration:350,sticky:!1,appendTo:function(){return document.body},zIndex:9999,touchHold:!1,performance:!1,dynamicTitle:!1,flip:!0,flipBehavior:'flip',arrowType:'sharp',arrowTransform:'',maxWidth:'',target:null,popperOptions:{},createPopperInstanceOnInit:!1,onShow:function(){},onShown:function(){},onHide:function(){},onHidden:function(){}},Yt=At.supported&&Object.keys(St),Xt=function(t,e){if(!(t instanceof e))throw new TypeError('Cannot call a class as a function')},_t=function(){function t(t,e){for(var a,o=0;o<e.length;o++)a=e[o],a.enumerable=a.enumerable||!1,a.configurable=!0,('value'in a)&&(a.writable=!0),Object.defineProperty(t,a.key,a)}return function(e,a,i){return a&&t(e.prototype,a),i&&t(e,i),e}}(),It=Object.assign||function(t){for(var e,a=1;a<arguments.length;a++)for(var i in e=arguments[a],e)Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);return t},Pt='undefined'!=typeof window&&'undefined'!=typeof document,Dt=['Edge','Trident','Firefox'],Nt=0,Ht=0;Ht<Dt.length;Ht+=1)if(Pt&&0<=navigator.userAgent.indexOf(Dt[Ht])){Nt=1;break}var i,Rt=Pt&&window.Promise,Mt=Rt?function(t){var e=!1;return function(){e||(e=!0,window.Promise.resolve().then(function(){e=!1,t()}))}}:function(t){var e=!1;return function(){e||(e=!0,setTimeout(function(){e=!1,t()},Nt))}},Bt=function(){return void 0==i&&(i=-1!==navigator.appVersion.indexOf('MSIE 10')),i},Wt=function(t,e){if(!(t instanceof e))throw new TypeError('Cannot call a class as a function')},zt=function(){function t(t,e){for(var a,o=0;o<e.length;o++)a=e[o],a.enumerable=a.enumerable||!1,a.configurable=!0,'value'in a&&(a.writable=!0),Object.defineProperty(t,a.key,a)}return function(e,a,i){return a&&t(e.prototype,a),i&&t(e,i),e}}(),Ut=function(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t},qt=Object.assign||function(t){for(var e,a=1;a<arguments.length;a++)for(var i in e=arguments[a],e)Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);return t},Ft=['auto-start','auto','auto-end','top-start','top','top-end','right-start','right','right-end','bottom-end','bottom','bottom-start','left-end','left','left-start'],jt=Ft.slice(3),Kt={FLIP:'flip',CLOCKWISE:'clockwise',COUNTERCLOCKWISE:'counterclockwise'},Vt=function(){function t(e,a){var i=this,o=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};Wt(this,t),this.scheduleUpdate=function(){return requestAnimationFrame(i.update)},this.update=Mt(this.update.bind(this)),this.options=qt({},t.Defaults,o),this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},this.reference=e&&e.jquery?e[0]:e,this.popper=a&&a.jquery?a[0]:a,this.options.modifiers={},Object.keys(qt({},t.Defaults.modifiers,o.modifiers)).forEach(function(e){i.options.modifiers[e]=qt({},t.Defaults.modifiers[e]||{},o.modifiers?o.modifiers[e]:{})}),this.modifiers=Object.keys(this.options.modifiers).map(function(t){return qt({name:t},i.options.modifiers[t])}).sort(function(t,e){return t.order-e.order}),this.modifiers.forEach(function(t){t.enabled&&m(t.onLoad)&&t.onLoad(i.reference,i.popper,i.options,t,i.state)}),this.update();var r=this.options.eventsEnabled;r&&this.enableEventListeners(),this.state.eventsEnabled=r}return zt(t,[{key:'update',value:function(){return W.call(this)}},{key:'destroy',value:function(){return q.call(this)}},{key:'enableEventListeners',value:function(){return V.call(this)}},{key:'disableEventListeners',value:function(){return Q.call(this)}}]),t}();Vt.Utils=('undefined'==typeof window?__webpack_require__.g:window).PopperUtils,Vt.placements=Ft,Vt.Defaults={placement:'bottom',eventsEnabled:!0,removeOnDestroy:!1,onCreate:function(){},onUpdate:function(){},modifiers:{shift:{order:100,enabled:!0,fn:function(t){var e=t.placement,a=e.split('-')[0],i=e.split('-')[1];if(i){var o=t.offsets,r=o.reference,p=o.popper,n=-1!==['bottom','top'].indexOf(a),s=n?'left':'top',l=n?'width':'height',d={start:Ut({},s,r[s]),end:Ut({},s,r[s]+r[l]-p[l])};t.offsets.popper=qt({},p,d[i])}return t}},offset:{order:200,enabled:!0,fn:function(t,e){var a,i=e.offset,o=t.placement,r=t.offsets,p=r.popper,n=r.reference,s=o.split('-')[0];return a=J(+i)?[+i,0]:ot(i,p,n,s),'left'===s?(p.top+=a[0],p.left-=a[1]):'right'===s?(p.top+=a[0],p.left+=a[1]):'top'===s?(p.left+=a[0],p.top-=a[1]):'bottom'===s&&(p.left+=a[0],p.top+=a[1]),t.popper=p,t},offset:0},preventOverflow:{order:300,enabled:!0,fn:function(t,e){var a=e.boundariesElement||u(t.instance.popper);t.instance.reference===a&&(a=u(a));var i=X(t.instance.popper,t.instance.reference,e.padding,a);e.boundaries=i;var o=e.priority,r=t.offsets.popper,p={primary:function(t){var a=r[t];return r[t]<i[t]&&!e.escapeWithReference&&(a=Lt(r[t],i[t])),Ut({},t,a)},secondary:function(t){var a='right'===t?'left':'top',o=r[a];return r[t]>i[t]&&!e.escapeWithReference&&(o=Et(r[a],i[t]-('right'===t?r.width:r.height))),Ut({},a,o)}};return o.forEach(function(t){var e=-1===['left','top'].indexOf(t)?'secondary':'primary';r=qt({},r,p[e](t))}),t.offsets.popper=r,t},priority:['left','right','top','bottom'],padding:5,boundariesElement:'scrollParent'},keepTogether:{order:400,enabled:!0,fn:function(t){var e=t.offsets,a=e.popper,i=e.reference,o=t.placement.split('-')[0],r=Tt,p=-1!==['top','bottom'].indexOf(o),n=p?'right':'bottom',s=p?'left':'top',l=p?'width':'height';return a[n]<r(i[s])&&(t.offsets.popper[s]=r(i[s])-a[l]),a[s]>r(i[n])&&(t.offsets.popper[s]=r(i[n])),t}},arrow:{order:500,enabled:!0,fn:function(t,e){var a;if(!tt(t.instance.modifiers,'arrow','keepTogether'))return t;var i=e.element;if('string'==typeof i){if(i=t.instance.popper.querySelector(i),!i)return t;}else if(!t.instance.popper.contains(i))return console.warn('WARNING: `arrow.element` must be child of its popper element!'),t;var o=t.placement.split('-')[0],r=t.offsets,p=r.popper,n=r.reference,s=-1!==['left','right'].indexOf(o),l=s?'height':'width',d=s?'Top':'Left',c=d.toLowerCase(),m=s?'left':'top',h=s?'bottom':'right',b=D(i)[l];n[h]-b<p[c]&&(t.offsets.popper[c]-=p[c]-(n[h]-b)),n[c]+b>p[h]&&(t.offsets.popper[c]+=n[c]+b-p[h]),t.offsets.popper=O(t.offsets.popper);var u=n[c]+n[l]/2-b/2,y=f(t.instance.popper),g=parseFloat(y['margin'+d],10),w=parseFloat(y['border'+d+'Width'],10),x=u-t.offsets.popper[c]-g-w;return x=Lt(Et(p[l]-b,x),0),t.arrowElement=i,t.offsets.arrow=(a={},Ut(a,c,kt(x)),Ut(a,m,''),a),t},element:'[x-arrow]'},flip:{order:600,enabled:!0,fn:function(t,e){if(z(t.instance.modifiers,'inner'))return t;if(t.flipped&&t.placement===t.originalPlacement)return t;var a=X(t.instance.popper,t.instance.reference,e.padding,e.boundariesElement),i=t.placement.split('-')[0],o=N(i),r=t.placement.split('-')[1]||'',p=[];switch(e.behavior){case Kt.FLIP:p=[i,o];break;case Kt.CLOCKWISE:p=at(i);break;case Kt.COUNTERCLOCKWISE:p=at(i,!0);break;default:p=e.behavior;}return p.forEach(function(n,s){if(i!==n||p.length===s+1)return t;i=t.placement.split('-')[0],o=N(i);var l=t.offsets.popper,d=t.offsets.reference,c=Tt,m='left'===i&&c(l.right)>c(d.left)||'right'===i&&c(l.left)<c(d.right)||'top'===i&&c(l.bottom)>c(d.top)||'bottom'===i&&c(l.top)<c(d.bottom),f=c(l.left)<c(a.left),h=c(l.right)>c(a.right),b=c(l.top)<c(a.top),u=c(l.bottom)>c(a.bottom),y='left'===i&&f||'right'===i&&h||'top'===i&&b||'bottom'===i&&u,g=-1!==['top','bottom'].indexOf(i),w=!!e.flipVariations&&(g&&'start'===r&&f||g&&'end'===r&&h||!g&&'start'===r&&b||!g&&'end'===r&&u);(m||y||w)&&(t.flipped=!0,(m||y)&&(i=p[s+1]),w&&(r=et(r)),t.placement=i+(r?'-'+r:''),t.offsets.popper=qt({},t.offsets.popper,H(t.instance.popper,t.offsets.reference,t.placement)),t=B(t.instance.modifiers,t,'flip'))}),t},behavior:'flip',padding:5,boundariesElement:'viewport'},inner:{order:700,enabled:!1,fn:function(t){var e=t.placement,a=e.split('-')[0],i=t.offsets,o=i.popper,r=i.reference,p=-1!==['left','right'].indexOf(a),n=-1===['top','left'].indexOf(a);return o[p?'left':'top']=r[a]-(n?o[p?'width':'height']:0),t.placement=N(e),t.offsets.popper=O(o),t}},hide:{order:800,enabled:!0,fn:function(t){if(!tt(t.instance.modifiers,'hide','preventOverflow'))return t;var e=t.offsets.reference,a=R(t.instance.modifiers,function(t){return'preventOverflow'===t.name}).boundaries;if(e.bottom<a.top||e.left>a.right||e.top>a.bottom||e.right<a.left){if(!0===t.hide)return t;t.hide=!0,t.attributes['x-out-of-boundaries']=''}else{if(!1===t.hide)return t;t.hide=!1,t.attributes['x-out-of-boundaries']=!1}return t}},computeStyle:{order:850,enabled:!0,fn:function(t,e){var a=e.x,i=e.y,o=t.offsets.popper,r=R(t.instance.modifiers,function(t){return'applyStyle'===t.name}).gpuAcceleration;void 0!==r&&console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');var p,n,s=void 0===r?e.gpuAcceleration:r,l=u(t.instance.popper),d=A(l),c={position:o.position},m={left:Tt(o.left),top:Tt(o.top),bottom:Tt(o.bottom),right:Tt(o.right)},f='bottom'===a?'top':'bottom',h='right'===i?'left':'right',b=U('transform');if(n='bottom'==f?-d.height+m.bottom:m.top,p='right'==h?-d.width+m.right:m.left,s&&b)c[b]='translate3d('+p+'px, '+n+'px, 0)',c[f]=0,c[h]=0,c.willChange='transform';else{var y='bottom'==f?-1:1,g='right'==h?-1:1;c[f]=n*y,c[h]=p*g,c.willChange=f+', '+h}var w={"x-placement":t.placement};return t.attributes=qt({},w,t.attributes),t.styles=qt({},c,t.styles),t.arrowStyles=qt({},t.offsets.arrow,t.arrowStyles),t},gpuAcceleration:!0,x:'bottom',y:'right'},applyStyle:{order:900,enabled:!0,fn:function(t){return Z(t.instance.popper,t.styles),$(t.instance.popper,t.attributes),t.arrowElement&&Object.keys(t.arrowStyles).length&&Z(t.arrowElement,t.arrowStyles),t},onLoad:function(t,e,a,i,o){var r=P(o,e,t),p=I(a.placement,r,e,t,a.modifiers.flip.boundariesElement,a.modifiers.flip.padding);return e.setAttribute('x-placement',p),Z(e,{position:'absolute'}),a},gpuAcceleration:void 0}}};var Gt={};if(Ot){var Qt=Element.prototype;Gt=Qt.matches||Qt.matchesSelector||Qt.webkitMatchesSelector||Qt.mozMatchesSelector||Qt.msMatchesSelector||function(t){for(var e=(this.document||this.ownerDocument).querySelectorAll(t),a=e.length;0<=--a&&e.item(a)!==this;);return-1<a}}var e=Gt,Jt=function(){function t(t){var e=mt(t.target,this.options.target);if(e&&!e._tippy){var a=e.getAttribute('title')||this.title;a&&(e.setAttribute('title',a),vt(e,It({},this.options,{target:null})),e._tippy.show())}}function e(e){var a=this;if(n.call(this),!this.state.visible){if(this.options.target)return void t.call(this,e);if(this._(f).isPreparingToShow=!0,this.options.wait)return void this.options.wait.call(this.popper,this.show.bind(this),e);this.options.followCursor&&!At.usingTouch&&(!this._(f).followCursorListener&&s.call(this),document.addEventListener('mousemove',this._(f).followCursorListener));var i=Array.isArray(this.options.delay)?this.options.delay[0]:this.options.delay;i?this._(f).showTimeout=setTimeout(function(){a.show()},i):this.show()}}function i(){var t=this;if(n.call(this),!!this.state.visible){this._(f).isPreparingToShow=!1;var e=Array.isArray(this.options.delay)?this.options.delay[1]:this.options.delay;e?this._(f).hideTimeout=setTimeout(function(){t.state.visible&&t.hide()},e):this.hide()}}function o(){var t=this,e=this.popper,a=this.reference,i=this.options,o=d(e),p=o.tooltip,n=i.popperOptions,s='round'===i.arrowType?Ct.ROUND_ARROW:Ct.ARROW,l=p.querySelector(s),m=It({placement:i.placement},n||{},{modifiers:It({},n?n.modifiers:{},{arrow:It({element:s},n&&n.modifiers?n.modifiers.arrow:{}),flip:It({enabled:i.flip,padding:i.distance+5,behavior:i.flipBehavior},n&&n.modifiers?n.modifiers.flip:{}),offset:It({offset:i.offset},n&&n.modifiers?n.modifiers.offset:{})}),onCreate:function(){p.style[rt(e)]=dt(i.distance),l&&i.arrowTransform&&lt(e,l,i.arrowTransform)},onUpdate:function(){var t=p.style;t.top='',t.bottom='',t.left='',t.right='',t[rt(e)]=dt(i.distance),l&&i.arrowTransform&&lt(e,l,i.arrowTransform)}});return c.call(this,{target:e,callback:function(){var a=e.style;a[r('transitionDuration')]=null;var o=t.popperInstance.options.onUpdate;t.popperInstance.options.onUpdate=function(){ut(t.popper),a[r('transitionDuration')]=i.updateDuration+'ms',t.popperInstance.options.onUpdate=o},t.popperInstance.update()},options:{childList:!0,subtree:!0,characterData:!0}}),new Vt(a,e,m)}function p(t){var e=this;this.popperInstance?(this.popper.style[r('transform')]=null,this.popperInstance.scheduleUpdate(),(!this.options.followCursor||At.usingTouch)&&this.popperInstance.enableEventListeners()):this.popperInstance=o.call(this);var a=this.popperInstance.options.onCreate,i=this.popperInstance.options.onUpdate;this.popperInstance.options.onCreate=this.popperInstance.options.onUpdate=function(){ut(e.popper),t(),e.popperInstance.options.onUpdate=i,e.popperInstance.options.onCreate=a},this.options.appendTo.contains(this.popper)||this.options.appendTo.appendChild(this.popper)}function n(){var t=this._(f),e=t.showTimeout,a=t.hideTimeout;clearTimeout(e),clearTimeout(a)}function s(){var t=this;this._(f).followCursorListener=function(e){if(!(t._(f).lastTriggerEvent&&'focus'===t._(f).lastTriggerEvent.type)){t._(f).lastMouseMoveEvent=e;var a=document.documentElement.offsetWidth||document.body.offsetWidth,i=kt(t.popper.offsetWidth/2),o=kt(t.popper.offsetHeight/2),p=t.options.offset,n=e.pageX,s=e.pageY,l=5,d=t.options.placement.replace(/-.+/,'');t.popper.getAttribute('x-placement')&&(d=rt(t.popper));var c,m;'top'===d?(c=n-i+p,m=s-2*o):'bottom'===d?(c=n-i+p,m=s+10):'left'===d?(c=n-2*i,m=s-o+p):'right'===d?(c=n+5,m=s-o+p):void 0;('top'===d||'bottom'===d)&&(n+l+i+p>a&&(c=a-l-2*i),0>n-l-i+p&&(c=l)),t.popper.style[r('transform')]='translate3d('+c+'px, '+m+'px, 0)'}}}function l(){var t=this,e=function(){t.popper.style[r('transitionDuration')]=t.options.updateDuration+'ms'},a=function(){t.popper.style[r('transitionDuration')]=''};ct(function i(){t.popperInstance&&t.popperInstance.scheduleUpdate(),e(),t.state.visible?requestAnimationFrame(i):a()})}function c(t){var e=t.target,a=t.callback,i=t.options;if(window.MutationObserver){var o=new MutationObserver(a);o.observe(e,i),this._(f).mutationObservers.push(o)}}function m(t,a){if(!t)return a();var e=d(this.popper),i=e.tooltip,o=function(t,e){e&&i[t+'EventListener']('ontransitionend'in window?'transitionend':'webkitTransitionEnd',e)},r=function t(r){r.target===i&&(o('remove',t),a())};o('remove',this._(f).transitionendListener),o('add',r),this._(f).transitionendListener=r}var f={},h=function(t){return function(e){return e===f&&t}},b=function(){function t(e){for(var a in Xt(this,t),e)this[a]=e[a];this.state={destroyed:!1,visible:!1,enabled:!0},this._=h({mutationObservers:[]})}return _t(t,[{key:'enable',value:function(){this.state.enabled=!0}},{key:'disable',value:function(){this.state.enabled=!1}},{key:'show',value:function(t){var e=this;if(!this.state.destroyed&&this.state.enabled){var a=this.popper,i=this.reference,o=this.options,n=d(a),s=n.tooltip,c=n.backdrop,h=n.content;return o.dynamicTitle&&!i.getAttribute('data-original-title')?void 0:i.refObj||document.documentElement.contains(i)?void(o.onShow.call(a,this),t=ft(void 0===t?o.duration:t,0),bt([a,s,c],0),a.style.visibility='visible',this.state.visible=!0,p.call(this,function(){if(e.state.visible){if((!o.followCursor||At.usingTouch)&&(e.popperInstance.scheduleUpdate(),bt([a],o.updateDuration)),o.followCursor&&!At.usingTouch){e.popperInstance.disableEventListeners();var p=Array.isArray(o.delay)?o.delay[0]:o.delay;e._(f).lastTriggerEvent&&e._(f).followCursorListener(p&&e._(f).lastMouseMoveEvent?e._(f).lastMouseMoveEvent:e._(f).lastTriggerEvent)}bt([s,c,c?h:null],t),c&&getComputedStyle(c)[r('transform')],o.interactive&&i.classList.add('tippy-active'),o.sticky&&l.call(e),ht([s,c],'visible'),m.call(e,t,function(){o.updateDuration||s.classList.add('tippy-notransition'),o.interactive&&yt(a),i.setAttribute('aria-describedby','tippy-'+e.id),o.onShown.call(a,e)})}})):void this.destroy()}}},{key:'hide',value:function(t){var e=this;if(!this.state.destroyed&&this.state.enabled){var a=this.popper,i=this.reference,o=this.options,r=d(a),p=r.tooltip,n=r.backdrop,s=r.content;o.onHide.call(a,this),t=ft(void 0===t?o.duration:t,1),o.updateDuration||p.classList.remove('tippy-notransition'),o.interactive&&i.classList.remove('tippy-active'),a.style.visibility='hidden',this.state.visible=!1,bt([p,n,n?s:null],t),ht([p,n],'hidden'),o.interactive&&-1<o.trigger.indexOf('click')&&yt(i),ct(function(){m.call(e,t,function(){e.state.visible||!o.appendTo.contains(a)||(!e._(f).isPreparingToShow&&(document.removeEventListener('mousemove',e._(f).followCursorListener),e._(f).lastMouseMoveEvent=null),i.removeAttribute('aria-describedby'),e.popperInstance.disableEventListeners(),o.appendTo.removeChild(a),o.onHidden.call(a,e))})})}}},{key:'destroy',value:function(){var t=this,e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:!0;if(!this.state.destroyed){this.state.visible&&this.hide(0),this.listeners.forEach(function(e){t.reference.removeEventListener(e.event,e.handler)}),this.reference.setAttribute('title',this.reference.getAttribute('data-original-title')),delete this.reference._tippy;['data-original-title','data-tippy','data-tippy-delegate'].forEach(function(e){t.reference.removeAttribute(e)}),this.options.target&&e&&a(this.reference.querySelectorAll(this.options.target)).forEach(function(t){return t._tippy&&t._tippy.destroy()}),this.popperInstance&&this.popperInstance.destroy(),this._(f).mutationObservers.forEach(function(t){t.disconnect()}),this.state.destroyed=!0}}}]),t}();return{Tippy:b,_getEventListeners:function(){var t=this;return{handleTrigger:function(a){if(t.state.enabled){var o=At.supportsTouch&&At.usingTouch&&-1<['mouseenter','mouseover','focus'].indexOf(a.type);o&&t.options.touchHold||(t._(f).lastTriggerEvent=a,'click'===a.type&&'persistent'!==t.options.hideOnClick&&t.state.visible?i.call(t):e.call(t,a),o&&At.iOS&&t.reference.click&&t.reference.click())}},handleMouseLeave:function(e){if(!(-1<['mouseleave','mouseout'].indexOf(e.type)&&At.supportsTouch&&At.usingTouch&&t.options.touchHold)){if(t.options.interactive){var a=i.bind(t),o=function e(o){var r=mt(o.target,Ct.REFERENCE),p=mt(o.target,Ct.POPPER)===t.popper,n=r===t.reference;p||n||pt(o,t.popper,t.options)&&(document.body.removeEventListener('mouseleave',a),document.removeEventListener('mousemove',e),i.call(t))};return document.body.addEventListener('mouseleave',a),void document.addEventListener('mousemove',o)}i.call(t)}},handleBlur:function(e){!e.relatedTarget||At.usingTouch||mt(e.relatedTarget,Ct.POPPER)||i.call(t)},handleDelegateShow:function(a){mt(a.target,t.options.target)&&e.call(t,a)},handleDelegateHide:function(e){mt(e.target,t.options.target)&&i.call(t)}}},_addMutationObserver:c,_createPopperInstance:o,_onTransitionEnd:m}}(),T=Jt.Tippy,Zt=Jt._getEventListeners,$t=Jt._createPopperInstance,te=Jt._addMutationObserver,ee=1;return vt.browser=At,vt.defaults=St,function(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:'';if(Ot&&At.supported){var e=document.head||document.querySelector('head'),a=document.createElement('style');a.type='text/css',e.insertBefore(a,e.firstChild),a.styleSheet?a.styleSheet.cssText=t:a.appendChild(document.createTextNode(t))}}('.tippy-touch{cursor:pointer!important}.tippy-notransition{-webkit-transition:none!important;transition:none!important}.tippy-popper{max-width:350px;-webkit-perspective:700px;perspective:700px;z-index:9999;outline:0;-webkit-transition-timing-function:cubic-bezier(.165,.84,.44,1);transition-timing-function:cubic-bezier(.165,.84,.44,1);pointer-events:none}.tippy-popper[data-html]{max-width:96%;max-width:calc(100% - 20px)}.tippy-popper[x-placement^=top] .tippy-backdrop{border-radius:40% 40% 0 0}.tippy-popper[x-placement^=top] .tippy-roundarrow{bottom:-8px;margin:0 6px;-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=top] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(180deg);transform:rotate(180deg)}.tippy-popper[x-placement^=top] .tippy-arrow{border-top:7px solid #333;border-right:7px solid transparent;border-left:7px solid transparent;bottom:-7px;margin:0 7px;-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=top] .tippy-backdrop{-webkit-transform-origin:0 100%;transform-origin:0 100%}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(5.5) translate(-50%,25%);transform:scale(5.5) translate(-50%,25%);opacity:1}.tippy-popper[x-placement^=top] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(1) translate(-50%,25%);transform:scale(1) translate(-50%,25%);opacity:0}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=visible]{opacity:1;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(-20px);transform:translateY(-20px)}.tippy-popper[x-placement^=top] [data-animation=perspective]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=visible]{opacity:1;-webkit-transform:translateY(-10px) rotateX(0);transform:translateY(-10px) rotateX(0)}.tippy-popper[x-placement^=top] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:translateY(0) rotateX(90deg);transform:translateY(0) rotateX(90deg)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=visible]{opacity:1;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=visible]{opacity:1;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=visible]{opacity:1;-webkit-transform:translateY(-10px) scale(1);transform:translateY(-10px) scale(1)}.tippy-popper[x-placement^=top] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(0) scale(0);transform:translateY(0) scale(0)}.tippy-popper[x-placement^=bottom] .tippy-backdrop{border-radius:0 0 30% 30%}.tippy-popper[x-placement^=bottom] .tippy-roundarrow{top:-8px;margin:0 6px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%}.tippy-popper[x-placement^=bottom] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(0);transform:rotate(0)}.tippy-popper[x-placement^=bottom] .tippy-arrow{border-bottom:7px solid #333;border-right:7px solid transparent;border-left:7px solid transparent;top:-7px;margin:0 7px;-webkit-transform-origin:50% 100%;transform-origin:50% 100%}.tippy-popper[x-placement^=bottom] .tippy-backdrop{-webkit-transform-origin:0 -100%;transform-origin:0 -100%}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(5.5) translate(-50%,-125%);transform:scale(5.5) translate(-50%,-125%);opacity:1}.tippy-popper[x-placement^=bottom] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(1) translate(-50%,-125%);transform:scale(1) translate(-50%,-125%);opacity:0}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=visible]{opacity:1;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateY(20px);transform:translateY(20px)}.tippy-popper[x-placement^=bottom] [data-animation=perspective]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=visible]{opacity:1;-webkit-transform:translateY(10px) rotateX(0);transform:translateY(10px) rotateX(0)}.tippy-popper[x-placement^=bottom] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:translateY(0) rotateX(-90deg);transform:translateY(0) rotateX(-90deg)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=visible]{opacity:1;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=visible]{opacity:1;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=visible]{opacity:1;-webkit-transform:translateY(10px) scale(1);transform:translateY(10px) scale(1)}.tippy-popper[x-placement^=bottom] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateY(0) scale(0);transform:translateY(0) scale(0)}.tippy-popper[x-placement^=left] .tippy-backdrop{border-radius:30% 0 0 30%}.tippy-popper[x-placement^=left] .tippy-roundarrow{right:-16px;margin:4px 0;-webkit-transform-origin:33.33333333% 50%;transform-origin:33.33333333% 50%}.tippy-popper[x-placement^=left] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(90deg);transform:rotate(90deg)}.tippy-popper[x-placement^=left] .tippy-arrow{border-left:7px solid #333;border-top:7px solid transparent;border-bottom:7px solid transparent;right:-7px;margin:4px 0;-webkit-transform-origin:0 50%;transform-origin:0 50%}.tippy-popper[x-placement^=left] .tippy-backdrop{-webkit-transform-origin:100% 0;transform-origin:100% 0}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(5.5) translate(33%,-50%);transform:scale(5.5) translate(33%,-50%);opacity:1}.tippy-popper[x-placement^=left] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(1.5) translate(33%,-50%);transform:scale(1.5) translate(33%,-50%);opacity:0}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=visible]{opacity:1;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(-20px);transform:translateX(-20px)}.tippy-popper[x-placement^=left] [data-animation=perspective]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=visible]{opacity:1;-webkit-transform:translateX(-10px) rotateY(0);transform:translateX(-10px) rotateY(0)}.tippy-popper[x-placement^=left] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:translateX(0) rotateY(-90deg);transform:translateX(0) rotateY(-90deg)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=visible]{opacity:1;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=visible]{opacity:1;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=visible]{opacity:1;-webkit-transform:translateX(-10px) scale(1);transform:translateX(-10px) scale(1)}.tippy-popper[x-placement^=left] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(0) scale(0);transform:translateX(0) scale(0)}.tippy-popper[x-placement^=right] .tippy-backdrop{border-radius:0 30% 30% 0}.tippy-popper[x-placement^=right] .tippy-roundarrow{left:-16px;margin:4px 0;-webkit-transform-origin:66.66666666% 50%;transform-origin:66.66666666% 50%}.tippy-popper[x-placement^=right] .tippy-roundarrow svg{position:absolute;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.tippy-popper[x-placement^=right] .tippy-arrow{border-right:7px solid #333;border-top:7px solid transparent;border-bottom:7px solid transparent;left:-7px;margin:4px 0;-webkit-transform-origin:100% 50%;transform-origin:100% 50%}.tippy-popper[x-placement^=right] .tippy-backdrop{-webkit-transform-origin:-100% 0;transform-origin:-100% 0}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=visible]{-webkit-transform:scale(5.5) translate(-133%,-50%);transform:scale(5.5) translate(-133%,-50%);opacity:1}.tippy-popper[x-placement^=right] .tippy-backdrop[data-state=hidden]{-webkit-transform:scale(1.5) translate(-133%,-50%);transform:scale(1.5) translate(-133%,-50%);opacity:0}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=visible]{opacity:1;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-toward][data-state=hidden]{opacity:0;-webkit-transform:translateX(20px);transform:translateX(20px)}.tippy-popper[x-placement^=right] [data-animation=perspective]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=visible]{opacity:1;-webkit-transform:translateX(10px) rotateY(0);transform:translateX(10px) rotateY(0)}.tippy-popper[x-placement^=right] [data-animation=perspective][data-state=hidden]{opacity:0;-webkit-transform:translateX(0) rotateY(90deg);transform:translateX(0) rotateY(90deg)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=visible]{opacity:1;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=fade][data-state=hidden]{opacity:0;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=visible]{opacity:1;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift-away][data-state=hidden]{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=visible]{opacity:1;-webkit-transform:translateX(10px) scale(1);transform:translateX(10px) scale(1)}.tippy-popper[x-placement^=right] [data-animation=scale][data-state=hidden]{opacity:0;-webkit-transform:translateX(0) scale(0);transform:translateX(0) scale(0)}.tippy-tooltip{position:relative;color:#fff;border-radius:4px;font-size:.9rem;padding:.3rem .6rem;text-align:center;will-change:transform;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#333}.tippy-tooltip[data-size=small]{padding:.2rem .4rem;font-size:.75rem}.tippy-tooltip[data-size=large]{padding:.4rem .8rem;font-size:1rem}.tippy-tooltip[data-animatefill]{overflow:hidden;background-color:transparent}.tippy-tooltip[data-animatefill] .tippy-content{-webkit-transition:-webkit-clip-path cubic-bezier(.46,.1,.52,.98);transition:-webkit-clip-path cubic-bezier(.46,.1,.52,.98);transition:clip-path cubic-bezier(.46,.1,.52,.98);transition:clip-path cubic-bezier(.46,.1,.52,.98),-webkit-clip-path cubic-bezier(.46,.1,.52,.98)}.tippy-tooltip[data-interactive]{pointer-events:auto}.tippy-tooltip[data-inertia][data-state=visible]{-webkit-transition-timing-function:cubic-bezier(.53,2,.36,.85);transition-timing-function:cubic-bezier(.53,2,.36,.85)}.tippy-tooltip[data-inertia][data-state=hidden]{-webkit-transition-timing-function:ease;transition-timing-function:ease}.tippy-arrow,.tippy-roundarrow{position:absolute;width:0;height:0}.tippy-roundarrow{width:24px;height:8px;fill:#333;pointer-events:none}.tippy-roundarrow path{pointer-events:auto}.tippy-backdrop{position:absolute;will-change:transform;background-color:#333;border-radius:50%;width:26%;left:50%;top:50%;z-index:-1;-webkit-transition:all cubic-bezier(.46,.1,.52,.98);transition:all cubic-bezier(.46,.1,.52,.98);-webkit-backface-visibility:hidden;backface-visibility:hidden}.tippy-backdrop:after{content:"";float:left;padding-top:100%}body:not(.tippy-touch) .tippy-tooltip[data-animatefill][data-state=visible] .tippy-content{-webkit-clip-path:ellipse(100% 100% at 50% 50%);clip-path:ellipse(100% 100% at 50% 50%)}body:not(.tippy-touch) .tippy-tooltip[data-animatefill][data-state=hidden] .tippy-content{-webkit-clip-path:ellipse(5% 50% at 50% 50%);clip-path:ellipse(5% 50% at 50% 50%)}body:not(.tippy-touch) .tippy-popper[x-placement=right] .tippy-tooltip[data-animatefill][data-state=visible] .tippy-content{-webkit-clip-path:ellipse(135% 100% at 0 50%);clip-path:ellipse(135% 100% at 0 50%)}body:not(.tippy-touch) .tippy-popper[x-placement=right] .tippy-tooltip[data-animatefill][data-state=hidden] .tippy-content{-webkit-clip-path:ellipse(25% 100% at 0 50%);clip-path:ellipse(25% 100% at 0 50%)}body:not(.tippy-touch) .tippy-popper[x-placement=left] .tippy-tooltip[data-animatefill][data-state=visible] .tippy-content{-webkit-clip-path:ellipse(135% 100% at 100% 50%);clip-path:ellipse(135% 100% at 100% 50%)}body:not(.tippy-touch) .tippy-popper[x-placement=left] .tippy-tooltip[data-animatefill][data-state=hidden] .tippy-content{-webkit-clip-path:ellipse(25% 100% at 100% 50%);clip-path:ellipse(25% 100% at 100% 50%)}@media (max-width:360px){.tippy-popper{max-width:96%;max-width:calc(100% - 20px)}}'),vt});


/***/ }),

/***/ "./src/js/uPlot.esm.js":
/*!*****************************!*\
  !*** ./src/js/uPlot.esm.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ uPlot)
/* harmony export */ });
/**
* Copyright (c) 2023, Leon Sorokin
* All rights reserved. (MIT Licensed)
*
* uPlot.js (μPlot)
* A small, fast chart for time series, lines, areas, ohlc & bars
* https://github.com/leeoniya/uPlot (v1.6.25)
*/

const FEAT_TIME          = true;

const pre = "u-";

const UPLOT          =       "uplot";
const ORI_HZ         = pre + "hz";
const ORI_VT         = pre + "vt";
const TITLE          = pre + "title";
const WRAP           = pre + "wrap";
const UNDER          = pre + "under";
const OVER           = pre + "over";
const AXIS           = pre + "axis";
const OFF            = pre + "off";
const SELECT         = pre + "select";
const CURSOR_X       = pre + "cursor-x";
const CURSOR_Y       = pre + "cursor-y";
const CURSOR_PT      = pre + "cursor-pt";
const LEGEND         = pre + "legend";
const LEGEND_LIVE    = pre + "live";
const LEGEND_INLINE  = pre + "inline";
const LEGEND_SERIES  = pre + "series";
const LEGEND_MARKER  = pre + "marker";
const LEGEND_LABEL   = pre + "label";
const LEGEND_VALUE   = pre + "value";

const WIDTH       = "width";
const HEIGHT      = "height";
const TOP         = "top";
const BOTTOM      = "bottom";
const LEFT        = "left";
const RIGHT       = "right";
const hexBlack    = "#000";
const transparent = hexBlack + "0";

const mousemove   = "mousemove";
const mousedown   = "mousedown";
const mouseup     = "mouseup";
const mouseenter  = "mouseenter";
const mouseleave  = "mouseleave";
const dblclick    = "dblclick";
const resize      = "resize";
const scroll      = "scroll";

const change      = "change";
const dppxchange  = "dppxchange";

const LEGEND_DISP = "--";

const domEnv = typeof window != 'undefined';

const doc = domEnv ? document  : null;
const win = domEnv ? window    : null;
const nav = domEnv ? navigator : null;

let pxRatio;

//export const canHover = domEnv && !win.matchMedia('(hover: none)').matches;

let query;

function setPxRatio() {
	let _pxRatio = devicePixelRatio;

	// during print preview, Chrome fires off these dppx queries even without changes
	if (pxRatio != _pxRatio) {
		pxRatio = _pxRatio;

		query && off(change, query, setPxRatio);
		query = matchMedia(`(min-resolution: ${pxRatio - 0.001}dppx) and (max-resolution: ${pxRatio + 0.001}dppx)`);
		on(change, query, setPxRatio);

		win.dispatchEvent(new CustomEvent(dppxchange));
	}
}

function addClass(el, c) {
	if (c != null) {
		let cl = el.classList;
		!cl.contains(c) && cl.add(c);
	}
}

function remClass(el, c) {
	let cl = el.classList;
	cl.contains(c) && cl.remove(c);
}

function setStylePx(el, name, value) {
	el.style[name] = value + "px";
}

function placeTag(tag, cls, targ, refEl) {
	let el = doc.createElement(tag);

	if (cls != null)
		addClass(el, cls);

	if (targ != null)
		targ.insertBefore(el, refEl);

	return el;
}

function placeDiv(cls, targ) {
	return placeTag("div", cls, targ);
}

const xformCache = new WeakMap();

function elTrans(el, xPos, yPos, xMax, yMax) {
	let xform = "translate(" + xPos + "px," + yPos + "px)";
	let xformOld = xformCache.get(el);

	if (xform != xformOld) {
		el.style.transform = xform;
		xformCache.set(el, xform);

		if (xPos < 0 || yPos < 0 || xPos > xMax || yPos > yMax)
			addClass(el, OFF);
		else
			remClass(el, OFF);
	}
}

const colorCache = new WeakMap();

function elColor(el, background, borderColor) {
	let newColor = background + borderColor;
	let oldColor = colorCache.get(el);

	if (newColor != oldColor) {
		colorCache.set(el, newColor);
		el.style.background = background;
		el.style.borderColor = borderColor;
	}
}

const sizeCache = new WeakMap();

function elSize(el, newWid, newHgt, centered) {
	let newSize = newWid + "" + newHgt;
	let oldSize = sizeCache.get(el);

	if (newSize != oldSize) {
		sizeCache.set(el, newSize);
		el.style.height = newHgt + "px";
		el.style.width = newWid + "px";
		el.style.marginLeft = centered ? -newWid/2 + "px" : 0;
		el.style.marginTop = centered ? -newHgt/2 + "px" : 0;
	}
}

const evOpts = {passive: true};
const evOpts2 = {...evOpts, capture: true};

function on(ev, el, cb, capt) {
	el.addEventListener(ev, cb, capt ? evOpts2 : evOpts);
}

function off(ev, el, cb, capt) {
	el.removeEventListener(ev, cb, capt ? evOpts2 : evOpts);
}

domEnv && setPxRatio();

// binary search for index of closest value
function closestIdx(num, arr, lo, hi) {
	let mid;
	lo = lo || 0;
	hi = hi || arr.length - 1;
	let bitwise = hi <= 2147483647;

	while (hi - lo > 1) {
		mid = bitwise ? (lo + hi) >> 1 : floor((lo + hi) / 2);

		if (arr[mid] < num)
			lo = mid;
		else
			hi = mid;
	}

	if (num - arr[lo] <= arr[hi] - num)
		return lo;

	return hi;
}

function nonNullIdx(data, _i0, _i1, dir) {
	for (let i = dir == 1 ? _i0 : _i1; i >= _i0 && i <= _i1; i += dir) {
		if (data[i] != null)
			return i;
	}

	return -1;
}

function getMinMax(data, _i0, _i1, sorted) {
//	console.log("getMinMax()");

	let _min = inf;
	let _max = -inf;

	if (sorted == 1) {
		_min = data[_i0];
		_max = data[_i1];
	}
	else if (sorted == -1) {
		_min = data[_i1];
		_max = data[_i0];
	}
	else {
		for (let i = _i0; i <= _i1; i++) {
			let v = data[i];

			if (v != null) {
				if (v < _min)
					_min = v;
				if (v > _max)
					_max = v;
			}
		}
	}

	return [_min, _max];
}

function getMinMaxLog(data, _i0, _i1) {
//	console.log("getMinMax()");

	let _min = inf;
	let _max = -inf;

	for (let i = _i0; i <= _i1; i++) {
		let v = data[i];

		if (v != null && v > 0) {
			if (v < _min)
				_min = v;
			if (v > _max)
				_max = v;
		}
	}

	return [
		_min ==  inf ?  1 : _min,
		_max == -inf ? 10 : _max,
	];
}

function rangeLog(min, max, base, fullMags) {
	let minSign = sign(min);
	let maxSign = sign(max);

	let logFn = base == 10 ? log10 : log2;

	if (min == max) {
		if (minSign == -1) {
			min *= base;
			max /= base;
		}
		else {
			min /= base;
			max *= base;
		}
	}

	let growMinAbs = minSign == 1 ? floor : ceil;
	let growMaxAbs = maxSign == 1 ? ceil : floor;

	let minExp = growMinAbs(logFn(abs(min)));
	let maxExp = growMaxAbs(logFn(abs(max)));

	let minIncr = pow(base, minExp);
	let maxIncr = pow(base, maxExp);

	// fix values like Math.pow(10, -5) === 0.000009999999999999999
	if (base == 10) {
		if (minExp < 0)
			minIncr = roundDec(minIncr, -minExp);
		if (maxExp < 0)
			maxIncr = roundDec(maxIncr, -maxExp);
	}

	if (fullMags || base == 2) {
		min = minIncr * minSign;
		max = maxIncr * maxSign;
	}
	else {
		min = incrRoundDn(min, minIncr);
		max = incrRoundUp(max, maxIncr);
	}

	return [min, max];
}

function rangeAsinh(min, max, base, fullMags) {
	let minMax = rangeLog(min, max, base, fullMags);

	if (min == 0)
		minMax[0] = 0;

	if (max == 0)
		minMax[1] = 0;

	return minMax;
}

const rangePad = 0.1;

const autoRangePart = {
	mode: 3,
	pad: rangePad,
};

const _eqRangePart = {
	pad:  0,
	soft: null,
	mode: 0,
};

const _eqRange = {
	min: _eqRangePart,
	max: _eqRangePart,
};

// this ensures that non-temporal/numeric y-axes get multiple-snapped padding added above/below
// TODO: also account for incrs when snapping to ensure top of axis gets a tick & value
function rangeNum(_min, _max, mult, extra) {
	if (isObj(mult))
		return _rangeNum(_min, _max, mult);

	_eqRangePart.pad  = mult;
	_eqRangePart.soft = extra ? 0 : null;
	_eqRangePart.mode = extra ? 3 : 0;

	return _rangeNum(_min, _max, _eqRange);
}

// nullish coalesce
function ifNull(lh, rh) {
	return lh == null ? rh : lh;
}

// checks if given index range in an array contains a non-null value
// aka a range-bounded Array.some()
function hasData(data, idx0, idx1) {
	idx0 = ifNull(idx0, 0);
	idx1 = ifNull(idx1, data.length - 1);

	while (idx0 <= idx1) {
		if (data[idx0] != null)
			return true;
		idx0++;
	}

	return false;
}

function _rangeNum(_min, _max, cfg) {
	let cmin = cfg.min;
	let cmax = cfg.max;

	let padMin = ifNull(cmin.pad, 0);
	let padMax = ifNull(cmax.pad, 0);

	let hardMin = ifNull(cmin.hard, -inf);
	let hardMax = ifNull(cmax.hard,  inf);

	let softMin = ifNull(cmin.soft,  inf);
	let softMax = ifNull(cmax.soft, -inf);

	let softMinMode = ifNull(cmin.mode, 0);
	let softMaxMode = ifNull(cmax.mode, 0);

	let delta = _max - _min;
	let deltaMag = log10(delta);

	let scalarMax = max(abs(_min), abs(_max));
	let scalarMag = log10(scalarMax);

	let scalarMagDelta = abs(scalarMag - deltaMag);

	// this handles situations like 89.7, 89.69999999999999
	// by assuming 0.001x deltas are precision errors
//	if (delta > 0 && delta < abs(_max) / 1e3)
//		delta = 0;

	// treat data as flat if delta is less than 1 billionth
	// or range is 11+ orders of magnitude below raw values, e.g. 99999999.99999996 - 100000000.00000004
	if (delta < 1e-9 || scalarMagDelta > 10) {
		delta = 0;

		// if soft mode is 2 and all vals are flat at 0, avoid the 0.1 * 1e3 fallback
		// this prevents 0,0,0 from ranging to -100,100 when softMin/softMax are -1,1
		if (_min == 0 || _max == 0) {
			delta = 1e-9;

			if (softMinMode == 2 && softMin != inf)
				padMin = 0;

			if (softMaxMode == 2 && softMax != -inf)
				padMax = 0;
		}
	}

	let nonZeroDelta = delta || scalarMax || 1e3;
	let mag          = log10(nonZeroDelta);
	let base         = pow(10, floor(mag));

	let _padMin  = nonZeroDelta * (delta == 0 ? (_min == 0 ? .1 : 1) : padMin);
	let _newMin  = roundDec(incrRoundDn(_min - _padMin, base/10), 9);
	let _softMin = _min >= softMin && (softMinMode == 1 || softMinMode == 3 && _newMin <= softMin || softMinMode == 2 && _newMin >= softMin) ? softMin : inf;
	let minLim   = max(hardMin, _newMin < _softMin && _min >= _softMin ? _softMin : min(_softMin, _newMin));

	let _padMax  = nonZeroDelta * (delta == 0 ? (_max == 0 ? .1 : 1) : padMax);
	let _newMax  = roundDec(incrRoundUp(_max + _padMax, base/10), 9);
	let _softMax = _max <= softMax && (softMaxMode == 1 || softMaxMode == 3 && _newMax >= softMax || softMaxMode == 2 && _newMax <= softMax) ? softMax : -inf;
	let maxLim   = min(hardMax, _newMax > _softMax && _max <= _softMax ? _softMax : max(_softMax, _newMax));

	if (minLim == maxLim && minLim == 0)
		maxLim = 100;

	return [minLim, maxLim];
}

// alternative: https://stackoverflow.com/a/2254896
const numFormatter = new Intl.NumberFormat(domEnv ? nav.language : 'en-US');
const fmtNum = val => numFormatter.format(val);

const M = Math;

const PI = M.PI;
const abs = M.abs;
const floor = M.floor;
const round = M.round;
const ceil = M.ceil;
const min = M.min;
const max = M.max;
const pow = M.pow;
const sign = M.sign;
const log10 = M.log10;
const log2 = M.log2;
// TODO: seems like this needs to match asinh impl if the passed v is tweaked?
const sinh =  (v, linthresh = 1) => M.sinh(v) * linthresh;
const asinh = (v, linthresh = 1) => M.asinh(v / linthresh);

const inf = Infinity;

function numIntDigits(x) {
	return (log10((x ^ (x >> 31)) - (x >> 31)) | 0) + 1;
}

function clamp(num, _min, _max) {
	return min(max(num, _min), _max);
}

function fnOrSelf(v) {
	return typeof v == "function" ? v : () => v;
}

const noop = () => {};

const retArg0 = _0 => _0;

const retArg1 = (_0, _1) => _1;

const retNull = _ => null;

const retTrue = _ => true;

const retEq = (a, b) => a == b;

// this will probably prevent tick incrs > 14 decimal places
// (we generate up to 17 dec, see fixedDec const)
const fixFloat = v => roundDec(v, 14);

function incrRound(num, incr) {
	return fixFloat(roundDec(fixFloat(num/incr))*incr);
}

function incrRoundUp(num, incr) {
	return fixFloat(ceil(fixFloat(num/incr))*incr);
}

function incrRoundDn(num, incr) {
	return fixFloat(floor(fixFloat(num/incr))*incr);
}

// https://stackoverflow.com/a/48764436
// rounds half away from zero
function roundDec(val, dec = 0) {
	if (isInt(val))
		return val;
//	else if (dec == 0)
//		return round(val);

	let p = 10 ** dec;
	let n = (val * p) * (1 + Number.EPSILON);
	return round(n) / p;
}

const fixedDec = new Map();

function guessDec(num) {
	return ((""+num).split(".")[1] || "").length;
}

function genIncrs(base, minExp, maxExp, mults) {
	let incrs = [];

	let multDec = mults.map(guessDec);

	for (let exp = minExp; exp < maxExp; exp++) {
		let expa = abs(exp);
		let mag = roundDec(pow(base, exp), expa);

		for (let i = 0; i < mults.length; i++) {
			let _incr = mults[i] * mag;
			let dec = (_incr >= 0 && exp >= 0 ? 0 : expa) + (exp >= multDec[i] ? 0 : multDec[i]);
			let incr = roundDec(_incr, dec);
			incrs.push(incr);
			fixedDec.set(incr, dec);
		}
	}

	return incrs;
}

//export const assign = Object.assign;

const EMPTY_OBJ = {};
const EMPTY_ARR = [];

const nullNullTuple = [null, null];

const isArr = Array.isArray;
const isInt = Number.isInteger;
const isUndef = v => v === void 0;

function isStr(v) {
	return typeof v == 'string';
}

function isObj(v) {
	let is = false;

	if (v != null) {
		let c = v.constructor;
		is = c == null || c == Object;
	}

	return is;
}

function fastIsObj(v) {
	return v != null && typeof v == 'object';
}

const TypedArray = Object.getPrototypeOf(Uint8Array);

function copy(o, _isObj = isObj) {
	let out;

	if (isArr(o)) {
		let val = o.find(v => v != null);

		if (isArr(val) || _isObj(val)) {
			out = Array(o.length);
			for (let i = 0; i < o.length; i++)
				out[i] = copy(o[i], _isObj);
		}
		else
			out = o.slice();
	}
	else if (o instanceof TypedArray) // also (ArrayBuffer.isView(o) && !(o instanceof DataView))
		out = o.slice();
	else if (_isObj(o)) {
		out = {};
		for (let k in o)
			out[k] = copy(o[k], _isObj);
	}
	else
		out = o;

	return out;
}

function assign(targ) {
	let args = arguments;

	for (let i = 1; i < args.length; i++) {
		let src = args[i];

		for (let key in src) {
			if (isObj(targ[key]))
				assign(targ[key], copy(src[key]));
			else
				targ[key] = copy(src[key]);
		}
	}

	return targ;
}

// nullModes
const NULL_REMOVE = 0;  // nulls are converted to undefined (e.g. for spanGaps: true)
const NULL_RETAIN = 1;  // nulls are retained, with alignment artifacts set to undefined (default)
const NULL_EXPAND = 2;  // nulls are expanded to include any adjacent alignment artifacts

// sets undefined values to nulls when adjacent to existing nulls (minesweeper)
function nullExpand(yVals, nullIdxs, alignedLen) {
	for (let i = 0, xi, lastNullIdx = -1; i < nullIdxs.length; i++) {
		let nullIdx = nullIdxs[i];

		if (nullIdx > lastNullIdx) {
			xi = nullIdx - 1;
			while (xi >= 0 && yVals[xi] == null)
				yVals[xi--] = null;

			xi = nullIdx + 1;
			while (xi < alignedLen && yVals[xi] == null)
				yVals[lastNullIdx = xi++] = null;
		}
	}
}

// nullModes is a tables-matched array indicating how to treat nulls in each series
// output is sorted ASC on the joined field (table[0]) and duplicate join values are collapsed
function join(tables, nullModes) {
	if (allHeadersSame(tables)) {
	//	console.log('cheap join!');

		let table = tables[0].slice();

		for (let i = 1; i < tables.length; i++)
			table.push(...tables[i].slice(1));

		if (!isAsc(table[0]))
			table = sortCols(table);

		return table;
	}

	let xVals = new Set();

	for (let ti = 0; ti < tables.length; ti++) {
		let t = tables[ti];
		let xs = t[0];
		let len = xs.length;

		for (let i = 0; i < len; i++)
			xVals.add(xs[i]);
	}

	let data = [Array.from(xVals).sort((a, b) => a - b)];

	let alignedLen = data[0].length;

	let xIdxs = new Map();

	for (let i = 0; i < alignedLen; i++)
		xIdxs.set(data[0][i], i);

	for (let ti = 0; ti < tables.length; ti++) {
		let t = tables[ti];
		let xs = t[0];

		for (let si = 1; si < t.length; si++) {
			let ys = t[si];

			let yVals = Array(alignedLen).fill(undefined);

			let nullMode = nullModes ? nullModes[ti][si] : NULL_RETAIN;

			let nullIdxs = [];

			for (let i = 0; i < ys.length; i++) {
				let yVal = ys[i];
				let alignedIdx = xIdxs.get(xs[i]);

				if (yVal === null) {
					if (nullMode != NULL_REMOVE) {
						yVals[alignedIdx] = yVal;

						if (nullMode == NULL_EXPAND)
							nullIdxs.push(alignedIdx);
					}
				}
				else
					yVals[alignedIdx] = yVal;
			}

			nullExpand(yVals, nullIdxs, alignedLen);

			data.push(yVals);
		}
	}

	return data;
}

const microTask = typeof queueMicrotask == "undefined" ? fn => Promise.resolve().then(fn) : queueMicrotask;

// TODO: https://github.com/dy/sort-ids (~2x faster for 1e5+ arrays)
function sortCols(table) {
	let head = table[0];
	let rlen = head.length;

	let idxs = Array(rlen);
	for (let i = 0; i < idxs.length; i++)
		idxs[i] = i;

	idxs.sort((i0, i1) => head[i0] - head[i1]);

	let table2 = [];
	for (let i = 0; i < table.length; i++) {
		let row = table[i];
		let row2 = Array(rlen);

		for (let j = 0; j < rlen; j++)
			row2[j] = row[idxs[j]];

		table2.push(row2);
	}

	return table2;
}

// test if we can do cheap join (all join fields same)
function allHeadersSame(tables) {
	let vals0 = tables[0][0];
	let len0 = vals0.length;

	for (let i = 1; i < tables.length; i++) {
		let vals1 = tables[i][0];

		if (vals1.length != len0)
			return false;

		if (vals1 != vals0) {
			for (let j = 0; j < len0; j++) {
				if (vals1[j] != vals0[j])
					return false;
			}
		}
	}

	return true;
}

function isAsc(vals, samples = 100) {
	const len = vals.length;

	// empty or single value
	if (len <= 1)
		return true;

	// skip leading & trailing nullish
	let firstIdx = 0;
	let lastIdx = len - 1;

	while (firstIdx <= lastIdx && vals[firstIdx] == null)
		firstIdx++;

	while (lastIdx >= firstIdx && vals[lastIdx] == null)
		lastIdx--;

	// all nullish or one value surrounded by nullish
	if (lastIdx <= firstIdx)
		return true;

	const stride = max(1, floor((lastIdx - firstIdx + 1) / samples));

	for (let prevVal = vals[firstIdx], i = firstIdx + stride; i <= lastIdx; i += stride) {
		const v = vals[i];

		if (v != null) {
			if (v <= prevVal)
				return false;

			prevVal = v;
		}
	}

	return true;
}

const months = [
	"January",
	"February",
	"March",
	"April",
	"May",
	"June",
	"July",
	"August",
	"September",
	"October",
	"November",
	"December",
];

const days = [
	"Sunday",
	"Monday",
	"Tuesday",
	"Wednesday",
	"Thursday",
	"Friday",
	"Saturday",
];

function slice3(str) {
	return str.slice(0, 3);
}

const days3 = days.map(slice3);

const months3 = months.map(slice3);

const engNames = {
	MMMM: months,
	MMM:  months3,
	WWWW: days,
	WWW:  days3,
};

function zeroPad2(int) {
	return (int < 10 ? '0' : '') + int;
}

function zeroPad3(int) {
	return (int < 10 ? '00' : int < 100 ? '0' : '') + int;
}

/*
function suffix(int) {
	let mod10 = int % 10;

	return int + (
		mod10 == 1 && int != 11 ? "st" :
		mod10 == 2 && int != 12 ? "nd" :
		mod10 == 3 && int != 13 ? "rd" : "th"
	);
}
*/

const subs = {
	// 2019
	YYYY:	d => d.getFullYear(),
	// 19
	YY:		d => (d.getFullYear()+'').slice(2),
	// July
	MMMM:	(d, names) => names.MMMM[d.getMonth()],
	// Jul
	MMM:	(d, names) => names.MMM[d.getMonth()],
	// 07
	MM:		d => zeroPad2(d.getMonth()+1),
	// 7
	M:		d => d.getMonth()+1,
	// 09
	DD:		d => zeroPad2(d.getDate()),
	// 9
	D:		d => d.getDate(),
	// Monday
	WWWW:	(d, names) => names.WWWW[d.getDay()],
	// Mon
	WWW:	(d, names) => names.WWW[d.getDay()],
	// 03
	HH:		d => zeroPad2(d.getHours()),
	// 3
	H:		d => d.getHours(),
	// 9 (12hr, unpadded)
	h:		d => {let h = d.getHours(); return h == 0 ? 12 : h > 12 ? h - 12 : h;},
	// AM
	AA:		d => d.getHours() >= 12 ? 'PM' : 'AM',
	// am
	aa:		d => d.getHours() >= 12 ? 'pm' : 'am',
	// a
	a:		d => d.getHours() >= 12 ? 'p' : 'a',
	// 09
	mm:		d => zeroPad2(d.getMinutes()),
	// 9
	m:		d => d.getMinutes(),
	// 09
	ss:		d => zeroPad2(d.getSeconds()),
	// 9
	s:		d => d.getSeconds(),
	// 374
	fff:	d => zeroPad3(d.getMilliseconds()),
};

function fmtDate(tpl, names) {
	names = names || engNames;
	let parts = [];

	let R = /\{([a-z]+)\}|[^{]+/gi, m;

	while (m = R.exec(tpl))
		parts.push(m[0][0] == '{' ? subs[m[1]] : m[0]);

	return d => {
		let out = '';

		for (let i = 0; i < parts.length; i++)
			out += typeof parts[i] == "string" ? parts[i] : parts[i](d, names);

		return out;
	}
}

const localTz = new Intl.DateTimeFormat().resolvedOptions().timeZone;

// https://stackoverflow.com/questions/15141762/how-to-initialize-a-javascript-date-to-a-particular-time-zone/53652131#53652131
function tzDate(date, tz) {
	let date2;

	// perf optimization
	if (tz == 'UTC' || tz == 'Etc/UTC')
		date2 = new Date(+date + date.getTimezoneOffset() * 6e4);
	else if (tz == localTz)
		date2 = date;
	else {
		date2 = new Date(date.toLocaleString('en-US', {timeZone: tz}));
		date2.setMilliseconds(date.getMilliseconds());
	}

	return date2;
}

//export const series = [];

// default formatters:

const onlyWhole = v => v % 1 == 0;

const allMults = [1,2,2.5,5];

// ...0.01, 0.02, 0.025, 0.05, 0.1, 0.2, 0.25, 0.5
const decIncrs = genIncrs(10, -16, 0, allMults);

// 1, 2, 2.5, 5, 10, 20, 25, 50...
const oneIncrs = genIncrs(10, 0, 16, allMults);

// 1, 2,      5, 10, 20, 25, 50...
const wholeIncrs = oneIncrs.filter(onlyWhole);

const numIncrs = decIncrs.concat(oneIncrs);

const NL = "\n";

const yyyy    = "{YYYY}";
const NLyyyy  = NL + yyyy;
const md      = "{M}/{D}";
const NLmd    = NL + md;
const NLmdyy  = NLmd + "/{YY}";

const aa      = "{aa}";
const hmm     = "{h}:{mm}";
const hmmaa   = hmm + aa;
const NLhmmaa = NL + hmmaa;
const ss      = ":{ss}";

const _ = null;

function genTimeStuffs(ms) {
	let	s  = ms * 1e3,
		m  = s  * 60,
		h  = m  * 60,
		d  = h  * 24,
		mo = d  * 30,
		y  = d  * 365;

	// min of 1e-3 prevents setting a temporal x ticks too small since Date objects cannot advance ticks smaller than 1ms
	let subSecIncrs = ms == 1 ? genIncrs(10, 0, 3, allMults).filter(onlyWhole) : genIncrs(10, -3, 0, allMults);

	let timeIncrs = subSecIncrs.concat([
		// minute divisors (# of secs)
		s,
		s * 5,
		s * 10,
		s * 15,
		s * 30,
		// hour divisors (# of mins)
		m,
		m * 5,
		m * 10,
		m * 15,
		m * 30,
		// day divisors (# of hrs)
		h,
		h * 2,
		h * 3,
		h * 4,
		h * 6,
		h * 8,
		h * 12,
		// month divisors TODO: need more?
		d,
		d * 2,
		d * 3,
		d * 4,
		d * 5,
		d * 6,
		d * 7,
		d * 8,
		d * 9,
		d * 10,
		d * 15,
		// year divisors (# months, approx)
		mo,
		mo * 2,
		mo * 3,
		mo * 4,
		mo * 6,
		// century divisors
		y,
		y * 2,
		y * 5,
		y * 10,
		y * 25,
		y * 50,
		y * 100,
	]);

	// [0]:   minimum num secs in the tick incr
	// [1]:   default tick format
	// [2-7]: rollover tick formats
	// [8]:   mode: 0: replace [1] -> [2-7], 1: concat [1] + [2-7]
	const _timeAxisStamps = [
	//   tick incr    default          year                    month   day                   hour    min       sec   mode
		[y,           yyyy,            _,                      _,      _,                    _,      _,        _,       1],
		[d * 28,      "{MMM}",         NLyyyy,                 _,      _,                    _,      _,        _,       1],
		[d,           md,              NLyyyy,                 _,      _,                    _,      _,        _,       1],
		[h,           "{h}" + aa,      NLmdyy,                 _,      NLmd,                 _,      _,        _,       1],
		[m,           hmmaa,           NLmdyy,                 _,      NLmd,                 _,      _,        _,       1],
		[s,           ss,              NLmdyy + " " + hmmaa,   _,      NLmd + " " + hmmaa,   _,      NLhmmaa,  _,       1],
		[ms,          ss + ".{fff}",   NLmdyy + " " + hmmaa,   _,      NLmd + " " + hmmaa,   _,      NLhmmaa,  _,       1],
	];

	// the ensures that axis ticks, values & grid are aligned to logical temporal breakpoints and not an arbitrary timestamp
	// https://www.timeanddate.com/time/dst/
	// https://www.timeanddate.com/time/dst/2019.html
	// https://www.epochconverter.com/timezones
	function timeAxisSplits(tzDate) {
		return (self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace) => {
			let splits = [];
			let isYr = foundIncr >= y;
			let isMo = foundIncr >= mo && foundIncr < y;

			// get the timezone-adjusted date
			let minDate = tzDate(scaleMin);
			let minDateTs = roundDec(minDate * ms, 3);

			// get ts of 12am (this lands us at or before the original scaleMin)
			let minMin = mkDate(minDate.getFullYear(), isYr ? 0 : minDate.getMonth(), isMo || isYr ? 1 : minDate.getDate());
			let minMinTs = roundDec(minMin * ms, 3);

			if (isMo || isYr) {
				let moIncr = isMo ? foundIncr / mo : 0;
				let yrIncr = isYr ? foundIncr / y  : 0;
			//	let tzOffset = scaleMin - minDateTs;		// needed?
				let split = minDateTs == minMinTs ? minDateTs : roundDec(mkDate(minMin.getFullYear() + yrIncr, minMin.getMonth() + moIncr, 1) * ms, 3);
				let splitDate = new Date(round(split / ms));
				let baseYear = splitDate.getFullYear();
				let baseMonth = splitDate.getMonth();

				for (let i = 0; split <= scaleMax; i++) {
					let next = mkDate(baseYear + yrIncr * i, baseMonth + moIncr * i, 1);
					let offs = next - tzDate(roundDec(next * ms, 3));

					split = roundDec((+next + offs) * ms, 3);

					if (split <= scaleMax)
						splits.push(split);
				}
			}
			else {
				let incr0 = foundIncr >= d ? d : foundIncr;
				let tzOffset = floor(scaleMin) - floor(minDateTs);
				let split = minMinTs + tzOffset + incrRoundUp(minDateTs - minMinTs, incr0);
				splits.push(split);

				let date0 = tzDate(split);

				let prevHour = date0.getHours() + (date0.getMinutes() / m) + (date0.getSeconds() / h);
				let incrHours = foundIncr / h;

				let minSpace = self.axes[axisIdx]._space;
				let pctSpace = foundSpace / minSpace;

				while (1) {
					split = roundDec(split + foundIncr, ms == 1 ? 0 : 3);

					if (split > scaleMax)
						break;

					if (incrHours > 1) {
						let expectedHour = floor(roundDec(prevHour + incrHours, 6)) % 24;
						let splitDate = tzDate(split);
						let actualHour = splitDate.getHours();

						let dstShift = actualHour - expectedHour;

						if (dstShift > 1)
							dstShift = -1;

						split -= dstShift * h;

						prevHour = (prevHour + incrHours) % 24;

						// add a tick only if it's further than 70% of the min allowed label spacing
						let prevSplit = splits[splits.length - 1];
						let pctIncr = roundDec((split - prevSplit) / foundIncr, 3);

						if (pctIncr * pctSpace >= .7)
							splits.push(split);
					}
					else
						splits.push(split);
				}
			}

			return splits;
		}
	}

	return [
		timeIncrs,
		_timeAxisStamps,
		timeAxisSplits,
	];
}

const [ timeIncrsMs, _timeAxisStampsMs, timeAxisSplitsMs ] = genTimeStuffs(1);
const [ timeIncrsS,  _timeAxisStampsS,  timeAxisSplitsS  ] = genTimeStuffs(1e-3);

// base 2
genIncrs(2, -53, 53, [1]);

/*
console.log({
	decIncrs,
	oneIncrs,
	wholeIncrs,
	numIncrs,
	timeIncrs,
	fixedDec,
});
*/

function timeAxisStamps(stampCfg, fmtDate) {
	return stampCfg.map(s => s.map((v, i) =>
		i == 0 || i == 8 || v == null ? v : fmtDate(i == 1 || s[8] == 0 ? v : s[1] + v)
	));
}

// TODO: will need to accept spaces[] and pull incr into the loop when grid will be non-uniform, eg for log scales.
// currently we ignore this for months since they're *nearly* uniform and the added complexity is not worth it
function timeAxisVals(tzDate, stamps) {
	return (self, splits, axisIdx, foundSpace, foundIncr) => {
		let s = stamps.find(s => foundIncr >= s[0]) || stamps[stamps.length - 1];

		// these track boundaries when a full label is needed again
		let prevYear;
		let prevMnth;
		let prevDate;
		let prevHour;
		let prevMins;
		let prevSecs;

		return splits.map(split => {
			let date = tzDate(split);

			let newYear = date.getFullYear();
			let newMnth = date.getMonth();
			let newDate = date.getDate();
			let newHour = date.getHours();
			let newMins = date.getMinutes();
			let newSecs = date.getSeconds();

			let stamp = (
				newYear != prevYear && s[2] ||
				newMnth != prevMnth && s[3] ||
				newDate != prevDate && s[4] ||
				newHour != prevHour && s[5] ||
				newMins != prevMins && s[6] ||
				newSecs != prevSecs && s[7] ||
				                       s[1]
			);

			prevYear = newYear;
			prevMnth = newMnth;
			prevDate = newDate;
			prevHour = newHour;
			prevMins = newMins;
			prevSecs = newSecs;

			return stamp(date);
		});
	}
}

// for when axis.values is defined as a static fmtDate template string
function timeAxisVal(tzDate, dateTpl) {
	let stamp = fmtDate(dateTpl);
	return (self, splits, axisIdx, foundSpace, foundIncr) => splits.map(split => stamp(tzDate(split)));
}

function mkDate(y, m, d) {
	return new Date(y, m, d);
}

function timeSeriesStamp(stampCfg, fmtDate) {
	return fmtDate(stampCfg);
}
const _timeSeriesStamp = '{YYYY}-{MM}-{DD} {h}:{mm}{aa}';

function timeSeriesVal(tzDate, stamp) {
	return (self, val, seriesIdx, dataIdx) => dataIdx == null ? LEGEND_DISP : stamp(tzDate(val));
}

function legendStroke(self, seriesIdx) {
	let s = self.series[seriesIdx];
	return s.width ? s.stroke(self, seriesIdx) : s.points.width ? s.points.stroke(self, seriesIdx) : null;
}

function legendFill(self, seriesIdx) {
	return self.series[seriesIdx].fill(self, seriesIdx);
}

const legendOpts = {
	show: true,
	live: true,
	isolate: false,
	mount: noop,
	markers: {
		show: true,
		width: 2,
		stroke: legendStroke,
		fill: legendFill,
		dash: "solid",
	},
	idx: null,
	idxs: null,
	values: [],
};

function cursorPointShow(self, si) {
	let o = self.cursor.points;

	let pt = placeDiv();

	let size = o.size(self, si);
	setStylePx(pt, WIDTH, size);
	setStylePx(pt, HEIGHT, size);

	let mar = size / -2;
	setStylePx(pt, "marginLeft", mar);
	setStylePx(pt, "marginTop", mar);

	let width = o.width(self, si, size);
	width && setStylePx(pt, "borderWidth", width);

	return pt;
}

function cursorPointFill(self, si) {
	let sp = self.series[si].points;
	return sp._fill || sp._stroke;
}

function cursorPointStroke(self, si) {
	let sp = self.series[si].points;
	return sp._stroke || sp._fill;
}

function cursorPointSize(self, si) {
	let sp = self.series[si].points;
	return sp.size;
}

function dataIdx(self, seriesIdx, cursorIdx) {
	return cursorIdx;
}

const moveTuple = [0,0];

function cursorMove(self, mouseLeft1, mouseTop1) {
	moveTuple[0] = mouseLeft1;
	moveTuple[1] = mouseTop1;
	return moveTuple;
}

function filtBtn0(self, targ, handle, onlyTarg = true) {
	return e => {
		e.button == 0 && (!onlyTarg || e.target == targ) && handle(e);
	};
}

function filtTarg(self, targ, handle, onlyTarg = true) {
	return e => {
		(!onlyTarg || e.target == targ) && handle(e);
	};
}

const cursorOpts = {
	show: true,
	x: true,
	y: true,
	lock: false,
	move: cursorMove,
	points: {
		show:   cursorPointShow,
		size:   cursorPointSize,
		width:  0,
		stroke: cursorPointStroke,
		fill:   cursorPointFill,
	},

	bind: {
		mousedown:   filtBtn0,
		mouseup:     filtBtn0,
		click:       filtBtn0, // legend clicks, not .u-over clicks
		dblclick:    filtBtn0,

		mousemove:   filtTarg,
		mouseleave:  filtTarg,
		mouseenter:  filtTarg,
	},

	drag: {
		setScale: true,
		x: true,
		y: false,
		dist: 0,
		uni: null,
		click: (self, e) => {
		//	e.preventDefault();
			e.stopPropagation();
			e.stopImmediatePropagation();
		},
		_x: false,
		_y: false,
	},

	focus: {
		prox: -1,
		bias: 0,
	},

	left: -10,
	top: -10,
	idx: null,
	dataIdx,
	idxs: null,

	event: null,
};

const axisLines = {
	show: true,
	stroke: "rgba(0,0,0,0.07)",
	width: 2,
//	dash: [],
};

const grid = assign({}, axisLines, {
	filter: retArg1,
});

const ticks = assign({}, grid, {
	size: 10,
});

const border = assign({}, axisLines, {
	show: false,
});

const font      = '12px system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"';
const labelFont = "bold " + font;
const lineGap = 1.5;	// font-size multiplier

const xAxisOpts = {
	show: true,
	scale: "x",
	stroke: hexBlack,
	space: 50,
	gap: 5,
	size: 50,
	labelGap: 0,
	labelSize: 30,
	labelFont,
	side: 2,
//	class: "x-vals",
//	incrs: timeIncrs,
//	values: timeVals,
//	filter: retArg1,
	grid,
	ticks,
	border,
	font,
	lineGap,
	rotate: 0,
};

const numSeriesLabel = "Value";
const timeSeriesLabel = "Time";

const xSeriesOpts = {
	show: true,
	scale: "x",
	auto: false,
	sorted: 1,
//	label: "Time",
//	value: v => stamp(new Date(v * 1e3)),

	// internal caches
	min: inf,
	max: -inf,
	idxs: [],
};

function numAxisVals(self, splits, axisIdx, foundSpace, foundIncr) {
	return splits.map(v => v == null ? "" : fmtNum(v));
}

function numAxisSplits(self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {
	let splits = [];

	let numDec = fixedDec.get(foundIncr) || 0;

	scaleMin = forceMin ? scaleMin : roundDec(incrRoundUp(scaleMin, foundIncr), numDec);

	for (let val = scaleMin; val <= scaleMax; val = roundDec(val + foundIncr, numDec))
		splits.push(Object.is(val, -0) ? 0 : val);		// coalesces -0

	return splits;
}

// this doesnt work for sin, which needs to come off from 0 independently in pos and neg dirs
function logAxisSplits(self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {
	const splits = [];

	const logBase = self.scales[self.axes[axisIdx].scale].log;

	const logFn = logBase == 10 ? log10 : log2;

	const exp = floor(logFn(scaleMin));

	foundIncr = pow(logBase, exp);

	if (logBase == 10 && exp < 0)
		foundIncr = roundDec(foundIncr, -exp);

	let split = scaleMin;

	do {
		splits.push(split);
		split = split + foundIncr;

		if (logBase == 10)
			split = roundDec(split, fixedDec.get(foundIncr));

		if (split >= foundIncr * logBase)
			foundIncr = split;

	} while (split <= scaleMax);

	return splits;
}

function asinhAxisSplits(self, axisIdx, scaleMin, scaleMax, foundIncr, foundSpace, forceMin) {
	let sc = self.scales[self.axes[axisIdx].scale];

	let linthresh = sc.asinh;

	let posSplits = scaleMax > linthresh ? logAxisSplits(self, axisIdx, max(linthresh, scaleMin), scaleMax, foundIncr) : [linthresh];
	let zero = scaleMax >= 0 && scaleMin <= 0 ? [0] : [];
	let negSplits = scaleMin < -linthresh ? logAxisSplits(self, axisIdx, max(linthresh, -scaleMax), -scaleMin, foundIncr): [linthresh];

	return negSplits.reverse().map(v => -v).concat(zero, posSplits);
}

const RE_ALL   = /./;
const RE_12357 = /[12357]/;
const RE_125   = /[125]/;
const RE_1     = /1/;

const _filt = (splits, distr, re, keepMod) => splits.map((v, i) => ((distr == 4 && v == 0) || i % keepMod == 0 && re.test(v.toExponential()[v < 0 ? 1 : 0])) ? v : null);

function log10AxisValsFilt(self, splits, axisIdx, foundSpace, foundIncr) {
	let axis = self.axes[axisIdx];
	let scaleKey = axis.scale;
	let sc = self.scales[scaleKey];

//	if (sc.distr == 3 && sc.log == 2)
//		return splits;

	let valToPos = self.valToPos;

	let minSpace = axis._space;

	let _10 = valToPos(10, scaleKey);

	let re = (
		valToPos(9, scaleKey) - _10 >= minSpace ? RE_ALL :
		valToPos(7, scaleKey) - _10 >= minSpace ? RE_12357 :
		valToPos(5, scaleKey) - _10 >= minSpace ? RE_125 :
		RE_1
	);

	if (re == RE_1) {
		let magSpace = abs(valToPos(1, scaleKey) - _10);

		if (magSpace < minSpace)
			return _filt(splits.slice().reverse(), sc.distr, re, ceil(minSpace / magSpace)).reverse(); // max->min skip
	}

	return _filt(splits, sc.distr, re, 1);
}

function log2AxisValsFilt(self, splits, axisIdx, foundSpace, foundIncr) {
	let axis = self.axes[axisIdx];
	let scaleKey = axis.scale;
	let minSpace = axis._space;
	let valToPos = self.valToPos;

	let magSpace = abs(valToPos(1, scaleKey) - valToPos(2, scaleKey));

	if (magSpace < minSpace)
		return _filt(splits.slice().reverse(), 3, RE_ALL, ceil(minSpace / magSpace)).reverse(); // max->min skip

	return splits;
}

function numSeriesVal(self, val, seriesIdx, dataIdx) {
	return dataIdx == null ? LEGEND_DISP : val == null ? "" : fmtNum(val);
}

const yAxisOpts = {
	show: true,
	scale: "y",
	stroke: hexBlack,
	space: 30,
	gap: 5,
	size: 50,
	labelGap: 0,
	labelSize: 30,
	labelFont,
	side: 3,
//	class: "y-vals",
//	incrs: numIncrs,
//	values: (vals, space) => vals,
//	filter: retArg1,
	grid,
	ticks,
	border,
	font,
	lineGap,
	rotate: 0,
};

// takes stroke width
function ptDia(width, mult) {
	let dia = 3 + (width || 1) * 2;
	return roundDec(dia * mult, 3);
}

function seriesPointsShow(self, si) {
	let { scale, idxs } = self.series[0];
	let xData = self._data[0];
	let p0 = self.valToPos(xData[idxs[0]], scale, true);
	let p1 = self.valToPos(xData[idxs[1]], scale, true);
	let dim = abs(p1 - p0);

	let s = self.series[si];
//	const dia = ptDia(s.width, pxRatio);
	let maxPts = dim / (s.points.space * pxRatio);
	return idxs[1] - idxs[0] <= maxPts;
}

const facet = {
	scale: null,
	auto: true,
	sorted: 0,

	// internal caches
	min: inf,
	max: -inf,
};

const gaps = (self, seriesIdx, idx0, idx1, nullGaps) => nullGaps;

const xySeriesOpts = {
	show: true,
	auto: true,
	sorted: 0,
	gaps,
	alpha: 1,
	facets: [
		assign({}, facet, {scale: 'x'}),
		assign({}, facet, {scale: 'y'}),
	],
};

const ySeriesOpts = {
	scale: "y",
	auto: true,
	sorted: 0,
	show: true,
	spanGaps: false,
	gaps,
	alpha: 1,
	points: {
		show: seriesPointsShow,
		filter: null,
	//  paths:
	//	stroke: "#000",
	//	fill: "#fff",
	//	width: 1,
	//	size: 10,
	},
//	label: "Value",
//	value: v => v,
	values: null,

	// internal caches
	min: inf,
	max: -inf,
	idxs: [],

	path: null,
	clip: null,
};

function clampScale(self, val, scaleMin, scaleMax, scaleKey) {
/*
	if (val < 0) {
		let cssHgt = self.bbox.height / pxRatio;
		let absPos = self.valToPos(abs(val), scaleKey);
		let fromBtm = cssHgt - absPos;
		return self.posToVal(cssHgt + fromBtm, scaleKey);
	}
*/
	return scaleMin / 10;
}

const xScaleOpts = {
	time: FEAT_TIME,
	auto: true,
	distr: 1,
	log: 10,
	asinh: 1,
	min: null,
	max: null,
	dir: 1,
	ori: 0,
};

const yScaleOpts = assign({}, xScaleOpts, {
	time: false,
	ori: 1,
});

const syncs = {};

function _sync(key, opts) {
	let s = syncs[key];

	if (!s) {
		s = {
			key,
			plots: [],
			sub(plot) {
				s.plots.push(plot);
			},
			unsub(plot) {
				s.plots = s.plots.filter(c => c != plot);
			},
			pub(type, self, x, y, w, h, i) {
				for (let j = 0; j < s.plots.length; j++)
					s.plots[j] != self && s.plots[j].pub(type, self, x, y, w, h, i);
			},
		};

		if (key != null)
			syncs[key] = s;
	}

	return s;
}

const BAND_CLIP_FILL   = 1 << 0;
const BAND_CLIP_STROKE = 1 << 1;

function orient(u, seriesIdx, cb) {
	const mode = u.mode;
	const series = u.series[seriesIdx];
	const data = mode == 2 ? u._data[seriesIdx] : u._data;
	const scales = u.scales;
	const bbox   = u.bbox;

	let dx = data[0],
		dy = mode == 2 ? data[1] : data[seriesIdx],
		sx = mode == 2 ? scales[series.facets[0].scale] : scales[u.series[0].scale],
		sy = mode == 2 ? scales[series.facets[1].scale] : scales[series.scale],
		l = bbox.left,
		t = bbox.top,
		w = bbox.width,
		h = bbox.height,
		H = u.valToPosH,
		V = u.valToPosV;

	return (sx.ori == 0
		? cb(
			series,
			dx,
			dy,
			sx,
			sy,
			H,
			V,
			l,
			t,
			w,
			h,
			moveToH,
			lineToH,
			rectH,
			arcH,
			bezierCurveToH,
		)
		: cb(
			series,
			dx,
			dy,
			sx,
			sy,
			V,
			H,
			t,
			l,
			h,
			w,
			moveToV,
			lineToV,
			rectV,
			arcV,
			bezierCurveToV,
		)
	);
}

function bandFillClipDirs(self, seriesIdx) {
	let fillDir = 0;

	// 2 bits, -1 | 1
	let clipDirs = 0;

	let bands = ifNull(self.bands, EMPTY_ARR);

	for (let i = 0; i < bands.length; i++) {
		let b = bands[i];

		// is a "from" band edge
		if (b.series[0] == seriesIdx)
			fillDir = b.dir;
		// is a "to" band edge
		else if (b.series[1] == seriesIdx) {
			if (b.dir == 1)
				clipDirs |= 1;
			else
				clipDirs |= 2;
		}
	}

	return [
		fillDir,
		(
			clipDirs == 1 ? -1 : // neg only
			clipDirs == 2 ?  1 : // pos only
			clipDirs == 3 ?  2 : // both
			                 0   // neither
		)
	];
}

function seriesFillTo(self, seriesIdx, dataMin, dataMax, bandFillDir) {
	let mode = self.mode;
	let series = self.series[seriesIdx];
	let scaleKey = mode == 2 ? series.facets[1].scale : series.scale;
	let scale = self.scales[scaleKey];

	return (
		bandFillDir == -1 ? scale.min :
		bandFillDir ==  1 ? scale.max :
		scale.distr ==  3 ? (
			scale.dir == 1 ? scale.min :
			scale.max
		) : 0
	);
}

// creates inverted band clip path (from stroke path -> yMax || yMin)
// clipDir is always inverse of fillDir
// default clip dir is upwards (1), since default band fill is downwards/fillBelowTo (-1) (highIdx -> lowIdx)
function clipBandLine(self, seriesIdx, idx0, idx1, strokePath, clipDir) {
	return orient(self, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
		let pxRound = series.pxRound;

		const dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);
		const lineTo = scaleX.ori == 0 ? lineToH : lineToV;

		let frIdx, toIdx;

		if (dir == 1) {
			frIdx = idx0;
			toIdx = idx1;
		}
		else {
			frIdx = idx1;
			toIdx = idx0;
		}

		// path start
		let x0 = pxRound(valToPosX(dataX[frIdx], scaleX, xDim, xOff));
		let y0 = pxRound(valToPosY(dataY[frIdx], scaleY, yDim, yOff));
		// path end x
		let x1 = pxRound(valToPosX(dataX[toIdx], scaleX, xDim, xOff));
		// upper or lower y limit
		let yLimit = pxRound(valToPosY(clipDir == 1 ? scaleY.max : scaleY.min, scaleY, yDim, yOff));

		let clip = new Path2D(strokePath);

		lineTo(clip, x1, yLimit);
		lineTo(clip, x0, yLimit);
		lineTo(clip, x0, y0);

		return clip;
	});
}

function clipGaps(gaps, ori, plotLft, plotTop, plotWid, plotHgt) {
	let clip = null;

	// create clip path (invert gaps and non-gaps)
	if (gaps.length > 0) {
		clip = new Path2D();

		const rect = ori == 0 ? rectH : rectV;

		let prevGapEnd = plotLft;

		for (let i = 0; i < gaps.length; i++) {
			let g = gaps[i];

			if (g[1] > g[0]) {
				let w = g[0] - prevGapEnd;

				w > 0 && rect(clip, prevGapEnd, plotTop, w, plotTop + plotHgt);

				prevGapEnd = g[1];
			}
		}

		let w = plotLft + plotWid - prevGapEnd;

		// hack to ensure we expand the clip enough to avoid cutting off strokes at edges
		let maxStrokeWidth = 10;

		w > 0 && rect(clip, prevGapEnd, plotTop - maxStrokeWidth / 2, w, plotTop + plotHgt + maxStrokeWidth);
	}

	return clip;
}

function addGap(gaps, fromX, toX) {
	let prevGap = gaps[gaps.length - 1];

	if (prevGap && prevGap[0] == fromX)			// TODO: gaps must be encoded at stroke widths?
		prevGap[1] = toX;
	else
		gaps.push([fromX, toX]);
}

function findGaps(xs, ys, idx0, idx1, dir, pixelForX, align) {
	let gaps = [];
	let len = xs.length;

	for (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {
		let yVal = ys[i];

		if (yVal === null) {
			let fr = i, to = i;

			if (dir == 1) {
				while (++i <= idx1 && ys[i] === null)
					to = i;
			}
			else {
				while (--i >= idx0 && ys[i] === null)
					to = i;
			}

			let frPx = pixelForX(xs[fr]);
			let toPx = to == fr ? frPx : pixelForX(xs[to]);

			// if value adjacent to edge null is same pixel, then it's partially
			// filled and gap should start at next pixel
			let fri2 = fr - dir;
			let frPx2 = align <= 0 && fri2 >= 0 && fri2 < len ? pixelForX(xs[fri2]) : frPx;
		//	if (frPx2 == frPx)
		//		frPx++;
		//	else
				frPx = frPx2;

			let toi2 = to + dir;
			let toPx2 = align >= 0 && toi2 >= 0 && toi2 < len ? pixelForX(xs[toi2]) : toPx;
		//	if (toPx2 == toPx)
		//		toPx--;
		//	else
				toPx = toPx2;

			if (toPx >= frPx)
				gaps.push([frPx, toPx]); // addGap
		}
	}

	return gaps;
}

function pxRoundGen(pxAlign) {
	return pxAlign == 0 ? retArg0 : pxAlign == 1 ? round : v => incrRound(v, pxAlign);
}

function rect(ori) {
	let moveTo = ori == 0 ?
		moveToH :
		moveToV;

	let arcTo = ori == 0 ?
		(p, x1, y1, x2, y2, r) => { p.arcTo(x1, y1, x2, y2, r); } :
		(p, y1, x1, y2, x2, r) => { p.arcTo(x1, y1, x2, y2, r); };

	let rect = ori == 0 ?
		(p, x, y, w, h) => { p.rect(x, y, w, h); } :
		(p, y, x, h, w) => { p.rect(x, y, w, h); };

	// TODO (pending better browser support): https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/roundRect
	return (p, x, y, w, h, endRad = 0, baseRad = 0) => {
		if (endRad == 0 && baseRad == 0)
			rect(p, x, y, w, h);
		else {
			endRad  = min(endRad,  w / 2, h / 2);
			baseRad = min(baseRad, w / 2, h / 2);

			// adapted from https://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-using-html-canvas/7838871#7838871
			moveTo(p, x + endRad, y);
			arcTo(p, x + w, y, x + w, y + h, endRad);
			arcTo(p, x + w, y + h, x, y + h, baseRad);
			arcTo(p, x, y + h, x, y, baseRad);
			arcTo(p, x, y, x + w, y, endRad);
			p.closePath();
		}
	};
}

// orientation-inverting canvas functions
const moveToH = (p, x, y) => { p.moveTo(x, y); };
const moveToV = (p, y, x) => { p.moveTo(x, y); };
const lineToH = (p, x, y) => { p.lineTo(x, y); };
const lineToV = (p, y, x) => { p.lineTo(x, y); };
const rectH = rect(0);
const rectV = rect(1);
const arcH = (p, x, y, r, startAngle, endAngle) => { p.arc(x, y, r, startAngle, endAngle); };
const arcV = (p, y, x, r, startAngle, endAngle) => { p.arc(x, y, r, startAngle, endAngle); };
const bezierCurveToH = (p, bp1x, bp1y, bp2x, bp2y, p2x, p2y) => { p.bezierCurveTo(bp1x, bp1y, bp2x, bp2y, p2x, p2y); };
const bezierCurveToV = (p, bp1y, bp1x, bp2y, bp2x, p2y, p2x) => { p.bezierCurveTo(bp1x, bp1y, bp2x, bp2y, p2x, p2y); };

// TODO: drawWrap(seriesIdx, drawPoints) (save, restore, translate, clip)
function points(opts) {
	return (u, seriesIdx, idx0, idx1, filtIdxs) => {
	//	log("drawPoints()", arguments);

		return orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
			let { pxRound, points } = series;

			let moveTo, arc;

			if (scaleX.ori == 0) {
				moveTo = moveToH;
				arc = arcH;
			}
			else {
				moveTo = moveToV;
				arc = arcV;
			}

			const width = roundDec(points.width * pxRatio, 3);

			let rad = (points.size - points.width) / 2 * pxRatio;
			let dia = roundDec(rad * 2, 3);

			let fill = new Path2D();
			let clip = new Path2D();

			let { left: lft, top: top, width: wid, height: hgt } = u.bbox;

			rectH(clip,
				lft - dia,
				top - dia,
				wid + dia * 2,
				hgt + dia * 2,
			);

			const drawPoint = pi => {
				if (dataY[pi] != null) {
					let x = pxRound(valToPosX(dataX[pi], scaleX, xDim, xOff));
					let y = pxRound(valToPosY(dataY[pi], scaleY, yDim, yOff));

					moveTo(fill, x + rad, y);
					arc(fill, x, y, rad, 0, PI * 2);
				}
			};

			if (filtIdxs)
				filtIdxs.forEach(drawPoint);
			else {
				for (let pi = idx0; pi <= idx1; pi++)
					drawPoint(pi);
			}

			return {
				stroke: width > 0 ? fill : null,
				fill,
				clip,
				flags: BAND_CLIP_FILL | BAND_CLIP_STROKE,
			};
		});
	};
}

function _drawAcc(lineTo) {
	return (stroke, accX, minY, maxY, inY, outY) => {
		if (minY != maxY) {
			if (inY != minY && outY != minY)
				lineTo(stroke, accX, minY);
			if (inY != maxY && outY != maxY)
				lineTo(stroke, accX, maxY);

			lineTo(stroke, accX, outY);
		}
	};
}

const drawAccH = _drawAcc(lineToH);
const drawAccV = _drawAcc(lineToV);

function linear(opts) {
	const alignGaps = ifNull(opts?.alignGaps, 0);

	return (u, seriesIdx, idx0, idx1) => {
		return orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
			let pxRound = series.pxRound;

			let pixelForX = val => pxRound(valToPosX(val, scaleX, xDim, xOff));
			let pixelForY = val => pxRound(valToPosY(val, scaleY, yDim, yOff));

			let lineTo, drawAcc;

			if (scaleX.ori == 0) {
				lineTo = lineToH;
				drawAcc = drawAccH;
			}
			else {
				lineTo = lineToV;
				drawAcc = drawAccV;
			}

			const dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);

			const _paths = {stroke: new Path2D(), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL};
			const stroke = _paths.stroke;

			let minY = inf,
				maxY = -inf,
				inY, outY, drawnAtX;

			let accX = pixelForX(dataX[dir == 1 ? idx0 : idx1]);

			// data edges
			let lftIdx = nonNullIdx(dataY, idx0, idx1,  1 * dir);
			let rgtIdx = nonNullIdx(dataY, idx0, idx1, -1 * dir);
			let lftX   =  pixelForX(dataX[lftIdx]);
			let rgtX   =  pixelForX(dataX[rgtIdx]);

			let hasGap = false;

			for (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {
				let x = pixelForX(dataX[i]);
				let yVal = dataY[i];

				if (x == accX) {
					if (yVal != null) {
						outY = pixelForY(yVal);

						if (minY == inf) {
							lineTo(stroke, x, outY);
							inY = outY;
						}

						minY = min(outY, minY);
						maxY = max(outY, maxY);
					}
					else {
						if (yVal === null)
							hasGap = true;
					}
				}
				else {
					if (minY != inf) {
						drawAcc(stroke, accX, minY, maxY, inY, outY);
						drawnAtX = accX;
					}

					if (yVal != null) {
						outY = pixelForY(yVal);
						lineTo(stroke, x, outY);
						minY = maxY = inY = outY;
					}
					else {
						minY = inf;
						maxY = -inf;

						if (yVal === null)
							hasGap = true;
					}

					accX = x;
				}
			}

			if (minY != inf && minY != maxY && drawnAtX != accX)
				drawAcc(stroke, accX, minY, maxY, inY, outY);

			let [ bandFillDir, bandClipDir ] = bandFillClipDirs(u, seriesIdx);

			if (series.fill != null || bandFillDir != 0) {
				let fill = _paths.fill = new Path2D(stroke);

				let fillToVal = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);
				let fillToY = pixelForY(fillToVal);

				lineTo(fill, rgtX, fillToY);
				lineTo(fill, lftX, fillToY);
			}

			if (!series.spanGaps) {
			//	console.time('gaps');
				let gaps = [];

				hasGap && gaps.push(...findGaps(dataX, dataY, idx0, idx1, dir, pixelForX, alignGaps));

			//	console.timeEnd('gaps');

			//	console.log('gaps', JSON.stringify(gaps));

				_paths.gaps = gaps = series.gaps(u, seriesIdx, idx0, idx1, gaps);

				_paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);
			}

			if (bandClipDir != 0) {
				_paths.band = bandClipDir == 2 ? [
					clipBandLine(u, seriesIdx, idx0, idx1, stroke, -1),
					clipBandLine(u, seriesIdx, idx0, idx1, stroke,  1),
				] : clipBandLine(u, seriesIdx, idx0, idx1, stroke, bandClipDir);
			}

			return _paths;
		});
	};
}

// BUG: align: -1 behaves like align: 1 when scale.dir: -1
function stepped(opts) {
	const align = ifNull(opts.align, 1);
	// whether to draw ascenders/descenders at null/gap bondaries
	const ascDesc = ifNull(opts.ascDesc, false);
	const alignGaps = ifNull(opts.alignGaps, 0);
	const extend = ifNull(opts.extend, false);

	return (u, seriesIdx, idx0, idx1) => {
		return orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
			let pxRound = series.pxRound;

			let { left, width } = u.bbox;

			let pixelForX = val => pxRound(valToPosX(val, scaleX, xDim, xOff));
			let pixelForY = val => pxRound(valToPosY(val, scaleY, yDim, yOff));

			let lineTo = scaleX.ori == 0 ? lineToH : lineToV;

			const _paths = {stroke: new Path2D(), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL};
			const stroke = _paths.stroke;

			const dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);

			idx0 = nonNullIdx(dataY, idx0, idx1,  1);
			idx1 = nonNullIdx(dataY, idx0, idx1, -1);

			let prevYPos  = pixelForY(dataY[dir == 1 ? idx0 : idx1]);
			let firstXPos = pixelForX(dataX[dir == 1 ? idx0 : idx1]);
			let prevXPos = firstXPos;

			let firstXPosExt = firstXPos;

			if (extend && align == -1) {
				firstXPosExt = left;
				lineTo(stroke, firstXPosExt, prevYPos);
			}

			lineTo(stroke, firstXPos, prevYPos);

			for (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {
				let yVal1 = dataY[i];

				if (yVal1 == null)
					continue;

				let x1 = pixelForX(dataX[i]);
				let y1 = pixelForY(yVal1);

				if (align == 1)
					lineTo(stroke, x1, prevYPos);
				else
					lineTo(stroke, prevXPos, y1);

				lineTo(stroke, x1, y1);

				prevYPos = y1;
				prevXPos = x1;
			}

			let prevXPosExt = prevXPos;

			if (extend && align == 1) {
				prevXPosExt = left + width;
				lineTo(stroke, prevXPosExt, prevYPos);
			}

			let [ bandFillDir, bandClipDir ] = bandFillClipDirs(u, seriesIdx);

			if (series.fill != null || bandFillDir != 0) {
				let fill = _paths.fill = new Path2D(stroke);

				let fillTo = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);
				let fillToY = pixelForY(fillTo);

				lineTo(fill, prevXPosExt, fillToY);
				lineTo(fill, firstXPosExt, fillToY);
			}

			if (!series.spanGaps) {
			//	console.time('gaps');
				let gaps = [];

				gaps.push(...findGaps(dataX, dataY, idx0, idx1, dir, pixelForX, alignGaps));

			//	console.timeEnd('gaps');

			//	console.log('gaps', JSON.stringify(gaps));

				// expand/contract clips for ascenders/descenders
				let halfStroke = (series.width * pxRatio) / 2;
				let startsOffset = (ascDesc || align ==  1) ?  halfStroke : -halfStroke;
				let endsOffset   = (ascDesc || align == -1) ? -halfStroke :  halfStroke;

				gaps.forEach(g => {
					g[0] += startsOffset;
					g[1] += endsOffset;
				});

				_paths.gaps = gaps = series.gaps(u, seriesIdx, idx0, idx1, gaps);

				_paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);
			}

			if (bandClipDir != 0) {
				_paths.band = bandClipDir == 2 ? [
					clipBandLine(u, seriesIdx, idx0, idx1, stroke, -1),
					clipBandLine(u, seriesIdx, idx0, idx1, stroke,  1),
				] : clipBandLine(u, seriesIdx, idx0, idx1, stroke, bandClipDir);
			}

			return _paths;
		});
	};
}

function bars(opts) {
	opts = opts || EMPTY_OBJ;
	const size = ifNull(opts.size, [0.6, inf, 1]);
	const align = opts.align || 0;
	const extraGap = (opts.gap || 0) * pxRatio;

	let ro = opts.radius;

	ro =
		// [valueRadius, baselineRadius]
		ro == null ? [0, 0] :
		typeof ro == 'number' ? [ro, 0] : ro;

	const radiusFn = fnOrSelf(ro);

	const gapFactor = 1 - size[0];
	const maxWidth  = ifNull(size[1], inf) * pxRatio;
	const minWidth  = ifNull(size[2], 1) * pxRatio;

	const disp = ifNull(opts.disp, EMPTY_OBJ);
	const _each = ifNull(opts.each, _ => {});

	const { fill: dispFills, stroke: dispStrokes } = disp;

	return (u, seriesIdx, idx0, idx1) => {
		return orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
			let pxRound = series.pxRound;

			let valRadius, baseRadius;

			if (scaleX.ori == 0)
				[valRadius, baseRadius] = radiusFn(u, seriesIdx);
			else
				[baseRadius, valRadius] = radiusFn(u, seriesIdx);

			const _dirX = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);
			const _dirY = scaleY.dir * (scaleY.ori == 1 ? 1 : -1);

			let rect = scaleX.ori == 0 ? rectH : rectV;

			let each = scaleX.ori == 0 ? _each : (u, seriesIdx, i, top, lft, hgt, wid) => {
				_each(u, seriesIdx, i, lft, top, wid, hgt);
			};

			let [ bandFillDir, bandClipDir ] = bandFillClipDirs(u, seriesIdx);

		//	let fillToY = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);
			let fillToY = scaleY.distr == 3 ? (bandFillDir == 1 ? scaleY.max : scaleY.min) : 0;

			let y0Pos = valToPosY(fillToY, scaleY, yDim, yOff);

			// barWid is to center of stroke
			let xShift, barWid;

			let strokeWidth = pxRound(series.width * pxRatio);

			let multiPath = false;

			let fillColors = null;
			let fillPaths = null;
			let strokeColors = null;
			let strokePaths = null;

			if (dispFills != null && (strokeWidth == 0 || dispStrokes != null)) {
				multiPath = true;

				fillColors = dispFills.values(u, seriesIdx, idx0, idx1);
				fillPaths = new Map();
				(new Set(fillColors)).forEach(color => {
					if (color != null)
						fillPaths.set(color, new Path2D());
				});

				if (strokeWidth > 0) {
					strokeColors = dispStrokes.values(u, seriesIdx, idx0, idx1);
					strokePaths = new Map();
					(new Set(strokeColors)).forEach(color => {
						if (color != null)
							strokePaths.set(color, new Path2D());
					});
				}
			}

			let { x0, size } = disp;

			let bandClipNulls = true;

			if (x0 != null && size != null) {
				dataX = x0.values(u, seriesIdx, idx0, idx1);

				if (x0.unit == 2)
					dataX = dataX.map(pct => u.posToVal(xOff + pct * xDim, scaleX.key, true));

				// assumes uniform sizes, for now
				let sizes = size.values(u, seriesIdx, idx0, idx1);

				if (size.unit == 2)
					barWid = sizes[0] * xDim;
				else
					barWid = valToPosX(sizes[0], scaleX, xDim, xOff) - valToPosX(0, scaleX, xDim, xOff); // assumes linear scale (delta from 0)

				barWid = pxRound(barWid - strokeWidth);

				xShift = (_dirX == 1 ? -strokeWidth / 2 : barWid + strokeWidth / 2);
			}
			else {
				let colWid = xDim;

				if (dataX.length > 1) {
					// prior index with non-undefined y data
					let prevIdx = null;

					// scan full dataset for smallest adjacent delta
					// will not work properly for non-linear x scales, since does not do expensive valToPosX calcs till end
					for (let i = 0, minDelta = Infinity; i < dataX.length; i++) {
						if (dataY[i] !== undefined) {
							if (prevIdx != null) {
								let delta = abs(dataX[i] - dataX[prevIdx]);

								if (delta < minDelta) {
									minDelta = delta;
									colWid = abs(valToPosX(dataX[i], scaleX, xDim, xOff) - valToPosX(dataX[prevIdx], scaleX, xDim, xOff));
								}
							}

							prevIdx = i;
						}
					}
				}

				let gapWid = colWid * gapFactor;

				barWid = pxRound(min(maxWidth, max(minWidth, colWid - gapWid)) - strokeWidth - extraGap);

				xShift = (align == 0 ? barWid / 2 : align == _dirX ? 0 : barWid) - align * _dirX * extraGap / 2;

				// when colWidth is smaller than [min-clamped] bar width (e.g. aligned data values are non-uniform)
				// disable clipping of null-valued band bars to avoid clip overlap / bleed into adjacent bars
				// (this could still bleed clips of adjacent band/stacked bars into each other, so is far from perfect)
				if (barWid > colWid)
					bandClipNulls = false;
			}

			const _paths = {stroke: null, fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL | BAND_CLIP_STROKE};  // disp, geom

			let yLimit;

			if (bandClipDir != 0) {
				_paths.band = new Path2D();
				yLimit = pxRound(valToPosY(bandClipDir == 1 ? scaleY.max : scaleY.min, scaleY, yDim, yOff));
			}

			const stroke = multiPath ? null : new Path2D();
			const band = _paths.band;

			let { y0, y1 } = disp;

			let dataY0 = null;

			if (y0 != null && y1 != null) {
				dataY = y1.values(u, seriesIdx, idx0, idx1);
				dataY0 = y0.values(u, seriesIdx, idx0, idx1);
			}

			let radVal = valRadius * barWid;
			let radBase = baseRadius * barWid;

			for (let i = _dirX == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += _dirX) {
				let yVal = dataY[i];

				// we can skip both, drawing and band clipping for alignment artifacts
				if (yVal === undefined)
					continue;

			/*
				// interpolate upwards band clips
				if (yVal == null) {
				//	if (hasBands)
				//		yVal = costlyLerp(i, idx0, idx1, _dirX, dataY);
				//	else
						continue;
				}
			*/

				let xVal = scaleX.distr != 2 || disp != null ? dataX[i] : i;

				// TODO: all xPos can be pre-computed once for all series in aligned set
				let xPos = valToPosX(xVal, scaleX, xDim, xOff);
				let yPos = valToPosY(ifNull(yVal, fillToY), scaleY, yDim, yOff);

				if (dataY0 != null && yVal != null)
					y0Pos = valToPosY(dataY0[i], scaleY, yDim, yOff);

				let lft = pxRound(xPos - xShift);
				let btm = pxRound(max(yPos, y0Pos));
				let top = pxRound(min(yPos, y0Pos));
				// this includes the stroke
				let barHgt = btm - top;

				if (yVal != null) {  // && yVal != fillToY (0 height bar)
					let rv = yVal < 0 ? radBase : radVal;
					let rb = yVal < 0 ? radVal : radBase;

					if (multiPath) {
						if (strokeWidth > 0 && strokeColors[i] != null)
							rect(strokePaths.get(strokeColors[i]), lft, top + floor(strokeWidth / 2), barWid, max(0, barHgt - strokeWidth), rv, rb);

						if (fillColors[i] != null)
							rect(fillPaths.get(fillColors[i]), lft, top + floor(strokeWidth / 2), barWid, max(0, barHgt - strokeWidth), rv, rb);
					}
					else
						rect(stroke, lft, top + floor(strokeWidth / 2), barWid, max(0, barHgt - strokeWidth), rv, rb);

					each(u, seriesIdx, i,
						lft    - strokeWidth / 2,
						top,
						barWid + strokeWidth,
						barHgt,
					);
				}

				if (bandClipDir != 0 && (yVal != null || bandClipNulls)) {
					if (_dirY * bandClipDir == 1) {
						btm = top;
						top = yLimit;
					}
					else {
						top = btm;
						btm = yLimit;
					}

					barHgt = btm - top;

					rect(band, lft - strokeWidth / 2, top, barWid + strokeWidth, max(0, barHgt), 0, 0);  // radius here?
				}
			}

			if (strokeWidth > 0)
				_paths.stroke = multiPath ? strokePaths : stroke;

			_paths.fill = multiPath ? fillPaths : stroke;

			return _paths;
		});
	};
}

function splineInterp(interp, opts) {
	const alignGaps = ifNull(opts?.alignGaps, 0);

	return (u, seriesIdx, idx0, idx1) => {
		return orient(u, seriesIdx, (series, dataX, dataY, scaleX, scaleY, valToPosX, valToPosY, xOff, yOff, xDim, yDim) => {
			let pxRound = series.pxRound;

			let pixelForX = val => pxRound(valToPosX(val, scaleX, xDim, xOff));
			let pixelForY = val => pxRound(valToPosY(val, scaleY, yDim, yOff));

			let moveTo, bezierCurveTo, lineTo;

			if (scaleX.ori == 0) {
				moveTo = moveToH;
				lineTo = lineToH;
				bezierCurveTo = bezierCurveToH;
			}
			else {
				moveTo = moveToV;
				lineTo = lineToV;
				bezierCurveTo = bezierCurveToV;
			}

			const dir = scaleX.dir * (scaleX.ori == 0 ? 1 : -1);

			idx0 = nonNullIdx(dataY, idx0, idx1,  1);
			idx1 = nonNullIdx(dataY, idx0, idx1, -1);

			let firstXPos = pixelForX(dataX[dir == 1 ? idx0 : idx1]);
			let prevXPos = firstXPos;

			let xCoords = [];
			let yCoords = [];

			for (let i = dir == 1 ? idx0 : idx1; i >= idx0 && i <= idx1; i += dir) {
				let yVal = dataY[i];

				if (yVal != null) {
					let xVal = dataX[i];
					let xPos = pixelForX(xVal);

					xCoords.push(prevXPos = xPos);
					yCoords.push(pixelForY(dataY[i]));
				}
			}

			const _paths = {stroke: interp(xCoords, yCoords, moveTo, lineTo, bezierCurveTo, pxRound), fill: null, clip: null, band: null, gaps: null, flags: BAND_CLIP_FILL};
			const stroke = _paths.stroke;

			let [ bandFillDir, bandClipDir ] = bandFillClipDirs(u, seriesIdx);

			if (series.fill != null || bandFillDir != 0) {
				let fill = _paths.fill = new Path2D(stroke);

				let fillTo = series.fillTo(u, seriesIdx, series.min, series.max, bandFillDir);
				let fillToY = pixelForY(fillTo);

				lineTo(fill, prevXPos, fillToY);
				lineTo(fill, firstXPos, fillToY);
			}

			if (!series.spanGaps) {
			//	console.time('gaps');
				let gaps = [];

				gaps.push(...findGaps(dataX, dataY, idx0, idx1, dir, pixelForX, alignGaps));

			//	console.timeEnd('gaps');

			//	console.log('gaps', JSON.stringify(gaps));

				_paths.gaps = gaps = series.gaps(u, seriesIdx, idx0, idx1, gaps);

				_paths.clip = clipGaps(gaps, scaleX.ori, xOff, yOff, xDim, yDim);
			}

			if (bandClipDir != 0) {
				_paths.band = bandClipDir == 2 ? [
					clipBandLine(u, seriesIdx, idx0, idx1, stroke, -1),
					clipBandLine(u, seriesIdx, idx0, idx1, stroke,  1),
				] : clipBandLine(u, seriesIdx, idx0, idx1, stroke, bandClipDir);
			}

			return _paths;

			//  if FEAT_PATHS: false in rollup.config.js
			//	u.ctx.save();
			//	u.ctx.beginPath();
			//	u.ctx.rect(u.bbox.left, u.bbox.top, u.bbox.width, u.bbox.height);
			//	u.ctx.clip();
			//	u.ctx.strokeStyle = u.series[sidx].stroke;
			//	u.ctx.stroke(stroke);
			//	u.ctx.fillStyle = u.series[sidx].fill;
			//	u.ctx.fill(fill);
			//	u.ctx.restore();
			//	return null;
		});
	};
}

function monotoneCubic(opts) {
	return splineInterp(_monotoneCubic, opts);
}

// Monotone Cubic Spline interpolation, adapted from the Chartist.js implementation:
// https://github.com/gionkunz/chartist-js/blob/e7e78201bffe9609915e5e53cfafa29a5d6c49f9/src/scripts/interpolation.js#L240-L369
function _monotoneCubic(xs, ys, moveTo, lineTo, bezierCurveTo, pxRound) {
	const n = xs.length;

	if (n < 2)
		return null;

	const path = new Path2D();

	moveTo(path, xs[0], ys[0]);

	if (n == 2)
		lineTo(path, xs[1], ys[1]);
	else {
		let ms  = Array(n),
			ds  = Array(n - 1),
			dys = Array(n - 1),
			dxs = Array(n - 1);

		// calc deltas and derivative
		for (let i = 0; i < n - 1; i++) {
			dys[i] = ys[i + 1] - ys[i];
			dxs[i] = xs[i + 1] - xs[i];
			ds[i]  = dys[i] / dxs[i];
		}

		// determine desired slope (m) at each point using Fritsch-Carlson method
		// http://math.stackexchange.com/questions/45218/implementation-of-monotone-cubic-interpolation
		ms[0] = ds[0];

		for (let i = 1; i < n - 1; i++) {
			if (ds[i] === 0 || ds[i - 1] === 0 || (ds[i - 1] > 0) !== (ds[i] > 0))
				ms[i] = 0;
			else {
				ms[i] = 3 * (dxs[i - 1] + dxs[i]) / (
					(2 * dxs[i] + dxs[i - 1]) / ds[i - 1] +
					(dxs[i] + 2 * dxs[i - 1]) / ds[i]
				);

				if (!isFinite(ms[i]))
					ms[i] = 0;
			}
		}

		ms[n - 1] = ds[n - 2];

		for (let i = 0; i < n - 1; i++) {
			bezierCurveTo(
				path,
				xs[i] + dxs[i] / 3,
				ys[i] + ms[i] * dxs[i] / 3,
				xs[i + 1] - dxs[i] / 3,
				ys[i + 1] - ms[i + 1] * dxs[i] / 3,
				xs[i + 1],
				ys[i + 1],
			);
		}
	}

	return path;
}

const cursorPlots = new Set();

function invalidateRects() {
	for (let u of cursorPlots)
		u.syncRect(true);
}

if (domEnv) {
	on(resize, win, invalidateRects);
	on(scroll, win, invalidateRects, true);
	on(dppxchange, win, () => { uPlot.pxRatio = pxRatio; });
}

const linearPath = linear() ;
const pointsPath = points() ;

function setDefaults(d, xo, yo, initY) {
	let d2 = initY ? [d[0], d[1]].concat(d.slice(2)) : [d[0]].concat(d.slice(1));
	return d2.map((o, i) => setDefault(o, i, xo, yo));
}

function setDefaults2(d, xyo) {
	return d.map((o, i) => i == 0 ? null : assign({}, xyo, o));  // todo: assign() will not merge facet arrays
}

function setDefault(o, i, xo, yo) {
	return assign({}, (i == 0 ? xo : yo), o);
}

function snapNumX(self, dataMin, dataMax) {
	return dataMin == null ? nullNullTuple : [dataMin, dataMax];
}

const snapTimeX = snapNumX;

// this ensures that non-temporal/numeric y-axes get multiple-snapped padding added above/below
// TODO: also account for incrs when snapping to ensure top of axis gets a tick & value
function snapNumY(self, dataMin, dataMax) {
	return dataMin == null ? nullNullTuple : rangeNum(dataMin, dataMax, rangePad, true);
}

function snapLogY(self, dataMin, dataMax, scale) {
	return dataMin == null ? nullNullTuple : rangeLog(dataMin, dataMax, self.scales[scale].log, false);
}

const snapLogX = snapLogY;

function snapAsinhY(self, dataMin, dataMax, scale) {
	return dataMin == null ? nullNullTuple : rangeAsinh(dataMin, dataMax, self.scales[scale].log, false);
}

const snapAsinhX = snapAsinhY;

// dim is logical (getClientBoundingRect) pixels, not canvas pixels
function findIncr(minVal, maxVal, incrs, dim, minSpace) {
	let intDigits = max(numIntDigits(minVal), numIntDigits(maxVal));

	let delta = maxVal - minVal;

	let incrIdx = closestIdx((minSpace / dim) * delta, incrs);

	do {
		let foundIncr = incrs[incrIdx];
		let foundSpace = dim * foundIncr / delta;

		if (foundSpace >= minSpace && intDigits + (foundIncr < 5 ? fixedDec.get(foundIncr) : 0) <= 17)
			return [foundIncr, foundSpace];
	} while (++incrIdx < incrs.length);

	return [0, 0];
}

function pxRatioFont(font) {
	let fontSize, fontSizeCss;
	font = font.replace(/(\d+)px/, (m, p1) => (fontSize = round((fontSizeCss = +p1) * pxRatio)) + 'px');
	return [font, fontSize, fontSizeCss];
}

function syncFontSize(axis) {
	if (axis.show) {
		[axis.font, axis.labelFont].forEach(f => {
			let size = roundDec(f[2] * pxRatio, 1);
			f[0] = f[0].replace(/[0-9.]+px/, size + 'px');
			f[1] = size;
		});
	}
}

function uPlot(opts, data, then) {
	const self = {
		mode: ifNull(opts.mode, 1),
	};

	const mode = self.mode;

	// TODO: cache denoms & mins scale.cache = {r, min, }
	function getValPct(val, scale) {
		let _val = (
			scale.distr == 3 ? log10(val > 0 ? val : scale.clamp(self, val, scale.min, scale.max, scale.key)) :
			scale.distr == 4 ? asinh(val, scale.asinh) :
			val
		);

		return (_val - scale._min) / (scale._max - scale._min);
	}

	function getHPos(val, scale, dim, off) {
		let pct = getValPct(val, scale);
		return off + dim * (scale.dir == -1 ? (1 - pct) : pct);
	}

	function getVPos(val, scale, dim, off) {
		let pct = getValPct(val, scale);
		return off + dim * (scale.dir == -1 ? pct : (1 - pct));
	}

	function getPos(val, scale, dim, off) {
		return scale.ori == 0 ? getHPos(val, scale, dim, off) : getVPos(val, scale, dim, off);
	}

	self.valToPosH = getHPos;
	self.valToPosV = getVPos;

	let ready = false;
	self.status = 0;

	const root = self.root = placeDiv(UPLOT);

	if (opts.id != null)
		root.id = opts.id;

	addClass(root, opts.class);

	if (opts.title) {
		let title = placeDiv(TITLE, root);
		title.textContent = opts.title;
	}

	const can = placeTag("canvas");
	const ctx = self.ctx = can.getContext("2d");

	const wrap = placeDiv(WRAP, root);

	on("click", wrap, e => {
		if (e.target === over) {
			let didDrag = mouseLeft1 != mouseLeft0 || mouseTop1 != mouseTop0;
			didDrag && drag.click(self, e);
		}
	}, true);

	const under = self.under = placeDiv(UNDER, wrap);
	wrap.appendChild(can);
	const over = self.over = placeDiv(OVER, wrap);

	opts = copy(opts);

	const pxAlign = +ifNull(opts.pxAlign, 1);

	const pxRound = pxRoundGen(pxAlign);

	(opts.plugins || []).forEach(p => {
		if (p.opts)
			opts = p.opts(self, opts) || opts;
	});

	const ms = opts.ms || 1e-3;

	const series  = self.series = mode == 1 ?
		setDefaults(opts.series || [], xSeriesOpts, ySeriesOpts, false) :
		setDefaults2(opts.series || [null], xySeriesOpts);
	const axes    = self.axes   = setDefaults(opts.axes   || [], xAxisOpts,   yAxisOpts,    true);
	const scales  = self.scales = {};
	const bands   = self.bands  = opts.bands || [];

	bands.forEach(b => {
		b.fill = fnOrSelf(b.fill || null);
		b.dir = ifNull(b.dir, -1);
	});

	const xScaleKey = mode == 2 ? series[1].facets[0].scale : series[0].scale;

	const drawOrderMap = {
		axes: drawAxesGrid,
		series: drawSeries,
	};

	const drawOrder = (opts.drawOrder || ["axes", "series"]).map(key => drawOrderMap[key]);

	function initScale(scaleKey) {
		let sc = scales[scaleKey];

		if (sc == null) {
			let scaleOpts = (opts.scales || EMPTY_OBJ)[scaleKey] || EMPTY_OBJ;

			if (scaleOpts.from != null) {
				// ensure parent is initialized
				initScale(scaleOpts.from);
				// dependent scales inherit
				scales[scaleKey] = assign({}, scales[scaleOpts.from], scaleOpts, {key: scaleKey});
			}
			else {
				sc = scales[scaleKey] = assign({}, (scaleKey == xScaleKey ? xScaleOpts : yScaleOpts), scaleOpts);

				sc.key = scaleKey;

				let isTime = sc.time;

				let rn = sc.range;

				let rangeIsArr = isArr(rn);

				if (scaleKey != xScaleKey || (mode == 2 && !isTime)) {
					// if range array has null limits, it should be auto
					if (rangeIsArr && (rn[0] == null || rn[1] == null)) {
						rn = {
							min: rn[0] == null ? autoRangePart : {
								mode: 1,
								hard: rn[0],
								soft: rn[0],
							},
							max: rn[1] == null ? autoRangePart : {
								mode: 1,
								hard: rn[1],
								soft: rn[1],
							},
						};
						rangeIsArr = false;
					}

					if (!rangeIsArr && isObj(rn)) {
						let cfg = rn;
						// this is similar to snapNumY
						rn = (self, dataMin, dataMax) => dataMin == null ? nullNullTuple : rangeNum(dataMin, dataMax, cfg);
					}
				}

				sc.range = fnOrSelf(rn || (isTime ? snapTimeX : scaleKey == xScaleKey ?
					(sc.distr == 3 ? snapLogX : sc.distr == 4 ? snapAsinhX : snapNumX) :
					(sc.distr == 3 ? snapLogY : sc.distr == 4 ? snapAsinhY : snapNumY)
				));

				sc.auto = fnOrSelf(rangeIsArr ? false : sc.auto);

				sc.clamp = fnOrSelf(sc.clamp || clampScale);

				// caches for expensive ops like asinh() & log()
				sc._min = sc._max = null;
			}
		}
	}

	initScale("x");
	initScale("y");

	// TODO: init scales from facets in mode: 2
	if (mode == 1) {
		series.forEach(s => {
			initScale(s.scale);
		});
	}

	axes.forEach(a => {
		initScale(a.scale);
	});

	for (let k in opts.scales)
		initScale(k);

	const scaleX = scales[xScaleKey];

	const xScaleDistr = scaleX.distr;

	let valToPosX, valToPosY;

	if (scaleX.ori == 0) {
		addClass(root, ORI_HZ);
		valToPosX = getHPos;
		valToPosY = getVPos;
		/*
		updOriDims = () => {
			xDimCan = plotWid;
			xOffCan = plotLft;
			yDimCan = plotHgt;
			yOffCan = plotTop;

			xDimCss = plotWidCss;
			xOffCss = plotLftCss;
			yDimCss = plotHgtCss;
			yOffCss = plotTopCss;
		};
		*/
	}
	else {
		addClass(root, ORI_VT);
		valToPosX = getVPos;
		valToPosY = getHPos;
		/*
		updOriDims = () => {
			xDimCan = plotHgt;
			xOffCan = plotTop;
			yDimCan = plotWid;
			yOffCan = plotLft;

			xDimCss = plotHgtCss;
			xOffCss = plotTopCss;
			yDimCss = plotWidCss;
			yOffCss = plotLftCss;
		};
		*/
	}

	const pendScales = {};

	// explicitly-set initial scales
	for (let k in scales) {
		let sc = scales[k];

		if (sc.min != null || sc.max != null) {
			pendScales[k] = {min: sc.min, max: sc.max};
			sc.min = sc.max = null;
		}
	}

//	self.tz = opts.tz || Intl.DateTimeFormat().resolvedOptions().timeZone;
	const _tzDate  = (opts.tzDate || (ts => new Date(round(ts / ms))));
	const _fmtDate = (opts.fmtDate || fmtDate);

	const _timeAxisSplits = (ms == 1 ? timeAxisSplitsMs(_tzDate) : timeAxisSplitsS(_tzDate));
	const _timeAxisVals   = timeAxisVals(_tzDate, timeAxisStamps((ms == 1 ? _timeAxisStampsMs : _timeAxisStampsS), _fmtDate));
	const _timeSeriesVal  = timeSeriesVal(_tzDate, timeSeriesStamp(_timeSeriesStamp, _fmtDate));

	const activeIdxs = [];

	const legend     = (self.legend = assign({}, legendOpts, opts.legend));
	const showLegend = legend.show;
	const markers    = legend.markers;

	{
		legend.idxs = activeIdxs;

		markers.width  = fnOrSelf(markers.width);
		markers.dash   = fnOrSelf(markers.dash);
		markers.stroke = fnOrSelf(markers.stroke);
		markers.fill   = fnOrSelf(markers.fill);
	}

	let legendTable;
	let legendHead;
	let legendBody;
	let legendRows = [];
	let legendCells = [];
	let legendCols;
	let multiValLegend = false;
	let NULL_LEGEND_VALUES = {};

	if (legend.live) {
		const getMultiVals = series[1] ? series[1].values : null;
		multiValLegend = getMultiVals != null;
		legendCols = multiValLegend ? getMultiVals(self, 1, 0) : {_: 0};

		for (let k in legendCols)
			NULL_LEGEND_VALUES[k] = LEGEND_DISP;
	}

	if (showLegend) {
		legendTable = placeTag("table", LEGEND, root);
		legendBody = placeTag("tbody", null, legendTable);

		// allows legend to be moved out of root
		legend.mount(self, legendTable);

		if (multiValLegend) {
			legendHead = placeTag("thead", null, legendTable, legendBody);

			let head = placeTag("tr", null, legendHead);
			placeTag("th", null, head);

			for (var key in legendCols)
				placeTag("th", LEGEND_LABEL, head).textContent = key;
		}
		else {
			addClass(legendTable, LEGEND_INLINE);
			legend.live && addClass(legendTable, LEGEND_LIVE);
		}
	}

	const son  = {show: true};
	const soff = {show: false};

	function initLegendRow(s, i) {
		if (i == 0 && (multiValLegend || !legend.live || mode == 2))
			return nullNullTuple;

		let cells = [];

		let row = placeTag("tr", LEGEND_SERIES, legendBody, legendBody.childNodes[i]);

		addClass(row, s.class);

		if (!s.show)
			addClass(row, OFF);

		let label = placeTag("th", null, row);

		if (markers.show) {
			let indic = placeDiv(LEGEND_MARKER, label);

			if (i > 0) {
				let width  = markers.width(self, i);

				if (width)
					indic.style.border = width + "px " + markers.dash(self, i) + " " + markers.stroke(self, i);

				indic.style.background = markers.fill(self, i);
			}
		}

		let text = placeDiv(LEGEND_LABEL, label);
		text.textContent = s.label;

		if (i > 0) {
			if (!markers.show)
				text.style.color = s.width > 0 ? markers.stroke(self, i) : markers.fill(self, i);

			onMouse("click", label, e => {
				if (cursor._lock)
					return;

				setCursorEvent(e);

				let seriesIdx = series.indexOf(s);

				if ((e.ctrlKey || e.metaKey) != legend.isolate) {
					// if any other series is shown, isolate this one. else show all
					let isolate = series.some((s, i) => i > 0 && i != seriesIdx && s.show);

					series.forEach((s, i) => {
						i > 0 && setSeries(i, isolate ? (i == seriesIdx ? son : soff) : son, true, syncOpts.setSeries);
					});
				}
				else
					setSeries(seriesIdx, {show: !s.show}, true, syncOpts.setSeries);
			}, false);

			if (cursorFocus) {
				onMouse(mouseenter, label, e => {
					if (cursor._lock)
						return;

					setCursorEvent(e);

					setSeries(series.indexOf(s), FOCUS_TRUE, true, syncOpts.setSeries);
				}, false);
			}
		}

		for (var key in legendCols) {
			let v = placeTag("td", LEGEND_VALUE, row);
			v.textContent = "--";
			cells.push(v);
		}

		return [row, cells];
	}

	const mouseListeners = new Map();

	function onMouse(ev, targ, fn, onlyTarg = true) {
		const targListeners = mouseListeners.get(targ) || {};
		const listener = cursor.bind[ev](self, targ, fn, onlyTarg);

		if (listener) {
			on(ev, targ, targListeners[ev] = listener);
			mouseListeners.set(targ, targListeners);
		}
	}

	function offMouse(ev, targ, fn) {
		const targListeners = mouseListeners.get(targ) || {};

		for (let k in targListeners) {
			if (ev == null || k == ev) {
				off(k, targ, targListeners[k]);
				delete targListeners[k];
			}
		}

		if (ev == null)
			mouseListeners.delete(targ);
	}

	let fullWidCss = 0;
	let fullHgtCss = 0;

	let plotWidCss = 0;
	let plotHgtCss = 0;

	// plot margins to account for axes
	let plotLftCss = 0;
	let plotTopCss = 0;

	let plotLft = 0;
	let plotTop = 0;
	let plotWid = 0;
	let plotHgt = 0;

	self.bbox = {};

	let shouldSetScales = false;
	let shouldSetSize = false;
	let shouldConvergeSize = false;
	let shouldSetCursor = false;
	let shouldSetSelect = false;
	let shouldSetLegend = false;

	function _setSize(width, height, force) {
		if (force || (width != self.width || height != self.height))
			calcSize(width, height);

		resetYSeries(false);

		shouldConvergeSize = true;
		shouldSetSize = true;

		if (cursor.left >= 0)
			shouldSetCursor = shouldSetLegend = true;

		commit();
	}

	function calcSize(width, height) {
	//	log("calcSize()", arguments);

		self.width  = fullWidCss = plotWidCss = width;
		self.height = fullHgtCss = plotHgtCss = height;
		plotLftCss  = plotTopCss = 0;

		calcPlotRect();
		calcAxesRects();

		let bb = self.bbox;

		plotLft = bb.left   = incrRound(plotLftCss * pxRatio, 0.5);
		plotTop = bb.top    = incrRound(plotTopCss * pxRatio, 0.5);
		plotWid = bb.width  = incrRound(plotWidCss * pxRatio, 0.5);
		plotHgt = bb.height = incrRound(plotHgtCss * pxRatio, 0.5);

	//	updOriDims();
	}

	// ensures size calc convergence
	const CYCLE_LIMIT = 3;

	function convergeSize() {
		let converged = false;

		let cycleNum = 0;

		while (!converged) {
			cycleNum++;

			let axesConverged = axesCalc(cycleNum);
			let paddingConverged = paddingCalc(cycleNum);

			converged = cycleNum == CYCLE_LIMIT || (axesConverged && paddingConverged);

			if (!converged) {
				calcSize(self.width, self.height);
				shouldSetSize = true;
			}
		}
	}

	function setSize({width, height}) {
		_setSize(width, height);
	}

	self.setSize = setSize;

	// accumulate axis offsets, reduce canvas width
	function calcPlotRect() {
		// easements for edge labels
		let hasTopAxis = false;
		let hasBtmAxis = false;
		let hasRgtAxis = false;
		let hasLftAxis = false;

		axes.forEach((axis, i) => {
			if (axis.show && axis._show) {
				let {side, _size} = axis;
				let isVt = side % 2;
				let labelSize = axis.label != null ? axis.labelSize : 0;

				let fullSize = _size + labelSize;

				if (fullSize > 0) {
					if (isVt) {
						plotWidCss -= fullSize;

						if (side == 3) {
							plotLftCss += fullSize;
							hasLftAxis = true;
						}
						else
							hasRgtAxis = true;
					}
					else {
						plotHgtCss -= fullSize;

						if (side == 0) {
							plotTopCss += fullSize;
							hasTopAxis = true;
						}
						else
							hasBtmAxis = true;
					}
				}
			}
		});

		sidesWithAxes[0] = hasTopAxis;
		sidesWithAxes[1] = hasRgtAxis;
		sidesWithAxes[2] = hasBtmAxis;
		sidesWithAxes[3] = hasLftAxis;

		// hz padding
		plotWidCss -= _padding[1] + _padding[3];
		plotLftCss += _padding[3];

		// vt padding
		plotHgtCss -= _padding[2] + _padding[0];
		plotTopCss += _padding[0];
	}

	function calcAxesRects() {
		// will accum +
		let off1 = plotLftCss + plotWidCss;
		let off2 = plotTopCss + plotHgtCss;
		// will accum -
		let off3 = plotLftCss;
		let off0 = plotTopCss;

		function incrOffset(side, size) {
			switch (side) {
				case 1: off1 += size; return off1 - size;
				case 2: off2 += size; return off2 - size;
				case 3: off3 -= size; return off3 + size;
				case 0: off0 -= size; return off0 + size;
			}
		}

		axes.forEach((axis, i) => {
			if (axis.show && axis._show) {
				let side = axis.side;

				axis._pos = incrOffset(side, axis._size);

				if (axis.label != null)
					axis._lpos = incrOffset(side, axis.labelSize);
			}
		});
	}

	const cursor = self.cursor = assign({}, cursorOpts, {drag: {y: mode == 2}}, opts.cursor);
	const setCursorEvent = e => { cursor.event = e; };

	cursor.idxs = activeIdxs;

	cursor._lock = false;

	let points = cursor.points;

	points.show   = fnOrSelf(points.show);
	points.size   = fnOrSelf(points.size);
	points.stroke = fnOrSelf(points.stroke);
	points.width  = fnOrSelf(points.width);
	points.fill   = fnOrSelf(points.fill);

	const focus = self.focus = assign({}, opts.focus || {alpha: 0.3}, cursor.focus);

	const cursorFocus = focus.prox >= 0;

	// series-intersection markers
	let cursorPts = [null];

	function initCursorPt(s, si) {
		if (si > 0) {
			let pt = cursor.points.show(self, si);

			if (pt) {
				addClass(pt, CURSOR_PT);
				addClass(pt, s.class);
				elTrans(pt, -10, -10, plotWidCss, plotHgtCss);
				over.insertBefore(pt, cursorPts[si]);

				return pt;
			}
		}
	}

	function initSeries(s, i) {
		if (mode == 1 || i > 0) {
			let isTime = mode == 1 && scales[s.scale].time;

			let sv = s.value;
			s.value = isTime ? (isStr(sv) ? timeSeriesVal(_tzDate, timeSeriesStamp(sv, _fmtDate)) : sv || _timeSeriesVal) : sv || numSeriesVal;
			s.label = s.label || (isTime ? timeSeriesLabel : numSeriesLabel);
		}

		if (i > 0) {
			s.width  = s.width == null ? 1 : s.width;
			s.paths  = s.paths || linearPath || retNull;
			s.fillTo = fnOrSelf(s.fillTo || seriesFillTo);
			s.pxAlign = +ifNull(s.pxAlign, pxAlign);
			s.pxRound = pxRoundGen(s.pxAlign);

			s.stroke = fnOrSelf(s.stroke || null);
			s.fill   = fnOrSelf(s.fill || null);
			s._stroke = s._fill = s._paths = s._focus = null;

			let _ptDia = ptDia(max(1, s.width), 1);
			let points = s.points = assign({}, {
				size: _ptDia,
				width: max(1, _ptDia * .2),
				stroke: s.stroke,
				space: _ptDia * 2,
				paths: pointsPath,
				_stroke: null,
				_fill: null,
			}, s.points);
			points.show   = fnOrSelf(points.show);
			points.filter = fnOrSelf(points.filter);
			points.fill   = fnOrSelf(points.fill);
			points.stroke = fnOrSelf(points.stroke);
			points.paths  = fnOrSelf(points.paths);
			points.pxAlign = s.pxAlign;
		}

		if (showLegend) {
			let rowCells = initLegendRow(s, i);
			legendRows.splice(i, 0, rowCells[0]);
			legendCells.splice(i, 0, rowCells[1]);
			legend.values.push(null);	// NULL_LEGEND_VALS not yet avil here :(
		}

		if (cursor.show) {
			activeIdxs.splice(i, 0, null);

			let pt = initCursorPt(s, i);
			pt && cursorPts.splice(i, 0, pt);
		}

		fire("addSeries", i);
	}

	function addSeries(opts, si) {
		si = si == null ? series.length : si;

		opts = mode == 1 ? setDefault(opts, si, xSeriesOpts, ySeriesOpts) : setDefault(opts, si, null, xySeriesOpts);

		series.splice(si, 0, opts);
		initSeries(series[si], si);
	}

	self.addSeries = addSeries;

	function delSeries(i) {
		series.splice(i, 1);

		if (showLegend) {
			legend.values.splice(i, 1);

			legendCells.splice(i, 1);
			let tr = legendRows.splice(i, 1)[0];
			offMouse(null, tr.firstChild);
			tr.remove();
		}

		if (cursor.show) {
			activeIdxs.splice(i, 1);

			cursorPts.length > 1 && cursorPts.splice(i, 1)[0].remove();
		}

		// TODO: de-init no-longer-needed scales?

		fire("delSeries", i);
	}

	self.delSeries = delSeries;

	const sidesWithAxes = [false, false, false, false];

	function initAxis(axis, i) {
		axis._show = axis.show;

		if (axis.show) {
			let isVt = axis.side % 2;

			let sc = scales[axis.scale];

			// this can occur if all series specify non-default scales
			if (sc == null) {
				axis.scale = isVt ? series[1].scale : xScaleKey;
				sc = scales[axis.scale];
			}

			// also set defaults for incrs & values based on axis distr
			let isTime = sc.time;

			axis.size   = fnOrSelf(axis.size);
			axis.space  = fnOrSelf(axis.space);
			axis.rotate = fnOrSelf(axis.rotate);

			if (isArr(axis.incrs)) {
				axis.incrs.forEach(incr => {
					!fixedDec.has(incr) && fixedDec.set(incr, guessDec(incr));
				});
			}

			axis.incrs  = fnOrSelf(axis.incrs  || (          sc.distr == 2 ? wholeIncrs : (isTime ? (ms == 1 ? timeIncrsMs : timeIncrsS) : numIncrs)));
			axis.splits = fnOrSelf(axis.splits || (isTime && sc.distr == 1 ? _timeAxisSplits : sc.distr == 3 ? logAxisSplits : sc.distr == 4 ? asinhAxisSplits : numAxisSplits));

			axis.stroke        = fnOrSelf(axis.stroke);
			axis.grid.stroke   = fnOrSelf(axis.grid.stroke);
			axis.ticks.stroke  = fnOrSelf(axis.ticks.stroke);
			axis.border.stroke = fnOrSelf(axis.border.stroke);

			let av = axis.values;

			axis.values = (
				// static array of tick values
				isArr(av) && !isArr(av[0]) ? fnOrSelf(av) :
				// temporal
				isTime ? (
					// config array of fmtDate string tpls
					isArr(av) ?
						timeAxisVals(_tzDate, timeAxisStamps(av, _fmtDate)) :
					// fmtDate string tpl
					isStr(av) ?
						timeAxisVal(_tzDate, av) :
					av || _timeAxisVals
				) : av || numAxisVals
			);

			axis.filter = fnOrSelf(axis.filter || (          sc.distr >= 3 && sc.log == 10 ? log10AxisValsFilt : sc.distr == 3 && sc.log == 2 ? log2AxisValsFilt : retArg1));

			axis.font      = pxRatioFont(axis.font);
			axis.labelFont = pxRatioFont(axis.labelFont);

			axis._size   = axis.size(self, null, i, 0);

			axis._space  =
			axis._rotate =
			axis._incrs  =
			axis._found  =	// foundIncrSpace
			axis._splits =
			axis._values = null;

			if (axis._size > 0) {
				sidesWithAxes[i] = true;
				axis._el = placeDiv(AXIS, wrap);
			}

			// debug
		//	axis._el.style.background = "#"  + Math.floor(Math.random()*16777215).toString(16) + '80';
		}
	}

	function autoPadSide(self, side, sidesWithAxes, cycleNum) {
		let [hasTopAxis, hasRgtAxis, hasBtmAxis, hasLftAxis] = sidesWithAxes;

		let ori = side % 2;
		let size = 0;

		if (ori == 0 && (hasLftAxis || hasRgtAxis))
			size = (side == 0 && !hasTopAxis || side == 2 && !hasBtmAxis ? round(xAxisOpts.size / 3) : 0);
		if (ori == 1 && (hasTopAxis || hasBtmAxis))
			size = (side == 1 && !hasRgtAxis || side == 3 && !hasLftAxis ? round(yAxisOpts.size / 2) : 0);

		return size;
	}

	const padding = self.padding = (opts.padding || [autoPadSide,autoPadSide,autoPadSide,autoPadSide]).map(p => fnOrSelf(ifNull(p, autoPadSide)));
	const _padding = self._padding = padding.map((p, i) => p(self, i, sidesWithAxes, 0));

	let dataLen;

	// rendered data window
	let i0 = null;
	let i1 = null;
	const idxs = mode == 1 ? series[0].idxs : null;

	let data0 = null;

	let viaAutoScaleX = false;

	function setData(_data, _resetScales) {
		data = _data == null ? [] : copy(_data, fastIsObj);

		if (mode == 2) {
			dataLen = 0;
			for (let i = 1; i < series.length; i++)
				dataLen += data[i][0].length;
			self.data = data = _data;
		}
		else {
			if (data[0] == null)
				data[0] = [];

			self.data = data.slice();

			data0 = data[0];
			dataLen = data0.length;

			if (xScaleDistr == 2) {
				data[0] = Array(dataLen);
				for (let i = 0; i < dataLen; i++)
					data[0][i] = i;
			}
		}

		self._data = data;

		resetYSeries(true);

		fire("setData");

		// forces x axis tick values to re-generate when neither x scale nor y scale changes
		// in ordinal mode, scale range is by index, so will not change if new data has same length, but tick values are from data
		if (xScaleDistr == 2) {
			shouldConvergeSize = true;

			/* or somewhat cheaper, and uglier:
			if (ready) {
				// logic extracted from axesCalc()
				let i = 0;
				let axis = axes[i];
				let _splits = axis._splits.map(i => data0[i]);
				let [_incr, _space] = axis._found;
				let incr = data0[_splits[1]] - data0[_splits[0]];
				axis._values = axis.values(self, axis.filter(self, _splits, i, _space, incr), i, _space, incr);
			}
			*/
		}

		if (_resetScales !== false) {
			let xsc = scaleX;

			if (xsc.auto(self, viaAutoScaleX))
				autoScaleX();
			else
				_setScale(xScaleKey, xsc.min, xsc.max);

			shouldSetCursor = shouldSetCursor || cursor.left >= 0;
			shouldSetLegend = true;
			commit();
		}
	}

	self.setData = setData;

	function autoScaleX() {
		viaAutoScaleX = true;

		let _min, _max;

		if (mode == 1) {
			if (dataLen > 0) {
				i0 = idxs[0] = 0;
				i1 = idxs[1] = dataLen - 1;

				_min = data[0][i0];
				_max = data[0][i1];

				if (xScaleDistr == 2) {
					_min = i0;
					_max = i1;
				}
				else if (_min == _max) {
					if (xScaleDistr == 3)
						[_min, _max] = rangeLog(_min, _min, scaleX.log, false);
					else if (xScaleDistr == 4)
						[_min, _max] = rangeAsinh(_min, _min, scaleX.log, false);
					else if (scaleX.time)
						_max = _min + round(86400 / ms);
					else
						[_min, _max] = rangeNum(_min, _max, rangePad, true);
				}
			}
			else {
				i0 = idxs[0] = _min = null;
				i1 = idxs[1] = _max = null;
			}
		}

		_setScale(xScaleKey, _min, _max);
	}

	let ctxStroke, ctxFill, ctxWidth, ctxDash, ctxJoin, ctxCap, ctxFont, ctxAlign, ctxBaseline;
	let ctxAlpha;

	function setCtxStyle(stroke, width, dash, cap, fill, join) {
		stroke ??= transparent;
		dash   ??= EMPTY_ARR;
		cap    ??= "butt"; // (‿|‿)
		fill   ??= transparent;
		join   ??= "round";

		if (stroke != ctxStroke)
			ctx.strokeStyle = ctxStroke = stroke;
		if (fill != ctxFill)
			ctx.fillStyle = ctxFill = fill;
		if (width != ctxWidth)
			ctx.lineWidth = ctxWidth = width;
		if (join != ctxJoin)
			ctx.lineJoin = ctxJoin = join;
		if (cap != ctxCap)
			ctx.lineCap = ctxCap = cap;
		if (dash != ctxDash)
			ctx.setLineDash(ctxDash = dash);
	}

	function setFontStyle(font, fill, align, baseline) {
		if (fill != ctxFill)
			ctx.fillStyle = ctxFill = fill;
		if (font != ctxFont)
			ctx.font = ctxFont = font;
		if (align != ctxAlign)
			ctx.textAlign = ctxAlign = align;
		if (baseline != ctxBaseline)
			ctx.textBaseline = ctxBaseline = baseline;
	}

	function accScale(wsc, psc, facet, data, sorted = 0) {
		if (data.length > 0 && wsc.auto(self, viaAutoScaleX) && (psc == null || psc.min == null)) {
			let _i0 = ifNull(i0, 0);
			let _i1 = ifNull(i1, data.length - 1);

			// only run getMinMax() for invalidated series data, else reuse
			let minMax = facet.min == null ? (wsc.distr == 3 ? getMinMaxLog(data, _i0, _i1) : getMinMax(data, _i0, _i1, sorted)) : [facet.min, facet.max];

			// initial min/max
			wsc.min = min(wsc.min, facet.min = minMax[0]);
			wsc.max = max(wsc.max, facet.max = minMax[1]);
		}
	}

	function setScales() {
	//	log("setScales()", arguments);

		// wip scales
		let wipScales = copy(scales, fastIsObj);

		for (let k in wipScales) {
			let wsc = wipScales[k];
			let psc = pendScales[k];

			if (psc != null && psc.min != null) {
				assign(wsc, psc);

				// explicitly setting the x-scale invalidates everything (acts as redraw)
				if (k == xScaleKey)
					resetYSeries(true);
			}
			else if (k != xScaleKey || mode == 2) {
				if (dataLen == 0 && wsc.from == null) {
					let minMax = wsc.range(self, null, null, k);
					wsc.min = minMax[0];
					wsc.max = minMax[1];
				}
				else {
					wsc.min = inf;
					wsc.max = -inf;
				}
			}
		}

		if (dataLen > 0) {
			// pre-range y-scales from y series' data values
			series.forEach((s, i) => {
				if (mode == 1) {
					let k = s.scale;
					let wsc = wipScales[k];
					let psc = pendScales[k];

					if (i == 0) {
						let minMax = wsc.range(self, wsc.min, wsc.max, k);

						wsc.min = minMax[0];
						wsc.max = minMax[1];

						i0 = closestIdx(wsc.min, data[0]);
						i1 = closestIdx(wsc.max, data[0]);

						// don't try to contract same or adjacent idxs
						if (i1 - i0 > 1) {
							// closest indices can be outside of view
							if (data[0][i0] < wsc.min)
								i0++;
							if (data[0][i1] > wsc.max)
								i1--;
						}

						s.min = data0[i0];
						s.max = data0[i1];
					}
					else if (s.show && s.auto)
						accScale(wsc, psc, s, data[i], s.sorted);

					s.idxs[0] = i0;
					s.idxs[1] = i1;
				}
				else {
					if (i > 0) {
						if (s.show && s.auto) {
							// TODO: only handles, assumes and requires facets[0] / 'x' scale, and facets[1] / 'y' scale
							let [ xFacet, yFacet ] = s.facets;
							let xScaleKey = xFacet.scale;
							let yScaleKey = yFacet.scale;
							let [ xData, yData ] = data[i];

							accScale(wipScales[xScaleKey], pendScales[xScaleKey], xFacet, xData, xFacet.sorted);
							accScale(wipScales[yScaleKey], pendScales[yScaleKey], yFacet, yData, yFacet.sorted);

							// temp
							s.min = yFacet.min;
							s.max = yFacet.max;
						}
					}
				}
			});

			// range independent scales
			for (let k in wipScales) {
				let wsc = wipScales[k];
				let psc = pendScales[k];

				if (wsc.from == null && (psc == null || psc.min == null)) {
					let minMax = wsc.range(
						self,
						wsc.min ==  inf ? null : wsc.min,
						wsc.max == -inf ? null : wsc.max,
						k
					);
					wsc.min = minMax[0];
					wsc.max = minMax[1];
				}
			}
		}

		// range dependent scales
		for (let k in wipScales) {
			let wsc = wipScales[k];

			if (wsc.from != null) {
				let base = wipScales[wsc.from];

				if (base.min == null)
					wsc.min = wsc.max = null;
				else {
					let minMax = wsc.range(self, base.min, base.max, k);
					wsc.min = minMax[0];
					wsc.max = minMax[1];
				}
			}
		}

		let changed = {};
		let anyChanged = false;

		for (let k in wipScales) {
			let wsc = wipScales[k];
			let sc = scales[k];

			if (sc.min != wsc.min || sc.max != wsc.max) {
				sc.min = wsc.min;
				sc.max = wsc.max;

				let distr = sc.distr;

				sc._min = distr == 3 ? log10(sc.min) : distr == 4 ? asinh(sc.min, sc.asinh) : sc.min;
				sc._max = distr == 3 ? log10(sc.max) : distr == 4 ? asinh(sc.max, sc.asinh) : sc.max;

				changed[k] = anyChanged = true;
			}
		}

		if (anyChanged) {
			// invalidate paths of all series on changed scales
			series.forEach((s, i) => {
				if (mode == 2) {
					if (i > 0 && changed.y)
						s._paths = null;
				}
				else {
					if (changed[s.scale])
						s._paths = null;
				}
			});

			for (let k in changed) {
				shouldConvergeSize = true;
				fire("setScale", k);
			}

			if (cursor.show && cursor.left >= 0)
				shouldSetCursor = shouldSetLegend = true;
		}

		for (let k in pendScales)
			pendScales[k] = null;
	}

	// grabs the nearest indices with y data outside of x-scale limits
	function getOuterIdxs(ydata) {
		let _i0 = clamp(i0 - 1, 0, dataLen - 1);
		let _i1 = clamp(i1 + 1, 0, dataLen - 1);

		while (ydata[_i0] == null && _i0 > 0)
			_i0--;

		while (ydata[_i1] == null && _i1 < dataLen - 1)
			_i1++;

		return [_i0, _i1];
	}

	function drawSeries() {
		if (dataLen > 0) {
			series.forEach((s, i) => {
				if (i > 0 && s.show && s._paths == null) {
					let _idxs = mode == 2 ? [0, data[i][0].length - 1] : getOuterIdxs(data[i]);
					s._paths = s.paths(self, i, _idxs[0], _idxs[1]);
				}
			});

			series.forEach((s, i) => {
				if (i > 0 && s.show) {
					if (ctxAlpha != s.alpha)
						ctx.globalAlpha = ctxAlpha = s.alpha;

					{
						cacheStrokeFill(i, false);
						s._paths && drawPath(i, false);
					}

					{
						cacheStrokeFill(i, true);

						let _gaps = s._paths ? s._paths.gaps : null;

						let show = s.points.show(self, i, i0, i1, _gaps);
						let idxs = s.points.filter(self, i, show, _gaps);

						if (show || idxs) {
							s.points._paths = s.points.paths(self, i, i0, i1, idxs);
							drawPath(i, true);
						}
					}

					if (ctxAlpha != 1)
						ctx.globalAlpha = ctxAlpha = 1;

					fire("drawSeries", i);
				}
			});
		}
	}

	function cacheStrokeFill(si, _points) {
		let s = _points ? series[si].points : series[si];

		s._stroke = s.stroke(self, si);
		s._fill   = s.fill(self, si);
	}

	function drawPath(si, _points) {
		let s = _points ? series[si].points : series[si];

		let strokeStyle = s._stroke;
		let fillStyle   = s._fill;

		let { stroke, fill, clip: gapsClip, flags } = s._paths;
		let boundsClip = null;
		let width = roundDec(s.width * pxRatio, 3);
		let offset = (width % 2) / 2;

		if (_points && fillStyle == null)
			fillStyle = width > 0 ? "#fff" : strokeStyle;

		let _pxAlign = s.pxAlign == 1 && offset > 0;

		_pxAlign && ctx.translate(offset, offset);

		if (!_points) {
			let lft = plotLft - width / 2,
				top = plotTop - width / 2,
				wid = plotWid + width,
				hgt = plotHgt + width;

			boundsClip = new Path2D();
			boundsClip.rect(lft, top, wid, hgt);
		}

		// the points pathbuilder's gapsClip is its boundsClip, since points dont need gaps clipping, and bounds depend on point size
		if (_points)
			strokeFill(strokeStyle, width, s.dash, s.cap, fillStyle, stroke, fill, flags, gapsClip);
		else
			fillStroke(si, strokeStyle, width, s.dash, s.cap, fillStyle, stroke, fill, flags, boundsClip, gapsClip);

		_pxAlign && ctx.translate(-offset, -offset);
	}

	function fillStroke(si, strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip) {
		let didStrokeFill = false;

		// for all bands where this series is the top edge, create upwards clips using the bottom edges
		// and apply clips + fill with band fill or dfltFill
		bands.forEach((b, bi) => {
			// isUpperEdge?
			if (b.series[0] == si) {
				let lowerEdge = series[b.series[1]];
				let lowerData = data[b.series[1]];

				let bandClip = (lowerEdge._paths || EMPTY_OBJ).band;

				if (isArr(bandClip))
					bandClip = b.dir == 1 ? bandClip[0] : bandClip[1];

				let gapsClip2;

				let _fillStyle = null;

				// hasLowerEdge?
				if (lowerEdge.show && bandClip && hasData(lowerData, i0, i1)) {
					_fillStyle = b.fill(self, bi) || fillStyle;
					gapsClip2 = lowerEdge._paths.clip;
				}
				else
					bandClip = null;

				strokeFill(strokeStyle, lineWidth, lineDash, lineCap, _fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip, gapsClip2, bandClip);

				didStrokeFill = true;
			}
		});

		if (!didStrokeFill)
			strokeFill(strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip);
	}

	const CLIP_FILL_STROKE = BAND_CLIP_FILL | BAND_CLIP_STROKE;

	function strokeFill(strokeStyle, lineWidth, lineDash, lineCap, fillStyle, strokePath, fillPath, flags, boundsClip, gapsClip, gapsClip2, bandClip) {
		setCtxStyle(strokeStyle, lineWidth, lineDash, lineCap, fillStyle);

		if (boundsClip || gapsClip || bandClip) {
			ctx.save();
			boundsClip && ctx.clip(boundsClip);
			gapsClip && ctx.clip(gapsClip);
		}

		if (bandClip) {
			if ((flags & CLIP_FILL_STROKE) == CLIP_FILL_STROKE) {
				ctx.clip(bandClip);
				gapsClip2 && ctx.clip(gapsClip2);
				doFill(fillStyle, fillPath);
				doStroke(strokeStyle, strokePath, lineWidth);
			}
			else if (flags & BAND_CLIP_STROKE) {
				doFill(fillStyle, fillPath);
				ctx.clip(bandClip);
				doStroke(strokeStyle, strokePath, lineWidth);
			}
			else if (flags & BAND_CLIP_FILL) {
				ctx.save();
				ctx.clip(bandClip);
				gapsClip2 && ctx.clip(gapsClip2);
				doFill(fillStyle, fillPath);
				ctx.restore();
				doStroke(strokeStyle, strokePath, lineWidth);
			}
		}
		else {
			doFill(fillStyle, fillPath);
			doStroke(strokeStyle, strokePath, lineWidth);
		}

		if (boundsClip || gapsClip || bandClip)
			ctx.restore();
	}

	function doStroke(strokeStyle, strokePath, lineWidth) {
		if (lineWidth > 0) {
			if (strokePath instanceof Map) {
				strokePath.forEach((strokePath, strokeStyle) => {
					ctx.strokeStyle = ctxStroke = strokeStyle;
					ctx.stroke(strokePath);
				});
			}
			else
				strokePath != null && strokeStyle && ctx.stroke(strokePath);
		}
	}

	function doFill(fillStyle, fillPath) {
		if (fillPath instanceof Map) {
			fillPath.forEach((fillPath, fillStyle) => {
				ctx.fillStyle = ctxFill = fillStyle;
				ctx.fill(fillPath);
			});
		}
		else
			fillPath != null && fillStyle && ctx.fill(fillPath);
	}

	function getIncrSpace(axisIdx, min, max, fullDim) {
		let axis = axes[axisIdx];

		let incrSpace;

		if (fullDim <= 0)
			incrSpace = [0, 0];
		else {
			let minSpace = axis._space = axis.space(self, axisIdx, min, max, fullDim);
			let incrs    = axis._incrs = axis.incrs(self, axisIdx, min, max, fullDim, minSpace);
			incrSpace    = findIncr(min, max, incrs, fullDim, minSpace);
		}

		return (axis._found = incrSpace);
	}

	function drawOrthoLines(offs, filts, ori, side, pos0, len, width, stroke, dash, cap) {
		let offset = (width % 2) / 2;

		pxAlign == 1 && ctx.translate(offset, offset);

		setCtxStyle(stroke, width, dash, cap, stroke);

		ctx.beginPath();

		let x0, y0, x1, y1, pos1 = pos0 + (side == 0 || side == 3 ? -len : len);

		if (ori == 0) {
			y0 = pos0;
			y1 = pos1;
		}
		else {
			x0 = pos0;
			x1 = pos1;
		}

		for (let i = 0; i < offs.length; i++) {
			if (filts[i] != null) {
				if (ori == 0)
					x0 = x1 = offs[i];
				else
					y0 = y1 = offs[i];

				ctx.moveTo(x0, y0);
				ctx.lineTo(x1, y1);
			}
		}

		ctx.stroke();

		pxAlign == 1 && ctx.translate(-offset, -offset);
	}

	function axesCalc(cycleNum) {
	//	log("axesCalc()", arguments);

		let converged = true;

		axes.forEach((axis, i) => {
			if (!axis.show)
				return;

			let scale = scales[axis.scale];

			if (scale.min == null) {
				if (axis._show) {
					converged = false;
					axis._show = false;
					resetYSeries(false);
				}
				return;
			}
			else {
				if (!axis._show) {
					converged = false;
					axis._show = true;
					resetYSeries(false);
				}
			}

			let side = axis.side;
			let ori = side % 2;

			let {min, max} = scale;		// 		// should this toggle them ._show = false

			let [_incr, _space] = getIncrSpace(i, min, max, ori == 0 ? plotWidCss : plotHgtCss);

			if (_space == 0)
				return;

			// if we're using index positions, force first tick to match passed index
			let forceMin = scale.distr == 2;

			let _splits = axis._splits = axis.splits(self, i, min, max, _incr, _space, forceMin);

			// tick labels
			// BOO this assumes a specific data/series
			let splits = scale.distr == 2 ? _splits.map(i => data0[i]) : _splits;
			let incr   = scale.distr == 2 ? data0[_splits[1]] - data0[_splits[0]] : _incr;

			let values = axis._values = axis.values(self, axis.filter(self, splits, i, _space, incr), i, _space, incr);

			// rotating of labels only supported on bottom x axis
			axis._rotate = side == 2 ? axis.rotate(self, values, i, _space) : 0;

			let oldSize = axis._size;

			axis._size = ceil(axis.size(self, values, i, cycleNum));

			if (oldSize != null && axis._size != oldSize)			// ready && ?
				converged = false;
		});

		return converged;
	}

	function paddingCalc(cycleNum) {
		let converged = true;

		padding.forEach((p, i) => {
			let _p = p(self, i, sidesWithAxes, cycleNum);

			if (_p != _padding[i])
				converged = false;

			_padding[i] = _p;
		});

		return converged;
	}

	function drawAxesGrid() {
		for (let i = 0; i < axes.length; i++) {
			let axis = axes[i];

			if (!axis.show || !axis._show)
				continue;

			let side = axis.side;
			let ori = side % 2;

			let x, y;

			let fillStyle = axis.stroke(self, i);

			let shiftDir = side == 0 || side == 3 ? -1 : 1;

			// axis label
			if (axis.label) {
				let shiftAmt = axis.labelGap * shiftDir;
				let baseLpos = round((axis._lpos + shiftAmt) * pxRatio);

				setFontStyle(axis.labelFont[0], fillStyle, "center", side == 2 ? TOP : BOTTOM);

				ctx.save();

				if (ori == 1) {
					x = y = 0;

					ctx.translate(
						baseLpos,
						round(plotTop + plotHgt / 2),
					);
					ctx.rotate((side == 3 ? -PI : PI) / 2);

				}
				else {
					x = round(plotLft + plotWid / 2);
					y = baseLpos;
				}

				ctx.fillText(axis.label, x, y);

				ctx.restore();
			}

			let [_incr, _space] = axis._found;

			if (_space == 0)
				continue;

			let scale = scales[axis.scale];

			let plotDim = ori == 0 ? plotWid : plotHgt;
			let plotOff = ori == 0 ? plotLft : plotTop;

			let axisGap = round(axis.gap * pxRatio);

			let _splits = axis._splits;

			// tick labels
			// BOO this assumes a specific data/series
			let splits = scale.distr == 2 ? _splits.map(i => data0[i]) : _splits;
			let incr   = scale.distr == 2 ? data0[_splits[1]] - data0[_splits[0]] : _incr;

			let ticks = axis.ticks;
			let border = axis.border;
			let tickSize = ticks.show ? round(ticks.size * pxRatio) : 0;

			// rotating of labels only supported on bottom x axis
			let angle = axis._rotate * -PI/180;

			let basePos  = pxRound(axis._pos * pxRatio);
			let shiftAmt = (tickSize + axisGap) * shiftDir;
			let finalPos = basePos + shiftAmt;
			    y        = ori == 0 ? finalPos : 0;
			    x        = ori == 1 ? finalPos : 0;

			let font         = axis.font[0];
			let textAlign    = axis.align == 1 ? LEFT :
			                   axis.align == 2 ? RIGHT :
			                   angle > 0 ? LEFT :
			                   angle < 0 ? RIGHT :
			                   ori == 0 ? "center" : side == 3 ? RIGHT : LEFT;
			let textBaseline = angle ||
			                   ori == 1 ? "middle" : side == 2 ? TOP   : BOTTOM;

			setFontStyle(font, fillStyle, textAlign, textBaseline);

			let lineHeight = axis.font[1] * axis.lineGap;

			let canOffs = _splits.map(val => pxRound(getPos(val, scale, plotDim, plotOff)));

			let _values = axis._values;

			for (let i = 0; i < _values.length; i++) {
				let val = _values[i];

				if (val != null) {
					if (ori == 0)
						x = canOffs[i];
					else
						y = canOffs[i];

					val = "" + val;

					let _parts = val.indexOf("\n") == -1 ? [val] : val.split(/\n/gm);

					for (let j = 0; j < _parts.length; j++) {
						let text = _parts[j];

						if (angle) {
							ctx.save();
							ctx.translate(x, y + j * lineHeight); // can this be replaced with position math?
							ctx.rotate(angle); // can this be done once?
							ctx.fillText(text, 0, 0);
							ctx.restore();
						}
						else
							ctx.fillText(text, x, y + j * lineHeight);
					}
				}
			}

			// ticks
			if (ticks.show) {
				drawOrthoLines(
					canOffs,
					ticks.filter(self, splits, i, _space, incr),
					ori,
					side,
					basePos,
					tickSize,
					roundDec(ticks.width * pxRatio, 3),
					ticks.stroke(self, i),
					ticks.dash,
					ticks.cap,
				);
			}

			// grid
			let grid = axis.grid;

			if (grid.show) {
				drawOrthoLines(
					canOffs,
					grid.filter(self, splits, i, _space, incr),
					ori,
					ori == 0 ? 2 : 1,
					ori == 0 ? plotTop : plotLft,
					ori == 0 ? plotHgt : plotWid,
					roundDec(grid.width * pxRatio, 3),
					grid.stroke(self, i),
					grid.dash,
					grid.cap,
				);
			}

			if (border.show) {
				drawOrthoLines(
					[basePos],
					[1],
					ori == 0 ? 1 : 0,
					ori == 0 ? 1 : 2,
					ori == 1 ? plotTop : plotLft,
					ori == 1 ? plotHgt : plotWid,
					roundDec(border.width * pxRatio, 3),
					border.stroke(self, i),
					border.dash,
					border.cap,
				);
			}
		}

		fire("drawAxes");
	}

	function resetYSeries(minMax) {
	//	log("resetYSeries()", arguments);

		series.forEach((s, i) => {
			if (i > 0) {
				s._paths = null;

				if (minMax) {
					if (mode == 1) {
						s.min = null;
						s.max = null;
					}
					else {
						s.facets.forEach(f => {
							f.min = null;
							f.max = null;
						});
					}
				}
			}
		});
	}

	let queuedCommit = false;

	function commit() {
		if (!queuedCommit) {
			microTask(_commit);
			queuedCommit = true;
		}
	}

	function _commit() {
	//	log("_commit()", arguments);

		if (shouldSetScales) {
			setScales();
			shouldSetScales = false;
		}

		if (shouldConvergeSize) {
			convergeSize();
			shouldConvergeSize = false;
		}

		if (shouldSetSize) {
			setStylePx(under, LEFT,   plotLftCss);
			setStylePx(under, TOP,    plotTopCss);
			setStylePx(under, WIDTH,  plotWidCss);
			setStylePx(under, HEIGHT, plotHgtCss);

			setStylePx(over, LEFT,    plotLftCss);
			setStylePx(over, TOP,     plotTopCss);
			setStylePx(over, WIDTH,   plotWidCss);
			setStylePx(over, HEIGHT,  plotHgtCss);

			setStylePx(wrap, WIDTH,   fullWidCss);
			setStylePx(wrap, HEIGHT,  fullHgtCss);

			// NOTE: mutating this during print preview in Chrome forces transparent
			// canvas pixels to white, even when followed up with clearRect() below
			can.width  = round(fullWidCss * pxRatio);
			can.height = round(fullHgtCss * pxRatio);

			axes.forEach(({ _el, _show, _size, _pos, side }) => {
				if (_el != null) {
					if (_show) {
						let posOffset = (side === 3 || side === 0 ? _size : 0);
						let isVt = side % 2 == 1;

						setStylePx(_el, isVt ? "left"   : "top",    _pos - posOffset);
						setStylePx(_el, isVt ? "width"  : "height", _size);
						setStylePx(_el, isVt ? "top"    : "left",   isVt ? plotTopCss : plotLftCss);
						setStylePx(_el, isVt ? "height" : "width",  isVt ? plotHgtCss : plotWidCss);

						remClass(_el, OFF);
					}
					else
						addClass(_el, OFF);
				}
			});

			// invalidate ctx style cache
			ctxStroke = ctxFill = ctxWidth = ctxJoin = ctxCap = ctxFont = ctxAlign = ctxBaseline = ctxDash = null;
			ctxAlpha = 1;

			syncRect(true);

			fire("setSize");

			shouldSetSize = false;
		}

		if (fullWidCss > 0 && fullHgtCss > 0) {
			ctx.clearRect(0, 0, can.width, can.height);
			fire("drawClear");
			drawOrder.forEach(fn => fn());
			fire("draw");
		}

		if (select.show && shouldSetSelect) {
			setSelect(select);
			shouldSetSelect = false;
		}

		if (cursor.show && shouldSetCursor) {
			updateCursor(null, true, false);
			shouldSetCursor = false;
		}

		if (legend.show && legend.live && shouldSetLegend) {
			setLegend();
			shouldSetLegend = false; // redundant currently
		}

		if (!ready) {
			ready = true;
			self.status = 1;

			fire("ready");
		}

		viaAutoScaleX = false;

		queuedCommit = false;
	}

	self.redraw = (rebuildPaths, recalcAxes) => {
		shouldConvergeSize = recalcAxes || false;

		if (rebuildPaths !== false)
			_setScale(xScaleKey, scaleX.min, scaleX.max);
		else
			commit();
	};

	// redraw() => setScale('x', scales.x.min, scales.x.max);

	// explicit, never re-ranged (is this actually true? for x and y)
	function setScale(key, opts) {
		let sc = scales[key];

		if (sc.from == null) {
			if (dataLen == 0) {
				let minMax = sc.range(self, opts.min, opts.max, key);
				opts.min = minMax[0];
				opts.max = minMax[1];
			}

			if (opts.min > opts.max) {
				let _min = opts.min;
				opts.min = opts.max;
				opts.max = _min;
			}

			if (dataLen > 1 && opts.min != null && opts.max != null && opts.max - opts.min < 1e-16)
				return;

			if (key == xScaleKey) {
				if (sc.distr == 2 && dataLen > 0) {
					opts.min = closestIdx(opts.min, data[0]);
					opts.max = closestIdx(opts.max, data[0]);

					if (opts.min == opts.max)
						opts.max++;
				}
			}

		//	log("setScale()", arguments);

			pendScales[key] = opts;

			shouldSetScales = true;
			commit();
		}
	}

	self.setScale = setScale;

//	INTERACTION

	let xCursor;
	let yCursor;
	let vCursor;
	let hCursor;

	// starting position before cursor.move
	let rawMouseLeft0;
	let rawMouseTop0;

	// starting position
	let mouseLeft0;
	let mouseTop0;

	// current position before cursor.move
	let rawMouseLeft1;
	let rawMouseTop1;

	// current position
	let mouseLeft1;
	let mouseTop1;

	let dragging = false;

	const drag = cursor.drag;

	let dragX = drag.x;
	let dragY = drag.y;

	if (cursor.show) {
		if (cursor.x)
			xCursor = placeDiv(CURSOR_X, over);
		if (cursor.y)
			yCursor = placeDiv(CURSOR_Y, over);

		if (scaleX.ori == 0) {
			vCursor = xCursor;
			hCursor = yCursor;
		}
		else {
			vCursor = yCursor;
			hCursor = xCursor;
		}

		mouseLeft1 = cursor.left;
		mouseTop1 = cursor.top;
	}

	const select = self.select = assign({
		show:   true,
		over:   true,
		left:   0,
		width:  0,
		top:    0,
		height: 0,
	}, opts.select);

	const selectDiv = select.show ? placeDiv(SELECT, select.over ? over : under) : null;

	function setSelect(opts, _fire) {
		if (select.show) {
			for (let prop in opts) {
				select[prop] = opts[prop];

				if (prop in _hideProps)
					setStylePx(selectDiv, prop, opts[prop]);
			}

			_fire !== false && fire("setSelect");
		}
	}

	self.setSelect = setSelect;

	function toggleDOM(i, onOff) {
		let s = series[i];
		let label = showLegend ? legendRows[i] : null;

		if (s.show)
			label && remClass(label, OFF);
		else {
			label && addClass(label, OFF);
			cursorPts.length > 1 && elTrans(cursorPts[i], -10, -10, plotWidCss, plotHgtCss);
		}
	}

	function _setScale(key, min, max) {
		setScale(key, {min, max});
	}

	function setSeries(i, opts, _fire, _pub) {
	//	log("setSeries()", arguments);

		if (opts.focus != null)
			setFocus(i);

		if (opts.show != null) {
			series.forEach((s, si) => {
				if (si > 0 && (i == si || i == null)) {
					s.show = opts.show;
					toggleDOM(si, opts.show);

					_setScale(mode == 2 ? s.facets[1].scale : s.scale, null, null);
					commit();
				}
			});
		}

		_fire !== false && fire("setSeries", i, opts);

		_pub && pubSync("setSeries", self, i, opts);
	}

	self.setSeries = setSeries;

	function setBand(bi, opts) {
		assign(bands[bi], opts);
	}

	function addBand(opts, bi) {
		opts.fill = fnOrSelf(opts.fill || null);
		opts.dir = ifNull(opts.dir, -1);
		bi = bi == null ? bands.length : bi;
		bands.splice(bi, 0, opts);
	}

	function delBand(bi) {
		if (bi == null)
			bands.length = 0;
		else
			bands.splice(bi, 1);
	}

	self.addBand = addBand;
	self.setBand = setBand;
	self.delBand = delBand;

	function setAlpha(i, value) {
		series[i].alpha = value;

		if (cursor.show && cursorPts[i])
			cursorPts[i].style.opacity = value;

		if (showLegend && legendRows[i])
			legendRows[i].style.opacity = value;
	}

	// y-distance
	let closestDist;
	let closestSeries;
	let focusedSeries;
	const FOCUS_TRUE  = {focus: true};

	function setFocus(i) {
		if (i != focusedSeries) {
		//	log("setFocus()", arguments);

			let allFocused = i == null;

			let _setAlpha = focus.alpha != 1;

			series.forEach((s, i2) => {
				let isFocused = allFocused || i2 == 0 || i2 == i;
				s._focus = allFocused ? null : isFocused;
				_setAlpha && setAlpha(i2, isFocused ? 1 : focus.alpha);
			});

			focusedSeries = i;
			_setAlpha && commit();
		}
	}

	if (showLegend && cursorFocus) {
		onMouse(mouseleave, legendTable, e => {
			if (cursor._lock)
				return;

			setCursorEvent(e);

			if (focusedSeries != null)
				setSeries(null, FOCUS_TRUE, true, syncOpts.setSeries);
		});
	}

	function posToVal(pos, scale, can) {
		let sc = scales[scale];

		if (can)
			pos = pos / pxRatio - (sc.ori == 1 ? plotTopCss : plotLftCss);

		let dim = plotWidCss;

		if (sc.ori == 1) {
			dim = plotHgtCss;
			pos = dim - pos;
		}

		if (sc.dir == -1)
			pos = dim - pos;

		let _min = sc._min,
			_max = sc._max,
			pct = pos / dim;

		let sv = _min + (_max - _min) * pct;

		let distr = sc.distr;

		return (
			distr == 3 ? pow(10, sv) :
			distr == 4 ? sinh(sv, sc.asinh) :
			sv
		);
	}

	function closestIdxFromXpos(pos, can) {
		let v = posToVal(pos, xScaleKey, can);
		return closestIdx(v, data[0], i0, i1);
	}

	self.valToIdx = val => closestIdx(val, data[0]);
	self.posToIdx = closestIdxFromXpos;
	self.posToVal = posToVal;
	self.valToPos = (val, scale, can) => (
		scales[scale].ori == 0 ?
		getHPos(val, scales[scale],
			can ? plotWid : plotWidCss,
			can ? plotLft : 0,
		) :
		getVPos(val, scales[scale],
			can ? plotHgt : plotHgtCss,
			can ? plotTop : 0,
		)
	);

	// defers calling expensive functions
	function batch(fn) {
		fn(self);
		commit();
	}

	self.batch = batch;

	self.setCursor = (opts, _fire, _pub) => {
		mouseLeft1 = opts.left;
		mouseTop1 = opts.top;
	//	assign(cursor, opts);
		updateCursor(null, _fire, _pub);
	};

	function setSelH(off, dim) {
		setStylePx(selectDiv, LEFT,  select.left = off);
		setStylePx(selectDiv, WIDTH, select.width = dim);
	}

	function setSelV(off, dim) {
		setStylePx(selectDiv, TOP,    select.top = off);
		setStylePx(selectDiv, HEIGHT, select.height = dim);
	}

	let setSelX = scaleX.ori == 0 ? setSelH : setSelV;
	let setSelY = scaleX.ori == 1 ? setSelH : setSelV;

	function syncLegend() {
		if (showLegend && legend.live) {
			for (let i = mode == 2 ? 1 : 0; i < series.length; i++) {
				if (i == 0 && multiValLegend)
					continue;

				let vals = legend.values[i];

				let j = 0;

				for (let k in vals)
					legendCells[i][j++].firstChild.nodeValue = vals[k];
			}
		}
	}

	function setLegend(opts, _fire) {
		if (opts != null) {
			if (opts.idxs) {
				opts.idxs.forEach((didx, sidx) => {
					activeIdxs[sidx] = didx;
				});
			}
			else if (!isUndef(opts.idx))
				activeIdxs.fill(opts.idx);

			legend.idx = activeIdxs[0];
		}

		for (let sidx = 0; sidx < series.length; sidx++) {
			if (sidx > 0 || mode == 1 && !multiValLegend)
				setLegendValues(sidx, activeIdxs[sidx]);
		}

		if (showLegend && legend.live)
			syncLegend();

		shouldSetLegend = false;

		_fire !== false && fire("setLegend");
	}

	self.setLegend = setLegend;

	function setLegendValues(sidx, idx) {
		let s = series[sidx];
		let src = sidx == 0 && xScaleDistr == 2 ? data0 : data[sidx];
		let val;

		if (multiValLegend)
			val = s.values(self, sidx, idx) ?? NULL_LEGEND_VALUES;
		else {
			val = s.value(self, idx == null ? null : src[idx], sidx, idx);
			val = val == null ? NULL_LEGEND_VALUES : {_: val};
		}

		legend.values[sidx] = val;
	}

	function updateCursor(src, _fire, _pub) {
	//	ts == null && log("updateCursor()", arguments);

		rawMouseLeft1 = mouseLeft1;
		rawMouseTop1 = mouseTop1;

		[mouseLeft1, mouseTop1] = cursor.move(self, mouseLeft1, mouseTop1);

		if (cursor.show) {
			vCursor && elTrans(vCursor, round(mouseLeft1), 0, plotWidCss, plotHgtCss);
			hCursor && elTrans(hCursor, 0, round(mouseTop1), plotWidCss, plotHgtCss);
		}

		let idx;

		// when zooming to an x scale range between datapoints the binary search
		// for nearest min/max indices results in this condition. cheap hack :D
		let noDataInRange = i0 > i1; // works for mode 1 only

		closestDist = inf;

		// TODO: extract
		let xDim = scaleX.ori == 0 ? plotWidCss : plotHgtCss;
		let yDim = scaleX.ori == 1 ? plotWidCss : plotHgtCss;

		// if cursor hidden, hide points & clear legend vals
		if (mouseLeft1 < 0 || dataLen == 0 || noDataInRange) {
			idx = null;

			for (let i = 0; i < series.length; i++) {
				if (i > 0) {
					cursorPts.length > 1 && elTrans(cursorPts[i], -10, -10, plotWidCss, plotHgtCss);
				}
			}

			if (cursorFocus)
				setSeries(null, FOCUS_TRUE, true, src == null && syncOpts.setSeries);

			if (legend.live) {
				activeIdxs.fill(idx);
				shouldSetLegend = true;
			}
		}
		else {
		//	let pctY = 1 - (y / rect.height);

			let mouseXPos, valAtPosX, xPos;

			if (mode == 1) {
				mouseXPos = scaleX.ori == 0 ? mouseLeft1 : mouseTop1;
				valAtPosX = posToVal(mouseXPos, xScaleKey);
				idx = closestIdx(valAtPosX, data[0], i0, i1);
				xPos = valToPosX(data[0][idx], scaleX, xDim, 0);
			}

			for (let i = mode == 2 ? 1 : 0; i < series.length; i++) {
				let s = series[i];

				let idx1  = activeIdxs[i];
				let yVal1 = mode == 1 ? data[i][idx1] : data[i][1][idx1];

				let idx2  = cursor.dataIdx(self, i, idx, valAtPosX);
				let yVal2 = mode == 1 ? data[i][idx2] : data[i][1][idx2];

				shouldSetLegend = shouldSetLegend || yVal2 != yVal1 || idx2 != idx1;

				activeIdxs[i] = idx2;

				let xPos2 = incrRoundUp(idx2 == idx ? xPos : valToPosX(mode == 1 ? data[0][idx2] : data[i][0][idx2], scaleX, xDim, 0), 1);

				if (i > 0 && s.show) {
					let yPos = yVal2 == null ? -10 : incrRoundUp(valToPosY(yVal2, mode == 1 ? scales[s.scale] : scales[s.facets[1].scale], yDim, 0), 1);

					if (cursorFocus && yPos >= 0 && mode == 1) {
						let dist = abs(yPos - mouseTop1);

						if (dist < closestDist) {
							let bias = focus.bias;

							if (bias != 0) {
								let mouseYPos = scaleX.ori == 1 ? mouseLeft1 : mouseTop1;
								let mouseYVal = posToVal(mouseYPos, s.scale);

								let seriesYValSign = yVal2     >= 0 ? 1 : -1;
								let mouseYValSign  = mouseYVal >= 0 ? 1 : -1;

								// with a focus bias, we will never cross zero when prox testing
								// it's either closest towards zero, or closest away from zero
								if (mouseYValSign == seriesYValSign && (
									mouseYValSign == 1 ?
										(bias == 1 ? yVal2 >= mouseYVal : yVal2 <= mouseYVal) :  // >= 0
										(bias == 1 ? yVal2 <= mouseYVal : yVal2 >= mouseYVal)    //  < 0
								)) {
									closestDist = dist;
									closestSeries = i;
								}
							}
							else {
								closestDist = dist;
								closestSeries = i;
							}
						}
					}

					let hPos, vPos;

					if (scaleX.ori == 0) {
						hPos = xPos2;
						vPos = yPos;
					}
					else {
						hPos = yPos;
						vPos = xPos2;
					}

					if (shouldSetLegend && cursorPts.length > 1) {
						elColor(cursorPts[i], cursor.points.fill(self, i), cursor.points.stroke(self, i));

						let ptWid, ptHgt, ptLft, ptTop,
							centered = true,
							getBBox = cursor.points.bbox;

						if (getBBox != null) {
							centered = false;

							let bbox = getBBox(self, i);

							ptLft = bbox.left;
							ptTop = bbox.top;
							ptWid = bbox.width;
							ptHgt = bbox.height;
						}
						else {
							ptLft = hPos;
							ptTop = vPos;
							ptWid = ptHgt = cursor.points.size(self, i);
						}

						elSize(cursorPts[i], ptWid, ptHgt, centered);
						elTrans(cursorPts[i], ptLft, ptTop, plotWidCss, plotHgtCss);
					}
				}
			}
		}

		cursor.idx = idx;
		cursor.left = mouseLeft1;
		cursor.top = mouseTop1;

		if (shouldSetLegend) {
			legend.idx = idx;
			setLegend();
		}

		// nit: cursor.drag.setSelect is assumed always true
		if (select.show && dragging) {
			if (src != null) {
				let [xKey, yKey] = syncOpts.scales;
				let [matchXKeys, matchYKeys] = syncOpts.match;
				let [xKeySrc, yKeySrc] = src.cursor.sync.scales;

				// match the dragX/dragY implicitness/explicitness of src
				let sdrag = src.cursor.drag;
				dragX = sdrag._x;
				dragY = sdrag._y;

				if (dragX || dragY) {
					let { left, top, width, height } = src.select;

					let sori = src.scales[xKey].ori;
					let sPosToVal = src.posToVal;

					let sOff, sDim, sc, a, b;

					let matchingX = xKey != null && matchXKeys(xKey, xKeySrc);
					let matchingY = yKey != null && matchYKeys(yKey, yKeySrc);

					if (matchingX && dragX) {
						if (sori == 0) {
							sOff = left;
							sDim = width;
						}
						else {
							sOff = top;
							sDim = height;
						}

						sc = scales[xKey];

						a = valToPosX(sPosToVal(sOff, xKeySrc),        sc, xDim, 0);
						b = valToPosX(sPosToVal(sOff + sDim, xKeySrc), sc, xDim, 0);

						setSelX(min(a,b), abs(b-a));
					}
					else
						setSelX(0, xDim);

					if (matchingY && dragY) {
						if (sori == 1) {
							sOff = left;
							sDim = width;
						}
						else {
							sOff = top;
							sDim = height;
						}

						sc = scales[yKey];

						a = valToPosY(sPosToVal(sOff, yKeySrc),        sc, yDim, 0);
						b = valToPosY(sPosToVal(sOff + sDim, yKeySrc), sc, yDim, 0);

						setSelY(min(a,b), abs(b-a));
					}
					else
						setSelY(0, yDim);
				}
				else
					hideSelect();
			}
			else {
				let rawDX = abs(rawMouseLeft1 - rawMouseLeft0);
				let rawDY = abs(rawMouseTop1 - rawMouseTop0);

				if (scaleX.ori == 1) {
					let _rawDX = rawDX;
					rawDX = rawDY;
					rawDY = _rawDX;
				}

				dragX = drag.x && rawDX >= drag.dist;
				dragY = drag.y && rawDY >= drag.dist;

				let uni = drag.uni;

				if (uni != null) {
					// only calc drag status if they pass the dist thresh
					if (dragX && dragY) {
						dragX = rawDX >= uni;
						dragY = rawDY >= uni;

						// force unidirectionality when both are under uni limit
						if (!dragX && !dragY) {
							if (rawDY > rawDX)
								dragY = true;
							else
								dragX = true;
						}
					}
				}
				else if (drag.x && drag.y && (dragX || dragY))
					// if omni with no uni then both dragX / dragY should be true if either is true
					dragX = dragY = true;

				let p0, p1;

				if (dragX) {
					if (scaleX.ori == 0) {
						p0 = mouseLeft0;
						p1 = mouseLeft1;
					}
					else {
						p0 = mouseTop0;
						p1 = mouseTop1;
					}

					setSelX(min(p0, p1), abs(p1 - p0));

					if (!dragY)
						setSelY(0, yDim);
				}

				if (dragY) {
					if (scaleX.ori == 1) {
						p0 = mouseLeft0;
						p1 = mouseLeft1;
					}
					else {
						p0 = mouseTop0;
						p1 = mouseTop1;
					}

					setSelY(min(p0, p1), abs(p1 - p0));

					if (!dragX)
						setSelX(0, xDim);
				}

				// the drag didn't pass the dist requirement
				if (!dragX && !dragY) {
					setSelX(0, 0);
					setSelY(0, 0);
				}
			}
		}

		drag._x = dragX;
		drag._y = dragY;

		if (src == null) {
			if (_pub) {
				if (syncKey != null) {
					let [xSyncKey, ySyncKey] = syncOpts.scales;

					syncOpts.values[0] = xSyncKey != null ? posToVal(scaleX.ori == 0 ? mouseLeft1 : mouseTop1, xSyncKey) : null;
					syncOpts.values[1] = ySyncKey != null ? posToVal(scaleX.ori == 1 ? mouseLeft1 : mouseTop1, ySyncKey) : null;
				}

				pubSync(mousemove, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, idx);
			}

			if (cursorFocus) {
				let shouldPub = _pub && syncOpts.setSeries;
				let p = focus.prox;

				if (focusedSeries == null) {
					if (closestDist <= p)
						setSeries(closestSeries, FOCUS_TRUE, true, shouldPub);
				}
				else {
					if (closestDist > p)
						setSeries(null, FOCUS_TRUE, true, shouldPub);
					else if (closestSeries != focusedSeries)
						setSeries(closestSeries, FOCUS_TRUE, true, shouldPub);
				}
			}
		}

		_fire !== false && fire("setCursor");
	}

	let rect = null;

	Object.defineProperty(self, 'rect', {
		get() {
			if (rect == null)
				syncRect(false);

			return rect;
		},
	});

	function syncRect(defer = false) {
		if (defer)
			rect = null;
		else {
			rect = over.getBoundingClientRect();
			fire("syncRect", rect);
		}
	}

	function mouseMove(e, src, _l, _t, _w, _h, _i) {
		if (cursor._lock)
			return;

		// Chrome on Windows has a bug which triggers a stray mousemove event after an initial mousedown event
		// when clicking into a plot as part of re-focusing the browser window.
		// we gotta ignore it to avoid triggering a phantom drag / setSelect
		// However, on touch-only devices Chrome-based browsers trigger a 0-distance mousemove before mousedown
		// so we don't ignore it when mousedown has set the dragging flag
		if (dragging && e != null && e.movementX == 0 && e.movementY == 0)
			return;

		cacheMouse(e, src, _l, _t, _w, _h, _i, false, e != null);

		if (e != null)
			updateCursor(null, true, true);
		else
			updateCursor(src, true, false);
	}

	function cacheMouse(e, src, _l, _t, _w, _h, _i, initial, snap) {
		if (rect == null)
			syncRect(false);

		setCursorEvent(e);

		if (e != null) {
			_l = e.clientX - rect.left;
			_t = e.clientY - rect.top;
		}
		else {
			if (_l < 0 || _t < 0) {
				mouseLeft1 = -10;
				mouseTop1 = -10;
				return;
			}

			let [xKey, yKey] = syncOpts.scales;

			let syncOptsSrc = src.cursor.sync;
			let [xValSrc, yValSrc] = syncOptsSrc.values;
			let [xKeySrc, yKeySrc] = syncOptsSrc.scales;
			let [matchXKeys, matchYKeys] = syncOpts.match;

			let rotSrc = src.axes[0].side % 2 == 1;

			let xDim = scaleX.ori == 0 ? plotWidCss : plotHgtCss,
				yDim = scaleX.ori == 1 ? plotWidCss : plotHgtCss,
				_xDim = rotSrc ? _h : _w,
				_yDim = rotSrc ? _w : _h,
				_xPos = rotSrc ? _t : _l,
				_yPos = rotSrc ? _l : _t;

			if (xKeySrc != null)
				_l = matchXKeys(xKey, xKeySrc) ? getPos(xValSrc, scales[xKey], xDim, 0) : -10;
			else
				_l = xDim * (_xPos/_xDim);

			if (yKeySrc != null)
				_t = matchYKeys(yKey, yKeySrc) ? getPos(yValSrc, scales[yKey], yDim, 0) : -10;
			else
				_t = yDim * (_yPos/_yDim);

			if (scaleX.ori == 1) {
				let __l = _l;
				_l = _t;
				_t = __l;
			}
		}

		if (snap) {
			if (_l <= 1 || _l >= plotWidCss - 1)
				_l = incrRound(_l, plotWidCss);

			if (_t <= 1 || _t >= plotHgtCss - 1)
				_t = incrRound(_t, plotHgtCss);
		}

		if (initial) {
			rawMouseLeft0 = _l;
			rawMouseTop0 = _t;

			[mouseLeft0, mouseTop0] = cursor.move(self, _l, _t);
		}
		else {
			mouseLeft1 = _l;
			mouseTop1 = _t;
		}
	}

	const _hideProps = {
		width: 0,
		height: 0,
		left: 0,
		top: 0,
	};

	function hideSelect() {
		setSelect(_hideProps, false);
	}

	let downSelectLeft;
	let downSelectTop;
	let downSelectWidth;
	let downSelectHeight;

	function mouseDown(e, src, _l, _t, _w, _h, _i) {
		dragging = true;
		dragX = dragY = drag._x = drag._y = false;

		cacheMouse(e, src, _l, _t, _w, _h, _i, true, false);

		if (e != null) {
			onMouse(mouseup, doc, mouseUp, false);
			pubSync(mousedown, self, mouseLeft0, mouseTop0, plotWidCss, plotHgtCss, null);
		}

		let { left, top, width, height } = select;

		downSelectLeft   = left;
		downSelectTop    = top;
		downSelectWidth  = width;
		downSelectHeight = height;

		hideSelect();
	}

	function mouseUp(e, src, _l, _t, _w, _h, _i) {
		dragging = drag._x = drag._y = false;

		cacheMouse(e, src, _l, _t, _w, _h, _i, false, true);

		let { left, top, width, height } = select;

		let hasSelect = width > 0 || height > 0;
		let chgSelect = (
			downSelectLeft   != left   ||
			downSelectTop    != top    ||
			downSelectWidth  != width  ||
			downSelectHeight != height
		);

		hasSelect && chgSelect && setSelect(select);

		if (drag.setScale && hasSelect && chgSelect) {
		//	if (syncKey != null) {
		//		dragX = drag.x;
		//		dragY = drag.y;
		//	}

			let xOff = left,
				xDim = width,
				yOff = top,
				yDim = height;

			if (scaleX.ori == 1) {
				xOff = top,
				xDim = height,
				yOff = left,
				yDim = width;
			}

			if (dragX) {
				_setScale(xScaleKey,
					posToVal(xOff, xScaleKey),
					posToVal(xOff + xDim, xScaleKey)
				);
			}

			if (dragY) {
				for (let k in scales) {
					let sc = scales[k];

					if (k != xScaleKey && sc.from == null && sc.min != inf) {
						_setScale(k,
							posToVal(yOff + yDim, k),
							posToVal(yOff, k)
						);
					}
				}
			}

			hideSelect();
		}
		else if (cursor.lock) {
			cursor._lock = !cursor._lock;

			if (!cursor._lock)
				updateCursor(null, true, false);
		}

		if (e != null) {
			offMouse(mouseup, doc);
			pubSync(mouseup, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null);
		}
	}

	function mouseLeave(e, src, _l, _t, _w, _h, _i) {
		if (cursor._lock)
			return;

		setCursorEvent(e);

		let _dragging = dragging;

		if (dragging) {
			// handle case when mousemove aren't fired all the way to edges by browser
			let snapH = true;
			let snapV = true;
			let snapProx = 10;

			let dragH, dragV;

			if (scaleX.ori == 0) {
				dragH = dragX;
				dragV = dragY;
			}
			else {
				dragH = dragY;
				dragV = dragX;
			}

			if (dragH && dragV) {
				// maybe omni corner snap
				snapH = mouseLeft1 <= snapProx || mouseLeft1 >= plotWidCss - snapProx;
				snapV = mouseTop1  <= snapProx || mouseTop1  >= plotHgtCss - snapProx;
			}

			if (dragH && snapH)
				mouseLeft1 = mouseLeft1 < mouseLeft0 ? 0 : plotWidCss;

			if (dragV && snapV)
				mouseTop1 = mouseTop1 < mouseTop0 ? 0 : plotHgtCss;

			updateCursor(null, true, true);

			dragging = false;
		}

		mouseLeft1 = -10;
		mouseTop1 = -10;

		// passing a non-null timestamp to force sync/mousemove event
		updateCursor(null, true, true);

		if (_dragging)
			dragging = _dragging;
	}

	function dblClick(e, src, _l, _t, _w, _h, _i) {
		if (cursor._lock)
			return;

		setCursorEvent(e);

		autoScaleX();

		hideSelect();

		if (e != null)
			pubSync(dblclick, self, mouseLeft1, mouseTop1, plotWidCss, plotHgtCss, null);
	}

	function syncPxRatio() {
		axes.forEach(syncFontSize);
		_setSize(self.width, self.height, true);
	}

	on(dppxchange, win, syncPxRatio);

	// internal pub/sub
	const events = {};

	events.mousedown = mouseDown;
	events.mousemove = mouseMove;
	events.mouseup = mouseUp;
	events.dblclick = dblClick;
	events["setSeries"] = (e, src, idx, opts) => {
		let seriesIdxMatcher = syncOpts.match[2];
		idx = seriesIdxMatcher(self, src, idx);
		idx != -1 && setSeries(idx, opts, true, false);
	};

	if (cursor.show) {
		onMouse(mousedown,  over, mouseDown);
		onMouse(mousemove,  over, mouseMove);
		onMouse(mouseenter, over, e => {
			setCursorEvent(e);
			syncRect(false);
		});
		onMouse(mouseleave, over, mouseLeave);

		onMouse(dblclick, over, dblClick);

		cursorPlots.add(self);

		self.syncRect = syncRect;
	}

	// external on/off
	const hooks = self.hooks = opts.hooks || {};

	function fire(evName, a1, a2) {
		if (evName in hooks) {
			hooks[evName].forEach(fn => {
				fn.call(null, self, a1, a2);
			});
		}
	}

	(opts.plugins || []).forEach(p => {
		for (let evName in p.hooks)
			hooks[evName] = (hooks[evName] || []).concat(p.hooks[evName]);
	});

	const seriesIdxMatcher = (self, src, srcSeriesIdx) => srcSeriesIdx;

	const syncOpts = assign({
		key: null,
		setSeries: false,
		filters: {
			pub: retTrue,
			sub: retTrue,
		},
		scales: [xScaleKey, series[1] ? series[1].scale : null],
		match: [retEq, retEq, seriesIdxMatcher],
		values: [null, null],
	}, cursor.sync);

	if (syncOpts.match.length == 2)
		syncOpts.match.push(seriesIdxMatcher);

	cursor.sync = syncOpts;

	const syncKey = syncOpts.key;

	const sync = _sync(syncKey);

	function pubSync(type, src, x, y, w, h, i) {
		if (syncOpts.filters.pub(type, src, x, y, w, h, i))
			sync.pub(type, src, x, y, w, h, i);
	}

	sync.sub(self);

	function pub(type, src, x, y, w, h, i) {
		if (syncOpts.filters.sub(type, src, x, y, w, h, i))
			events[type](null, src, x, y, w, h, i);
	}

	self.pub = pub;

	function destroy() {
		sync.unsub(self);
		cursorPlots.delete(self);
		mouseListeners.clear();
		off(dppxchange, win, syncPxRatio);
		root.remove();
		legendTable?.remove(); // in case mounted outside of root
		fire("destroy");
	}

	self.destroy = destroy;

	function _init() {
		fire("init", opts, data);

		setData(data || opts.data, false);

		if (pendScales[xScaleKey])
			setScale(xScaleKey, pendScales[xScaleKey]);
		else
			autoScaleX();

		shouldSetSelect = select.show;
		shouldSetCursor = shouldSetLegend = true;

		_setSize(opts.width, opts.height);
	}

	series.forEach(initSeries);

	axes.forEach(initAxis);

	if (then) {
		if (then instanceof HTMLElement) {
			then.appendChild(root);
			_init();
		}
		else
			then(self, _init);
	}
	else
		_init();

	return self;
}

uPlot.assign = assign;
uPlot.fmtNum = fmtNum;
uPlot.rangeNum = rangeNum;
uPlot.rangeLog = rangeLog;
uPlot.rangeAsinh = rangeAsinh;
uPlot.orient   = orient;
uPlot.pxRatio = pxRatio;

{
	uPlot.join = join;
}

{
	uPlot.fmtDate = fmtDate;
	uPlot.tzDate  = tzDate;
}

uPlot.sync = _sync;

{
	uPlot.addGap = addGap;
	uPlot.clipGaps = clipGaps;

	let paths = uPlot.paths = {
		points,
	};

	(paths.linear  = linear);
	(paths.stepped = stepped);
	(paths.bars    = bars);
	(paths.spline  = monotoneCubic);
}




/***/ }),

/***/ "./src/lib.js":
/*!********************!*\
  !*** ./src/lib.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadlib: () => (/* binding */ loadlib)
/* harmony export */ });
function loadlib(cb) {
  let memory = new WebAssembly.Memory({ initial: 2048, maximum: 4096 });
  let heap = new Uint8Array(memory.buffer);
  let imports = { env: { memory: memory } };

  WebAssembly.instantiateStreaming(fetch("./lib.wasm"), imports).then(function(obj) {
    // one would think that a priority for wasm 1.0 would be convenient interop with javascript typed arrays,
    // like why not allow you to just pass in an Uint8Array array as a param and have it "mmap()"
    // the array buffer for the duration of the function call to some high memory address
    // and pass it in as a pointer. But alas no, one is supposed to perform rituals like this
    obj.heap = heap;
    obj.inbuffer = heap.subarray(0,1024);
    obj.outbuffer = heap.subarray(1024,2048);
    obj.fn = obj.instance.exports;
    obj.wrap_array = function(fn, src) {
      obj.inbuffer.set(src)
      let len = fn(obj.outbuffer.byteOffset, obj.outbuffer.byteLength, obj.inbuffer.byteOffset,src.length);
      if (len < 0) {
        throw new Error("failed at call" + fn + ": " + len);
      }
      return new Uint8Array(obj.outbuffer.subarray(0,len));
    }
    cb(obj);
  });
}



/***/ }),

/***/ "./src/mididriver.js":
/*!***************************!*\
  !*** ./src/mididriver.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setSysExCallback: () => (/* binding */ setSysExCallback),
/* harmony export */   sysExRunning: () => (/* binding */ sysExRunning)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib.js */ "./src/lib.js");



/** @type {MIDIAccess} */
let midi = null;
/** @type {MIDIInput} */
let delugeIn = null;
/** @type {MIDIOutput} */
let delugeOut = null;

let sysExCallback;
var sysExRunning = false;

function setstatus(text) {
  jquery__WEBPACK_IMPORTED_MODULE_0___default()("#midiStatus").text(text);
}

function populateDevices() {
  for (const entry of midi.inputs) {
    const port = entry[1];
    const opt = new Option(port.name, port.id);
    jquery__WEBPACK_IMPORTED_MODULE_0___default()("#chooseIn").append(opt);
    if (port.name.includes("MIDIIN2 (Deluge)")) {
      opt.selected = true;
      setInput(port);
    }
  }
  for (const entry of midi.outputs) {
    const port = entry[1];
    const opt = new Option(port.name, port.id);
    jquery__WEBPACK_IMPORTED_MODULE_0___default()("#chooseOut").append(opt);
    if (port.name.includes("MIDIOUT2 (Deluge)")) {
      opt.selected = true;
      delugeOut = port;
    }
  }
}

function setInput(input) {
  if (delugeIn == input) {
    return;
  }
  if (delugeIn != null) {
    delugeIn.removeEventListener("midimessage", handleData);
  }
  delugeIn = input;
  if (delugeIn != null) {
    //handleData.on("midimessage", handleData);
    delugeIn.addEventListener("midimessage", handleData);
  }
}

function onChangeIn(ev) {
  const id = ev.target.value;
  setInput(midi.inputs.get(id))
}

function onChangeOut(ev) {
  const id = ev.target.value;
  console.log("choose the id:" + id)
  delugeOut = midi.outputs.get(id) || null;
  console.log("choose the port:" + delugeOut)
}

function onStateChange(ev) {
  const port = ev.port;
  const delet = (port.state == "disconnected");
  if (port.type == "input") {
    let found = false;
    let children = jquery__WEBPACK_IMPORTED_MODULE_0___default()("#chooseIn").children();
    for (let i=0; i < children.length; i++) {
      if (children[i].value == port.id) {
        found = true;
        if (delet) {
          children[i].remove();
          if (port == delugeIn) {
            jquery__WEBPACK_IMPORTED_MODULE_0___default()("noneInput").selected = true;
            // or maybe not, if id: are preserved during a disconnect/connect cycle
            setInput(null);
          }
          break;
        }
      }
    }
    if (!found && !delet) {
      const opt = new Option(port.name, port.id);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()("#chooseIn").append(opt);
    }
  } else {
    let found = false;
    let children = jquery__WEBPACK_IMPORTED_MODULE_0___default()("#chooseOut").children();
    for (let i=0; i < children.length; i++) {
      if (children[i].value == port.id) {
        found = true;
        if (delet) {
          children[i].remove();
          if (port == delugeOut) {
            jquery__WEBPACK_IMPORTED_MODULE_0___default()("#noneOutput").selected = true;
            // or maybe not, if id: are preserved during a disconnect/connect cycle
            delugeOut = null;
          }
          break;
        }
      }
    }
    if (!found && !delet) {
      const opt = new Option(port.name, port.id);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()("#chooseOut").append(opt);
    }
  }
}

function onMIDISuccess(midiAccess) {
  setstatus("webmidi ready");
  midi = midiAccess; // store in the global (in real usage, would probably keep in an object instance)
  populateDevices()
  midi.addEventListener("statechange", onStateChange)
}

function onMIDIFailure(msg) {
  setstatus(`Failed to get MIDI access :( - ${msg}`);
}

function getDebug() {
    delugeOut.send([0xf0, 0x7d, 0x03, 0x00, 0x01, 0xf7]);
    sysExRunning = true;
}

function stopDebug() {
    delugeOut.send([0xf0, 0x7d, 0x03, 0x00, 0x00, 0xf7]);
    sysExRunning = false;
}


window.addEventListener('load', function() {
  if (navigator.requestMIDIAccess) {
    navigator.requestMIDIAccess({ sysex: true }).then( onMIDISuccess, onMIDIFailure );
  } else {
    setstatus("webmidi unavail, check browser permissions");
  }

  jquery__WEBPACK_IMPORTED_MODULE_0___default()("#getDebugButton").on("click", getDebug);
  jquery__WEBPACK_IMPORTED_MODULE_0___default()("#stopDebugButton").on("click", stopDebug);
  jquery__WEBPACK_IMPORTED_MODULE_0___default()("#chooseIn").on("change", onChangeIn);
  jquery__WEBPACK_IMPORTED_MODULE_0___default()("#chooseOut").on("change", onChangeOut);
  return;
});

let lastmsg;

/** @param {MIDIMessageEvent} msg */
function handleData(msg) {
  lastmsg = msg
  // console.log(msg.data);
  if (msg.data.length > 8) {
    jquery__WEBPACK_IMPORTED_MODULE_0___default()("dataLog").text("size: " + msg.data.length);
  }
  decode(msg.data)
}

function decode(data) {
  if (data.length < 3 || data[0] != 0xf0 || data[1] != 0x7d) {
    console.log("foreign sysex?");
//  console.log(data);
    return;
  }
    if (data.length >= 5 && data[2] == 0x03 && data[3] == 0x40) {
    let msgbuf = data.subarray(5, data.length-1);
    let message = new TextDecoder().decode(msgbuf);
    if (sysExCallback !== undefined) {
      	if (sysExRunning) sysExCallback(message);
    }
    let chunks = message.split('\n');
    for (let i = 0; i < chunks.length; i++) {
      jquery__WEBPACK_IMPORTED_MODULE_0___default()('#debugOutput')[0].insertAdjacentText('beforeend', chunks[i])
      if (i < chunks.length-1) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()('#debugOutput')[0].insertAdjacentElement('beforeend', document.createElement("br"));
      }
    }
  }
}


function setSysExCallback(callback)
{var theInterval;
// Not used yet.
function setRefresh() {
  if (theInterval != null) {
    clearInterval(theInterval)
    theInterval = null;
  }

  theInterval = setInterval(function() { renderBlock; }, 100);
}

	sysExCallback = callback;
}


/***/ }),

/***/ "./src/uPlotter.js":
/*!*************************!*\
  !*** ./src/uPlotter.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TagInfo: () => (/* binding */ TagInfo),
/* harmony export */   uPlotter: () => (/* binding */ uPlotter)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _js_uPlot_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/uPlot.esm.js */ "./src/js/uPlot.esm.js");
/* harmony import */ var _js_quadtree_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./js/quadtree.js */ "./src/js/quadtree.js");



    





class TagInfo {
	  constructor() {
	  	this.ybase = 0;
			this.reset();
	  }

	  reset() {
	  	this.minTime = Number.MAX_VALUE;
	  	this.maxTime = Number.MIN_VALUE;
	  	this.minRange = Number.MAX_VALUE;
	  	this.maxRange = Number.MIN_VALUE;
	  	this.eventCount = 0;
	  	this.hasTSData = false;
	  }

		updateForEvent(evt) {
				if (evt.value !== undefined) {
					this.hasTSData = true;
          if (evt.value < this.minRange) {
          		this.minRange = evt.value;
          }
          if (evt.value > this.maxRange) {
          		this.maxRange = evt.value; 
          }
        }
       if (evt.absTime < this.minTime) {
          this.minTime = evt.absTime;
       }
       if (evt.absTime > this.maxTime) {
          this.maxTime = evt.absTime; 
       }
      this.eventCount++;
		}
}

	let colorTab = [
	 "red",
	 "green",
	 "blue",
	 "yellow",
	 "black",
	 "orange",
	 "cyan",
	 "gray"
	];
	

			let cursLeft = -10;
			let cursTop = -10;

			const cursorMemo = {
				set: (left, top) => {
					cursLeft = left;
					cursTop = top;
				},
				get: () => ({left: cursLeft, top: cursTop}),
			};

 			function tooltipsPlugin(opts) {
				let cursortt;
				let seriestt;
				let {eventArray, idxOffset} = opts;
				function init(u, opts, data) {
					let over = u.over;
/*
					let tt = cursortt = document.createElement("div");
					tt.className = "tooltip";
					tt.textContent = "(x,y)";
					tt.style.pointerEvents = "none";
					tt.style.position = "absolute";
					tt.style.background = "rgba(0,0,255,0.1)";
					over.appendChild(tt);
*/
					seriestt = opts.series.map((s, i) => {
						if (i == 0) return;

						let tt = document.createElement("div");
						tt.className = "tooltip";
						tt.textContent = "Tooltip!";
						tt.style.pointerEvents = "none";
						tt.style.position = "absolute";
						tt.style.background = "rgba(0,0,0,0.1)";
						tt.style.color = s.color;
						over.appendChild(tt);
						return tt;
					});

					function hideTips() {
						//cursortt.style.display = "none";
						seriestt.forEach((tt, i) => {
							if (i == 0) return;

							tt.style.display = "none";
						});
					}

					function showTips() {
						//cursortt.style.display = null;
						seriestt.forEach((tt, i) => {
							if (i == 0) return;

							let s = u.series[i];
							tt.style.display = s.show ? null : "none";
						});
					}

					over.addEventListener("mouseleave", () => {
						if (!u.cursor._lock) {
						//	u.setCursor({left: -10, top: -10});
							hideTips();
						}
					});

					over.addEventListener("mouseenter", () => {
						showTips();
					});

					if (u.cursor.left < 0)
						hideTips();
					else
						showTips();
				}

				function setCursor(u) {
					const {left, top, idx} = u.cursor;

					opts?.cursorMemo?.set(left, top);

					// this is here to handle if initial cursor position is set
					// not great (can be optimized by doing more enter/leave state transition tracking)
				//	if (left > 0)
				//		u.cursortt.style.display = null;

					//cursortt.style.left = left + "px";
					//cursortt.style.top = top + "px";
					//cursortt.textContent = "(" + u.posToVal(left, "x").toFixed(2) + ", " + u.posToVal(top, "y").toFixed(2) + ")";

					// can optimize further by not applying styles if idx did not change
					seriestt.forEach((tt, i) => {
						if (i == 0) return;

						let s = u.series[i];

						if (s.show) {
							// this is here to handle if initial cursor position is set
							// not great (can be optimized by doing more enter/leave state transition tracking)
						//	if (left > 0)
						//		tt.style.display = null;

							let xVal = u.data[0][idx];
							let yVal = u.data[i][idx];
							if (u.data[i, 0] === undefined) {
								idx--;
							}
							let evt;
							let idxOff = idx + idxOffset;
							if (idxOff >= 0 && idxOff < eventArray.length) {

							  evt = eventArray[idxOff];
							  console.log(evt); console.log(idxOff);
							}
							if (evt !== undefined) {
								tt.textContent = evt.body;
							} else {
								tt.textContent = "";
							}
							tt.style.left = Math.round(u.valToPos(xVal, 'x')) + "px";
							tt.style.top = Math.round(u.valToPos(yVal, s.scale)) + "px";
						}
					});
				}

				return {
					hooks: {
						init,
						setCursor,
						//drawClear: 	drawClearFunction,
						setScale: [
							(u, key) => {
								//console.log('setScale', key);
							}
						],
						setSeries: [
							(u, idx) => {
								//console.log('setSeries', idx);
							}
						],
					},
				};
			}

class uPlotter {

  constructor(viewer) {
  	this.viewer = viewer;
  	this.scaleFactor  = viewer.timeScale;
  }
 
			
	genTSArray(events, tagInfo, indexArray) {

	  if (events.length === 0) return;
		let tagCount = tagInfo.tagList.length;
		let tsArray = new Array(tagCount + 1);
		for (let t = 0; t < tsArray.length; ++t)
			tsArray[t] = [];
	
		let ex = 0;

		let tx = 0;

		while (ex < events.length)
		{
			let evt = events[ex];
			let nowT = (evt.absStart - this.viewer.minAbsTime) / this.scaleFactor;
				// fill in the array for the current time step:
			tsArray[0][tx] = nowT;
			
				// first, assume mostly missing data.
			for (let i = 0; i < tagCount; ++i) {
					tsArray[i + 1][tx] = null;
			}
	
			let done = false;
			while (ex < events.length && !done) {
				let ev2 = events[ex]
				let thisT = (ev2.absStart - this.viewer.minAbsTime) / this.scaleFactor;
				if (thisT <= nowT) {
						let tag = ev2.tag;
						let tagX = tagInfo.tagMap.get(tag);
						tsArray[tagX][tx] = ev2.value;
						indexArray[tx] = ev2.index;
						ex++;
				} else {
					done = true;
				}
			}
			tx++; // to next time column
		}
		return tsArray;
	}

	makeLineChart(o, d, tagInfo, indexArray, appendToElement) {
					if (d === undefined) {
							return;
					}
					let seriesInfo = new Array();
					let axisInfo  = new Array({});
					let title = tagInfo.tagList[0];

					seriesInfo.push({label: title});
	
					for (let i = 0; i < tagInfo.tagList.length; ++i) {
						let tag = tagInfo.tagList[i];
						let gline = {
							label: tag,
							width: 2,
							spanGaps: true,
							
				// series style
      			stroke: colorTab[i % colorTab.length],
      			//fill: "rgba(255, 0, 0, 0.3)",
      			//dash: [10, 5],
						};
						seriesInfo.push(gline);
						
						let aInfo = {
							scale: tag,
						};
					axisInfo.push(aInfo);
					}
					
				const opts = {
					width:  window.innerWidth,
					height: this.viewer.plotHeight,
					title: o.title ?? title,
					drawOrder: ["series", "axes"],
	
					scales: {
						x: {
							time: o.time ?? false,
						}
	
					},
					axes: [
						{},
						{},
					],
					
					legend: {
					//	live: false,
						markers: {
							width: 0,
						}
					},
	
				//	padding: [null, 0, null, 0],
					series: seriesInfo,
				};

				let u = new _js_uPlot_esm_js__WEBPACK_IMPORTED_MODULE_1__["default"](opts, d, appendToElement);
			}

genTLArray(events, tagInfo, indexArray) {
	let symbols = [];
	let minTime = this.viewer.minAbsTime;
	//console.log(events);
	for (let i = 0; i < events.length; ++i) {
		let evt = events[i];
		symbols.push({time: evt.absStart - minTime, dur: evt.duration, tag: evt.tag, index: evt.index});
	}
	symbols.sort((a, b)=> {
				if (a.time === b.time) return 0;
				return (a.time < b.time) ? -1 : 1;
			});

		let timeA = [];
		let yA = [];
		let durA = [];
		let symB = [];

	  for (let i = 0; i < symbols.length; ++i) {
	  	let symb = symbols[i];
	  	timeA.push(symb.time / this.scaleFactor);
	  	let tagX = tagInfo.tagMap.get(symb.tag);
	  	indexArray.push(symb.index);
	  	yA.push(tagX);
	  	let dur = 0;
	  	if (symb.dur !== undefined && symb.dur !== 0) {
	  		dur = symb.dur;
	  	}
	  	durA.push(dur / this.scaleFactor);
	  	symB.push(symbols.index);
	  }
	
		let tlArray = [timeA, yA, durA];
		return tlArray;
};


	makeTimelineChart(o, d, tagInfo, eventArray) {
					if (d === undefined) {
							jquery__WEBPACK_IMPORTED_MODULE_0___default()("#uplotl").empty();
							return;
					}
					;
					let seriesInfo = new Array();
					//let qt;
					let dpr = devicePixelRatio;
					// Since we may have added an empty column to the front of the data array
					// for timing alignment, that can throw off
					// our index by 1, check for that now and setup adjustment.
					let indexOffset = -1;
					for (let x = 1; x < d.length; ++x) {
						if (d[x][0] !== undefined) {
								indexOffset = 0;
						}
					}

					function drawPoints(u, sidx, i0, i1) {

					let { ctx, width } = u;
					let { _stroke, scale, min, max} = u.series[sidx];
					let xR = max - min;
					//let scaleFact = this.viewer.scaleFactor;
					ctx.save();

					ctx.fillStyle = _stroke;

					let j = i0;

					let xOff = u.bbox.left;
					let yOff = u.bbox.top;

					while (j <= i1) {					
						let {min, max} = u.scales["x"];
						let val = u.data[sidx][j];
						if (val !== undefined && val !== null) {
  						let dur = u.data[sidx + 1][j];
  						if (dur === undefined || dur === null) dur = 0;
  						let xRaw = u.data[0][j];
  						let xRawEnd = xRaw + dur;
  
  						let cx = Math.round(u.valToPos(xRaw, 'x', true));
  						let cxend = Math.round(u.valToPos(xRawEnd, 'x', true));
  						let xDur = cxend - cx;
  
  						let cy = Math.round(u.valToPos(val, scale, true));

  						ctx.save();
  						ctx.fillStyle = colorTab[val % colorTab.length];
  						let w = Math.max(8, xDur);
 
  						ctx.fillRect(cx, cy - 8, w, 16);

							let xT = Math.round(cx - xOff);
							let yT = Math.round(cy - yOff);
							let eva = eventArray[j];
							let tv = "";
							if (eva !== undefined) tv =eva.tag;
							//console.log("x " + xT + " Y " + yT + " W " + w + " didx " + j + " " + tv);
/*				
							if (qt !== undefined)
  						qt.add({
								x: xT,
								y: yT,
								w: w,
								h: 16,
								sidx: sidx,
								didx: j
							});
*/
  					ctx.restore();
						}
						j++;
					};
					ctx.restore();
		};

					seriesInfo.push({label: "Events"});
					let gline = {
							width: 3,
							label: "events",
							spanGaps: false,
							points: {
								show: drawPoints,
							},
						 // fill:   (seriesIdx, dataIdx, value) => colorTab[0 % colorTab.length],
							 stroke: (seriesIdx, dataIdx) => {
								return colorTab[1 % colorTab.length];
							},
							
								paths: (a, b, c, d, e, f)=> {
									 null // stops line drawing across events.
									},
								lineInterpolation: null,
						};
				seriesInfo.push(gline);
	
				let tlh = tagInfo.tagList.length * 20 + 50;
				
				let tagNames = tagInfo.tagList;
				let tagYs = [];
				for (let i = 0; i < tagInfo.tagList.length; ++i) {
					tagYs.push(tagInfo.tagMap.get(tagInfo.tagList[i]));
				}

				let idxOffset = 0;
				if (d.length > 1 && (d[1][0] === undefined || d[1][0] === null)) idxOffset = -1;
	
				let opts = {
					width:  window.innerWidth,
					height: tlh,
					title: o.title ?? "Events",
					drawOrder: ["series", "axes"],
	/*
					cursor: {
							dataIdx: (u, seriesIdx, closestIdx, xValue) => {
									let cx = Math.round(u.cursor.left * dpr);
									let cy = Math.round(u.cursor.top * dpr);
									if (seriesIdx == 0 || qt === undefined) return closestIdx;
									console.log("seeking: " + closestIdx + " " +  eventArray[closestIdx].tag + " x " + cx + " y " + cy);
									qt.get(cx, cy, 1, 1, o => {
										if (pointWithin(cx, cy, o.x, o.y, o.x + o.w, o.y + o.h)) {
												if (o.didx !== undefined)	{
													 console.log("found :" + o.didx);
														return o.didx;
													}
												else return closestIdx;
										} // if
									}); // cb
									return closestIdx;
								},
					}, // end cursor 
*/
					spanGaps: false,
					scales: {
						x: {
							time: o.time ?? false,
						}
	
					},
					axes: [
						{},
						{values: (u, splits)=>{
							return tagNames;
						  },
						 splits: () => { return tagYs}
						} 
					],

					legend: {
						show: false,
						markers: {
							width: 2,
						},			
					},
	
					plugins: [
						tooltipsPlugin({
							eventArray,
							cursorMemo,
							idxOffset,
							/*
							drawClearFunction: function(u)  {
								qt = qt || new Quadtree(0, 0, u.bbox.width, u.bbox.height);
								qt.clear();
							},
							*/
						})
					],
					
					series: seriesInfo,
				}; // end opts

				jquery__WEBPACK_IMPORTED_MODULE_0___default()("#uplotl").empty();
				let u = new _js_uPlot_esm_js__WEBPACK_IMPORTED_MODULE_1__["default"](opts, d, jquery__WEBPACK_IMPORTED_MODULE_0___default()("#uplotl")[0]);
			}

  tagMinMax(events) {
  	let tagTab = new Map();
 	 		for (let i=0; i < events.length; ++i) {
 	 			let evt = events[i];
	 			let tag = evt.tag;
	 			if (tag !== undefined && !tagTab.has(tag)) {
	 				tagTab.set(tag, new TagInfo());
	 			}
	
  		let tinfo = tagTab.get(tag);
  		tinfo.updateForEvent(evt);
  	}
  	return tagTab;
  }

	filterEvents(filtfun) {
			let filtered = [];
			for (let i=0; i < this.viewer.events.length; ++i) {
				let evt = this.viewer.events[i];
				if (filtfun(evt)) {
					filtered.push(evt);
				}
			}
		  filtered.sort((a, b)=> {
				if (a.absStart === b.absStart) return 0;
				return (a.absStart < b.absStart) ? -1 : 1;
			});
			this.viewer.matchEndings(filtered);
			//let tsArray = this.genTSArray(filtered);
			//console.log(tsArray);
			return filtered;
	}

	 genTagTables(events)
	 {
	 	  let tagInfoList = this.tagMinMax(events);

	 		let tagList = Array.from(tagInfoList.keys());
	 		tagList.sort();
	
			let tagMap = new Map();
	 		for (let i = 0; i < tagList.length; ++i) {
	 			tagMap.set(tagList[i], i + 1);
	 		}
	 		return {tagList, tagMap, tagInfoList};
	 }

	alignTimes(tm) {
		let minV = Number.MAX_VALUE;
		let maxV = Number.MIN_VALUE;
		for (let lm = 0; lm < tm.length; ++lm) {
			let m = tm[lm];
			if (m === undefined) continue;
			if (m[0][0] < minV) {
				minV = m[0][0];
			}
			let lastX = m[0].length - 1;
			if (m[0][lastX] > maxV) {
				maxV = m[0][lastX];
			}
		}

		for (let lm = 0; lm < tm.length; ++lm) {
			let m = tm[lm];
			if (m === undefined) continue;
			if (m[0][0] > minV) {
				m[0].unshift(minV);
				for (let r = 1; r < m.length; ++r) {
					m[r].unshift(null);
				}
			}
			let lastX = m[0].length - 1;
			if (m[0][lastX] < maxV) {
					m[0].push(maxV);
					for (let r = 1; r < m.length; ++r) {
						m[r].push(null);
				}
			}
		}
	}

  plotEverything() {
  	let performance = window.performance;
    let rstart = performance.now();
  	let tsEvents = this.filterEvents((evt)=>evt.value != undefined && evt.value >= 0);
  	
  	let allTSTags = this.genTagTables(tsEvents);
	
		let allPlotsMade = [];
		let allTSPlotData = [];
		// For each tab in the values table list, break into subplots
		for (let i = 0; i < allTSTags.tagList.length; ++i) {
			let aTagToDo = allTSTags.tagList[i];
			let aTagEvents = this.filterEvents((evt)=>evt.tag === aTagToDo);
			let tagTablefor1 = this.genTagTables(aTagEvents);
			let indexArray = [];
			let aValuePlotArray = this.genTSArray(aTagEvents, tagTablefor1, indexArray);
			allTSPlotData.push({aValuePlotArray, tagTablefor1, indexArray});
			allPlotsMade.push(aValuePlotArray);
		}

		let tlEvents = this.filterEvents((evt)=>evt.value === undefined);
		let tagTable2 = this.genTagTables(tlEvents);
		let indexArray = [];
		let tlData = this.genTLArray(tlEvents, tagTable2, indexArray);
		allPlotsMade.push(tlData);
		this.alignTimes(allPlotsMade);
		jquery__WEBPACK_IMPORTED_MODULE_0___default()("#uplot").empty();
		for (let x = 0; x < allTSPlotData.length; ++x) {
  			this.makeLineChart({mode: 1}, allTSPlotData[x].aValuePlotArray, allTSPlotData[x].tagTablefor1, allTSPlotData[x].indexArray, jquery__WEBPACK_IMPORTED_MODULE_0___default()("#uplot")[0]);
  	}

		this.makeTimelineChart({mode: 1, spanGaps: false}, tlData, tagTable2, tlEvents);
		let rend = performance.now();
    //console.log("Time to render uPlot: " + (rend - rstart));
  }
};

function pointWithin(px, py, rlft, rtop, rrgt, rbtm) {
    return px >= rlft && px <= rrgt && py >= rtop && py <= rbtm;
}


	

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!***************************!*\
  !*** ./src/viewEvents.js ***!
  \***************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _mididriver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mididriver.js */ "./src/mididriver.js");
/* harmony import */ var _js_uPlot_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./js/uPlot.esm.js */ "./src/js/uPlot.esm.js");
/* harmony import */ var _uPlotter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./uPlotter.js */ "./src/uPlotter.js");
/* harmony import */ var _jPlot_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jPlot.js */ "./src/jPlot.js");








var activeView;
// We must also update the 'selected' attribute in the dropdown element in the html file.
var lastTimeScale = 400000000;

var lastPlotHeight = 100;

// Test data:
let rttcapture =
`00> 64E7576E,00200000 Meow
00> 64E76C00 cows
00> 64E76C1E uS per 320 samples: 15
00> 6505A000 ~cows
00> 6505ABCA uS per 320 samples: 11
00> 65CC5990 uS per 320 samples: 49
00> 665F01E9 uS per 320 samples: 159
00> 665F31E9 fur 100
00> 665F3200 Cats
00> 665F32FF uS per 320 samples: 112
00> 66E74C00,00100000 fur
00> 66E761E9 fur 20
00> 66E76C1E uS per 320 samples: 15
00> 66E7A000 ~cows
00> 66E7A040,00010000 Callie
00> 66FF3200,00200000 Cats
00> 66FF8200 Purrs
00> 67FF8900 fur 130
`

let simplecap =
`00> 64E7576E,00200000 Meow
00> 65CC5990 uS per 320 samples: 49
00> 665F01E9 uS per 320 samples: 159
00> 66E7A040,00010000 Callie
00> 64E76C00 cows
00> 64E76C1E uS per 320 sampl
`
let regex = /[0-9A-Fa-f]{8}/g;
function parseHex(string)
{
  if (string.match(regex)) {
    return parseInt(string, 16);
  }
  return NaN;
}

// Check for a valid number in a string.
// thanks to https://makersaid.com/check-if-string-is-number-javascript/#google_vignette 
function isStrictlyNumeric(val) {
    if(val === "" || val === " " || val === null || typeof val === 'boolean') {
        return false;
    }
    return !isNaN(Number(val));
}


const match1 = /^([0-9A-Fa-f]{8})/;
const match2 = /^([0-9A-Fa-f]{8}),([0-9A-Fa-f]{8})/;
const splitspaceorcomma = /[\s,]+/;

class EventScanner
{
  constructor() {

    this.events = [] ;
    this.firstTime = true;
    this.baseTime = 0;
    this.lastBaseTime = 0;
    this.armed = false;
    this.previousStamp = 0;
    this.trackSet = new Set();
    this.trackOrder = [];
    this.trackMap = new Map();
    this.tagInfoTable = new Map();
    this.tagOrderOfAppearance = [];
    this.tagsToTrackNumber = new Map();
    this.timeSeriesTags = new Map();
    this.timeLineTags = new Map();
    this.maxRange = new Map();
    this.minRange = new Map();
    this.minAbsTime = Number.MAX_VALUE;
    this.maxAbsTime = Number.MIN_VALUE;
    this.flipped = true;
    this.maxY = 0;
    this.plotHeight = lastPlotHeight;
    this.laneHeight = 16;
    this.timeScale = lastTimeScale;
    this.captureStart = Date.now();

  }

  parseLine(inbuffer)
  {
    let maxLen = inbuffer.length;
  
    if ( inbuffer.length < 4) return;
    // If we are dealing with RTT data, skip the terminal indicator part.
    if (inbuffer[2] === '>') {
    	inbuffer = inbuffer.substring(4, inbuffer.length);
    }

		let charOff = 0;
		let tsa, tsb = 0;
		let kind = 0;

  	let matches = inbuffer.match(match2);
  	if (matches !== null && matches.length >= 2)
  	{
  		charOff = 17; kind = 2;
  		tsa = parseHex(matches[1]);
  		tsb = parseHex(matches[2]);
  	} else {
  		matches = inbuffer.match(match1);
  		if (matches !== null && matches.length > 1) {
  			charOff = 8; kind = 1;
  			tsa = parseHex(matches[1]);
  		}
  	}
		if (matches === null) return;
    let body = inbuffer.substring(charOff, inbuffer.length).trim();
		let ingested = Date.now();
    let event = {

		  start:	    tsa,
		  duration:   tsb,
		  body:       body,
		  number:			this.events.length,
		  ingested:		ingested,
    };

    this.events.push(event);
  }

  readLines(text)
  {
    let splits = text.split("\n");
    for(let i = 0; i < splits.length; i++) {
      let line = splits[i];
      this.parseLine(line);
    }

    //console.log(this.events);
  }

  overFlowCheck(time)
  {
    if(this.armed) {
      if (this.previousStamp > 0xA0000000 && time < 0x60000000) {
        this.baseTime += 0x100000000;
        this.armed = false;
      }
    } else { //unarmed
      if(time > 0x60000000) {
        this.lastBaseTime = this.baseTime;
        this.armed = true;
      }
    }
    this.previousStamp = time;
  }

  extendTime(time)
  {
    if (time > 0xA0000000)
      return time + this.lastBaseTime;
    else {
      return time + this.baseTime;
    }
  }

  extractInfo(evt) {
    let body = evt.body;
    let tag = "";
    let firstbit = "";
    let lastbit = "";
		let endEvent = false;
	
    let spl = body.split("|");
    if (spl.length > 1) {
      lastbit = spl[1];
    }

    if (spl.length > 0) {
      firstbit = spl[0];
    }

		let sent = body.split(splitspaceorcomma);

		let words = [];
		let numbs = [];

		for (let i = 0; i < sent.length; ++i) {
			let token = sent[i];
			if (isStrictlyNumeric(token)) {
				numbs.push(token);
			} else {
				words.push(token);
			}
		}
	
    if (words.length > 0) {
      tag = words[0];
    }


    if (tag.length === 0) {
      tag = body;
    }

    if (tag.length === 0) {
      tag = evt.body;
    }

    if (tag.length === 0) {
      tag = "_";
    }

		if (tag.indexOf('~') >= 0) {
			tag = tag.replace('~', '');
			endEvent = true;
		}
		// Extract last value from body for time series plotting
    // For now, go with the last number
    if (numbs.length > 0) {
      let str = numbs[numbs.length - 1];
      let num = Number(str);
      evt["value"] = num;
    }

    evt["tag"] = tag;
    evt["split"] = lastbit;
    evt["endEvent"] = endEvent;
 
    if(!this.trackSet.has(tag))
    {
      this.trackOrder.push(tag);
      let kind = evt.value != undefined ? 1 : 0;
      let tagInfo = new _uPlotter_js__WEBPACK_IMPORTED_MODULE_3__.TagInfo(kind);
      this.tagInfoTable.set(tag, tagInfo);
      this.tagOrderOfAppearance.push(tagInfo);
 
      this.tagsToTrackNumber.set(tag, this.trackOrder.length);
      this.trackSet.add(tag);
    }
  }


 searchForPreviousEvent(events, index, tag)
{
	for (let i = index - 1; i >= 0; --i) {
		if (events[i].tag === tag) return i;
	}
		return -1;
}

  reflowTime() {
    // The following assumes that point events advance monotonically
    // while duration events are added to the timeline at their startTime+duration (AKA ending time)
    if (this.events.length == 0) return;
    this.minAbsTime = Number.MAX_VALUE;
    this.maxAbsTime = Number.MIN_VALUE;

    this.tagInfoTable.forEach((v, k)=>v.reset());
    for (let i = 0; i < this.events.length; ++i) {

      let evt = this.events[i];
      let time = evt.start;
      this.overFlowCheck(time);
      let absStart = this.extendTime(time);
      evt["absStart"] = absStart;
      this.extractInfo(evt);
 
      let tag = evt.tag;
      let tagInfo = this.tagInfoTable.get(tag);
      tagInfo.eventCount++;

 			if (absStart < this.minAbsTime) this.minAbsTime = absStart;
 			if ((absStart + evt.duration) > this.maxAbsTime) this.maxAbsTime = absStart + evt.duration;
	
      if(evt.value !== undefined) {
        if (!this.minRange.has(evt.tag)) {
          this.minRange.set(evt.tag, evt.value);
          this.maxRange.set(evt.tag, evt.value);
        } else {
          if (this.minRange.get(evt.tag) > evt.value) {
          		this.minRange.set(evt.tag, evt.value);
          	}
          if (this.maxRange.get(evt.tag) < evt.value) { 
          		this.maxRange.set(evt.tag, evt.value);    
          }
        } // end has
        let val = evt.value;
				if (val > tagInfo.maxRange) tagInfo.maxRange = val;
			   else if (val < tagInfo.minRange) tagInfo.minRange = val;

			  
      } // end undefined value
			  let end = absStart + evt.duration;
      	if (end > tagInfo.maxTime) tagInfo.maxTime = end;
			  if (absStart < tagInfo.minTime) tagInfo.minTime = absStart;
    } // end loop
  }

  report()
  {
    for (let i = 0; i < this.events.length; ++i) {
      let evt = this.events[i];
      console.log(evt.absStart + " " + evt.start + " " + evt.duration + " L: "
                  + evt.body + " T: " + evt.tag + " S: " + evt.split + " C: " + evt.color + " V: " + evt.value);
    }
  }

  matchEndings(eventList) {
  	for (let i = eventList.length - 1; i >= 0; --i) {
  		let evt = eventList[i];
  		if (evt.endEvent) {
  			let lastEx = this.searchForPreviousEvent(eventList, i, evt.tag);
  			if (lastEx >= 0) {
  				let lastEvt = eventList[lastEx];
  				eventList[lastEx].duration = evt.absStart - lastEvt.absStart;
  			}
  		}
  	}
  }
  
  
  assignRows() {
    this.trackMap.clear();
    let y = 0;
    for (let i = 0; i < this.trackOrder.length; ++i)
    {
      let tag = this.trackOrder[i];
      this.trackMap.set(tag, y);
      y += this.minRange.has(tag) ? this.plotHeight +  (this.laneHeight / 2) : this.laneHeight;
    }
    
    this.maxY = y;
  }
}

function openLocal(evt) {
  var files = evt.target.files;
  var f = files[0];
  if (f === undefined) return;
  jquery__WEBPACK_IMPORTED_MODULE_0___default()('#instructions').empty();

  var reader = new FileReader();
// Closure to capture the file information.
  reader.onload = (function(theFile) {
    return function(e) {
      // Display contents of file
      let t = e.target.result;
      setEventData(theFile, t);
    };
  })(f);

  // actually read in the tex file.
  reader.readAsText(f);
}

function setEventData(fileName, text) {
  jquery__WEBPACK_IMPORTED_MODULE_0___default()("#plot").empty();
  let es = new EventScanner();
  activeView = es;
  activeView.baseTime = 0;
  activeView.lastBaseTime = 0;
  es.readLines(text);
  es.reflowTime();
  es.assignRows();
  //es.report();
  let up = new _uPlotter_js__WEBPACK_IMPORTED_MODULE_3__.uPlotter(es);
  up.plotEverything();

	//let jp = new jPlot(es);
 // jp.render();
}


function clearActiveView(event) {
  let es = new EventScanner();
  activeView = es;
  jquery__WEBPACK_IMPORTED_MODULE_0___default()("#debugOutput").empty();
}

function changeScale(event)
{
  let scaleString = new String(event.target.value);
  let ts = 400000000;
  if (scaleString == "microseconds") {
  	ts = 400;
  } else if (scaleString == "milliseconds") {
  	ts = 400000;
  }
	lastTimeScale = ts;
	if (activeView === undefined) return;
	activeView.timeScale = ts;
	activeView.render();
}

function changePlotHeight(event) {
	let asNum = Number(event.target.value);
	lastPlotHeight = asNum;
	if (activeView === undefined) return;
	activeView.plotHeight = asNum;
	//activeView.render();
	}

let callbackBuffer = "";

function renderBlock()
{
	if (!activeView) return;
	//if (!sysExRunning && !tippyActive) {
	//	activateTippy();
	//}

	if (callbackBuffer.length === 0) return;
	let lastNL = callbackBuffer.lastIndexOf("\n");
	if (lastNL >= 0) {
			let completes = callbackBuffer.substring(0, lastNL + 1);
			callbackBuffer =  callbackBuffer.substring(lastNL + 1, callbackBuffer.length);
	    jquery__WEBPACK_IMPORTED_MODULE_0___default()("#plot").empty();
	    activeView.baseTime = 0;
    	activeView.lastBaseTime = 0;
		  activeView.readLines(completes);
  		activeView.reflowTime();
  		activeView.assignRows();

/*
  		let tsData = activeView.uPlotter();
  		activeView.makeChart({mode: 1}, tsData);
*/
  	let up = new _uPlotter_js__WEBPACK_IMPORTED_MODULE_3__.uPlotter(activeView);
  	up.plotEverything();
	}
}

var theInterval;

// Regular render loop;
function setRefresh() {
  if (theInterval != null) {
    clearInterval(theInterval)
    theInterval = null;
  }

  theInterval = setInterval(function() { renderBlock(); }, 100);
}

function sysExCallback(text) {
	if (activeView == undefined) return;

	callbackBuffer = callbackBuffer.concat(text);
}

jquery__WEBPACK_IMPORTED_MODULE_0___default()("#clearbut").on('click', clearActiveView);
jquery__WEBPACK_IMPORTED_MODULE_0___default()("#opener").on('change', openLocal);
jquery__WEBPACK_IMPORTED_MODULE_0___default()("#scale").on('change', changeScale);
jquery__WEBPACK_IMPORTED_MODULE_0___default()("#plotH").on('change', changePlotHeight);

(0,_mididriver_js__WEBPACK_IMPORTED_MODULE_1__.setSysExCallback)(sysExCallback); setRefresh();
setEventData("test", ""); // no quotes. rttcapture or ""
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlld0V2ZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU0sS0FBMEI7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxZQUFZOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUYsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRiw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLG1CQUFtQixpQ0FBaUM7QUFDcEQsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUyw2QkFBNkI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlOztBQUVmLFNBQVM7O0FBRVQ7QUFDQSxTQUFTLGdDQUFnQztBQUN6QyxTQUFTLG1CQUFtQjtBQUM1QixTQUFTLHFDQUFxQztBQUM5QyxTQUFTO0FBQ1QsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVE7O0FBRVI7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0Esa0VBQWtFLFVBQVU7QUFDNUUsdUNBQXVDLDJCQUEyQjtBQUNsRTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhLHVFQUF1RTtBQUNwRjtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixpREFBaUQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsV0FBVyw0Q0FBNEM7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxTQUFTLEdBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLDJCQUEyQix3QkFBd0I7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDJDQUEyQztBQUMzQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMscUNBQXFDO0FBQzlFLHFDQUFxQyxzQ0FBc0M7QUFDM0UscUNBQXFDLHFDQUFxQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckMsc0NBQXNDO0FBQ3RDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsYUFBYTtBQUNyQyxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOzs7QUFHQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnRUFBZ0U7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGNBQWM7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUNBQXVDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1REFBdUQ7QUFDL0U7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0NBQStDO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGVBQWUsb0NBQW9DOztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsK0JBQStCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxxQ0FBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLDhCQUE4QjtBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGNBQWMsV0FBVztBQUN4RSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLHNCQUFzQixjQUFjLHNCQUFzQixnQkFBZ0I7QUFDMUUsZ0JBQWdCLFdBQVcsWUFBWTtBQUN2QyxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsY0FBYztBQUMzRCwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4REFBOEQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLE9BQU87O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrREFBa0QsMEJBQTBCO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsWUFBWSxpQkFBaUI7QUFDN0IsZUFBZTtBQUNmLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUyxtQkFBbUI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBLEtBQUs7QUFDTDs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7QUFDQTs7QUFFQSxjQUFjOztBQUVkOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxNQUFNO0FBQ047O0FBRUEsWUFBWTtBQUNaLElBQUk7QUFDSjtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0Esc0JBQXNCO0FBQ3RCLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGNBQWMsdUNBQXVDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7O0FBS0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0EsZUFBZSxxREFBcUQ7QUFDcEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQSxlQUFlLGtDQUFrQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyxJQUEwQztBQUMvQyxDQUFDLGlDQUFrQixFQUFFLG1DQUFFO0FBQ3ZCO0FBQ0EsRUFBRTtBQUFBLGtHQUFFO0FBQ0o7Ozs7O0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMzlVb0I7QUFDb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHNDQUFzQyw2QkFBNkIsYUFBYSxtQkFBbUIsb0JBQW9CLG1CQUFtQixtQkFBbUI7QUFDbE8sa0VBQWtFLHNDQUFzQyw2QkFBNkIsYUFBYSxtQkFBbUIsb0JBQW9CLG1CQUFtQixtQkFBbUI7QUFDL047QUFDQSxTQUFTLDZDQUFDO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyREFBSztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZDQUFDO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkNBQUM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2Q0FBQztBQUNMLElBQUksNkNBQUM7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZDQUFDLHVDQUF1QztBQUN4RDtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBLGtCQUFrQiw2Q0FBQztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUdBLGVBQWUsS0FBb0Qsb0JBQW9CLENBQTJELENBQUMsa0JBQWtCLGFBQWEsY0FBYyw0REFBNEQsY0FBYyx1QkFBdUIsY0FBYyx3Q0FBd0MscUNBQXFDLDZCQUE2QixJQUFJLHVDQUF1QyxTQUFTLFVBQVUsY0FBYyxtRUFBbUUsV0FBVyxLQUFLLHdCQUF3Qix1REFBdUQsWUFBWSxrQkFBa0IsNkxBQTZMLDRJQUE0SSxvQ0FBb0MsbUxBQW1MLDRCQUE0QixLQUFLLG9DQUFvQyx1WUFBdVksTUFBTSxzQ0FBc0Msb0NBQW9DLHlGQUF5Riw4RUFBOEUsb0NBQW9DLDhDQUE4QyxNQUFNLG1EQUFtRCxDQUFxQiwrSkFBK0osbUJBQW1CLDJDQUEyQyxvQkFBb0IsNkdBQTZHLHlCQUF5QixvQkFBb0IsZ0NBQWdDLGtCQUFrQixHQUFHLDZWQUE2VixnQkFBZ0IsOEJBQThCLDBEQUEwRCwwTEFBMEwsR0FBRyxFQUFFLFlBQVksTUFBTSxnQkFBZ0Isd0pBQXdKLGNBQWMsT0FBTywrR0FBK0csY0FBYyw4QkFBOEIsc0VBQXNFLGNBQWMsa0NBQWtDLGtCQUFrQixnQkFBZ0IsMkJBQTJCLCtCQUErQixnQkFBZ0IsY0FBYyxpREFBaUQsY0FBYywyQkFBMkIsbUJBQW1CLGtEQUFrRCwrQkFBK0Isb0RBQW9ELDZDQUE2QyxjQUFjLHdDQUF3Qyx1S0FBdUssY0FBYyxpQkFBaUIsMkRBQTJELGNBQWMsNkNBQTZDLGdCQUFnQixvRUFBb0UsNkdBQTZHLDhCQUE4QixnQ0FBZ0Msa0RBQWtELFdBQVcseUNBQXlDLGNBQWMscUhBQXFILDJCQUEyQiw0RUFBNEUsWUFBWSxZQUFZLGdCQUFnQixrR0FBa0csMkRBQTJELGdCQUFnQix3REFBd0QsaUZBQWlGLG9CQUFvQiwwTEFBMEwsYUFBYSwyRUFBMkUsT0FBTyxpREFBaUQsY0FBYyxZQUFZLElBQUksMkNBQTJDLEVBQUUsY0FBYyxTQUFTLFlBQVksNEJBQTRCLCtCQUErQiwwQ0FBMEMsVUFBVSxpQ0FBaUMsT0FBTyxpRUFBaUUsNkJBQTZCLDBIQUEwSCxTQUFTLFdBQVcsK0NBQStDLFlBQVksZ0JBQWdCLHVJQUF1SSxxRUFBcUUsRUFBRSx1Q0FBdUMsK0RBQStELCtFQUErRSxpRUFBaUUsY0FBYywySkFBMkoscUVBQXFFLFlBQVksY0FBYyxpQkFBaUIsbUVBQW1FLG9CQUFvQixPQUFPLGFBQWEsVUFBVSx5QkFBeUIsS0FBSyxNQUFNLDJJQUEySSxhQUFhLCtCQUErQiwrQkFBK0IsdUZBQXVGLFNBQVMsbURBQW1ELGNBQWMseUJBQXlCLFdBQVcsc0JBQXNCLCtEQUErRCxtQ0FBbUMsb0JBQW9CLEtBQUssaUNBQWlDLFFBQVEsc0NBQXNDLFNBQVMsdUNBQXVDLE9BQU8scUNBQXFDLGtDQUFrQyxXQUFXLE1BQU0sT0FBTyxhQUFhLEVBQUUscUJBQXFCLHFCQUFxQix5QkFBeUIseUJBQXlCLDJDQUEyQyxtREFBbUQsc0JBQXNCLGtCQUFrQixhQUFhLGNBQWMsY0FBYyx1SUFBdUksK0NBQStDLFNBQVMsY0FBYyxPQUFPLHFEQUFxRCxzREFBc0QsWUFBWSxFQUFFLGtCQUFrQixrQkFBa0IsY0FBYyw4QkFBOEIsZ0hBQWdILDhEQUE4RCxnQkFBZ0IscURBQXFELGtCQUFrQiw0REFBNEQsZ0JBQWdCLEVBQUUsc0JBQXNCLGdCQUFnQixFQUFFLG9CQUFvQixrQkFBa0IsNENBQTRDLDZCQUE2QixxRkFBcUYsMEJBQTBCLDRHQUE0RyxJQUFJLGFBQWEsNEJBQTRCLE9BQU8sdUJBQXVCLGVBQWUsY0FBYyx3QkFBd0IsaWVBQWllLGdCQUFnQiwwQkFBMEIseUJBQXlCLGdCQUFnQixFQUFFLGNBQWMsa0ZBQWtGLGFBQWEsS0FBSyx3QkFBd0IsdURBQXVELFlBQVksYUFBYSxvVkFBb1YsY0FBYyxzQkFBc0IsOEJBQThCLG9CQUFvQiw0REFBNEQsd0JBQXdCLFdBQVcsd0NBQXdDLG9CQUFvQiw4REFBOEQsV0FBVyxFQUFFLFdBQVcsMEZBQTBGLGFBQWEscUdBQXFHLGdCQUFnQiw0RkFBNEYsOENBQThDLGtGQUFrRixhQUFhLDhHQUE4RyxjQUFjLGlEQUFpRCxnQkFBZ0IsbUNBQW1DLFNBQVMsc0dBQXNHLEVBQUUsZ0JBQWdCLG1DQUFtQyxXQUFXLG1EQUFtRCxFQUFFLG1CQUFtQixzQkFBc0IsYUFBYSxhQUFhLDRCQUE0Qiw4Q0FBOEMsRUFBRSxPQUFPLGdCQUFnQix3SEFBd0gsU0FBUyxlQUFlLDRDQUE0QyxlQUFlLG9IQUFvSCx1QkFBdUIscUJBQXFCLDBEQUEwRCxlQUFlLHVCQUF1QixNQUFNLFVBQVUsYUFBYSxNQUFNLDhCQUE4QixXQUFXLGtCQUFrQix1QkFBdUIsTUFBTSx3SkFBd0osU0FBUyxxQkFBcUIsb0ZBQW9GLGdCQUFnQiw4QkFBOEIsNEJBQTRCLEdBQUcsMkhBQTJILDJHQUEyRyw2QkFBNkIseUNBQXlDLDhCQUE4QixxSEFBcUgscUJBQXFCLG1CQUFtQixFQUFFLDBCQUEwQix3QkFBd0Isb0NBQW9DLEVBQUUsSUFBSSxlQUFlLHVEQUF1RCxtQkFBbUIsMkNBQTJDLDRHQUE0RyxxRUFBcUUsd0tBQXdLLHFCQUFxQixzQkFBc0IsT0FBTyxpQkFBaUIsNERBQTRELHdCQUF3QiwySUFBMkksSUFBSSxZQUFZLGlCQUFpQixlQUFlLFlBQVksWUFBWSxJQUFJLG1CQUFtQixnRkFBZ0YsaUJBQWlCLGlCQUFpQixlQUFlLGlCQUFpQiw0Q0FBNEMsSUFBSSxrRUFBa0UsSUFBSSxXQUFXLGlEQUFpRCxRQUFRLDBDQUEwQyxpTUFBaU0sMEJBQTBCLGVBQWUsNEJBQTRCLGVBQWUsaUNBQWlDLGdCQUFnQixFQUFFLGlCQUFpQiw2Q0FBNkMsZUFBZSxFQUFFLEVBQUUsd0JBQXdCLG9CQUFvQixtQkFBbUIsaUJBQWlCLCtCQUErQixpQkFBaUIsc0JBQXNCLGtDQUFrQyxFQUFFLGlCQUFpQixzQkFBc0IsNkNBQTZDLEVBQUUsZUFBZSxvQkFBb0IsZUFBZSw4RUFBOEUsc0JBQXNCLGlCQUFpQiw4QkFBOEIsaUVBQWlFLG9EQUFvRCxvRUFBb0Usd0JBQXdCLGdFQUFnRSxFQUFFLHFHQUFxRyxpQkFBaUIsb0VBQW9FLDRCQUE0QixnQ0FBZ0MsNkJBQTZCLGlEQUFpRCxnQ0FBZ0MsVUFBVSxlQUFlLHdEQUF3RCxLQUFLLGVBQWUsOENBQThDLHNCQUFzQiwyQkFBMkIsa0ZBQWtGLEVBQUUsY0FBYyxpQkFBaUIsME1BQTBNLGNBQWMsTUFBTSxrQkFBa0Isd0JBQXdCLGlLQUFpSyxHQUFHLDhDQUE4Qyw4Q0FBOEMseURBQXlELGtEQUFrRCxNQUFNLHVCQUF1Qiw4RkFBOEYsNERBQTRELE1BQU0sc0ZBQXNGLGlDQUFpQyw0Q0FBNEMsd0hBQXdILGlCQUFpQixpSUFBaUksOEJBQThCLGtCQUFrQiw0QkFBNEIsdUJBQXVCLCtCQUErQix1QkFBdUIsZ0NBQWdDLG1DQUFtQyxjQUFjLGFBQWEsaUJBQWlCLG9DQUFvQyxvQkFBb0IsMkNBQTJDLHNCQUFzQixtQ0FBbUMsU0FBUyxRQUFRLCtFQUErRSxrQ0FBa0MsbUJBQW1CLHFCQUFxQiw0RkFBNEYsK09BQStPLDZCQUE2QixZQUFZLGtMQUFrTCxLQUFLLHdUQUF3VCxxQkFBcUIsaUtBQWlLLGtEQUFrRCxxQkFBcUIsb0JBQW9CLHVCQUF1QixtREFBbUQsOEVBQThFLGVBQWUsZ0JBQWdCLGNBQWMsV0FBVywySEFBMkgsdUJBQXVCLHdDQUF3QyxpQ0FBaUMsY0FBYyxtQkFBbUIseUZBQXlGLFNBQVMsdUdBQXVHLGFBQWEscURBQXFELEtBQUssTUFBTSw4Q0FBOEMsU0FBUyxrQkFBa0Isa0RBQWtELFNBQVMsSUFBSSxhQUFhLFNBQVMsa0JBQWtCLCtCQUErQixTQUFTLE9BQU8sZUFBZSxxRUFBcUUsa0JBQWtCLDhFQUE4RSxlQUFlLGdCQUFnQixjQUFjLFdBQVcseUhBQXlILHVCQUF1Qix3Q0FBd0Msc0JBQXNCLHlDQUF5QyxrREFBa0QsV0FBVywrQkFBK0IsY0FBYyxtQkFBbUIseUZBQXlGLFNBQVMsMExBQTBMLHNFQUFzRSxlQUFlLGdCQUFnQix1RUFBdUUsMENBQTBDLHVDQUF1QywwREFBMEQsMkJBQTJCLDZDQUE2QywyRkFBMkYsa0JBQWtCLHdEQUF3RCw0QkFBNEIsNEJBQTRCLDhCQUE4QixFQUFFLHFFQUFxRSxXQUFXLE9BQU8seUJBQXlCLHFCQUFxQix1QkFBdUIscUNBQXFDLDJFQUEyRSxnQkFBZ0IsaUNBQWlDLDBEQUEwRCxjQUFjLDhCQUE4QixxQkFBcUIsRUFBRSwrQkFBK0IscUJBQXFCLEVBQUUsNENBQTRDLHFCQUFxQixFQUFFLDZDQUE2QyxxQkFBcUIsS0FBSyxHQUFHLHFDQUFxQyxxQkFBTSxtREFBbUQsNEVBQTRFLHNCQUFzQixZQUFZLE9BQU8sb0NBQW9DLHNEQUFzRCxNQUFNLHFIQUFxSCxXQUFXLGtCQUFrQixvQkFBb0Isc0JBQXNCLFNBQVMsVUFBVSxTQUFTLHNDQUFzQyxzRkFBc0YsME1BQTBNLFVBQVUsa0JBQWtCLHNDQUFzQyxnREFBZ0QsbUNBQW1DLDREQUE0RCxlQUFlLHVDQUF1QyxvQkFBb0IsV0FBVyxpRUFBaUUsTUFBTSx1QkFBdUIsc0NBQXNDLGdHQUFnRyxRQUFRLDZCQUE2QiwyREFBMkQsT0FBTyxZQUFZLHVCQUF1QixxRkFBcUYsZUFBZSxvQ0FBb0Msd0tBQXdLLHVHQUF1RyxRQUFRLHNDQUFzQyxNQUFNLDZEQUE2RCxnQkFBZ0IsdUJBQXVCLHFEQUFxRCw4SEFBOEgsZ05BQWdOLHVJQUF1SSwrSUFBK0ksa0VBQWtFLCtCQUErQixxQkFBcUIsT0FBTyxzQ0FBc0MsNENBQTRDLHlEQUF5RCxzSkFBc0osbUJBQW1CLHFCQUFxQixNQUFNLDBCQUEwQixNQUFNLG9DQUFvQyxNQUFNLHNCQUFzQiwrQkFBK0Isa0NBQWtDLG1DQUFtQyw0ZEFBNGQsMEdBQTBHLDRHQUE0RyxJQUFJLHdEQUF3RCxRQUFRLG9DQUFvQyw2SUFBNkksb0dBQW9HLE9BQU8sb0NBQW9DLCtEQUErRCwrREFBK0QsaUNBQWlDLGFBQWEsbUVBQW1FLHdCQUF3QixpREFBaUQsS0FBSyx3QkFBd0IsaURBQWlELFVBQVUsZUFBZSxzQ0FBc0Msd0VBQXdFLDRCQUE0QixrQkFBa0IsMEpBQTBKLDBFQUEwRSxvQkFBb0IsSUFBSSxvRUFBb0UsNkVBQTZFLG1LQUFtSyxLQUFLLHlDQUF5Qyx3Q0FBd0MsT0FBTywyQkFBMkIseUJBQXlCLCtCQUErQixnQ0FBZ0Msa0NBQWtDLHlDQUF5QyxhQUFhLG9DQUFvQyw0SkFBNEosNEJBQTRCLGtHQUFrRyw0Q0FBNEMsb0JBQW9CLElBQUksMkJBQTJCLFVBQVUsT0FBTyx5QkFBeUIsc0hBQXNILDZFQUE2RSx5QkFBeUIsRUFBRSxZQUFZLHVCQUF1QixjQUFjLHVDQUF1QyxpQkFBaUIsMENBQTBDLHdDQUF3QyxlQUFlLFlBQVkscUJBQXFCLGNBQWMsV0FBVyxxQ0FBcUMsa0RBQWtELDJIQUEySCxpS0FBaUssaUZBQWlGLDhDQUE4QyxTQUFTLGlCQUFpQixhQUFhLFdBQVcsc0NBQXNDLCtCQUErQixpRkFBaUYsOENBQThDLDBCQUEwQixpQkFBaUIsYUFBYSx5S0FBeUssc0JBQXNCLE1BQU0sRUFBRSxlQUFlLGlCQUFpQixFQUFFLFVBQVUsVUFBVSxvQ0FBb0MsV0FBVyw0REFBNEQsbUNBQW1DLGFBQWEsZ0JBQWdCLHFDQUFxQyxFQUFFLHNCQUFzQiw0RUFBNEUscUJBQXFCLGNBQWMsaUhBQWlILEVBQUUsb0JBQW9CLDZCQUE2QixjQUFjLGdDQUFnQyx3Q0FBd0MsNkNBQTZDLGtHQUFrRywyQkFBMkIsVUFBVSwwQ0FBMEMsZ0JBQWdCLGNBQWMsV0FBVywyTkFBMk4sa0ZBQWtGLHFGQUFxRix5RkFBeUYsNkZBQTZGLGFBQWEsZ0RBQWdELGdDQUFnQyxhQUFhLFdBQVcsMkNBQTJDLHVFQUF1RSw0QkFBNEIsb05BQW9OLHVEQUF1RCxRQUFRLDBIQUEwSCx5SUFBeUksYUFBYSx3QkFBd0Isc0VBQXNFLGNBQWMsNENBQTRDLGdCQUFnQixxR0FBcUcsRUFBRSxjQUFjLHdDQUF3Qyw0QkFBNEIsOEJBQThCLG9EQUFvRCxnQkFBZ0IsaUJBQWlCLGlEQUFpRCw0RkFBNEYsaUJBQWlCLG1DQUFtQyx5RkFBeUYsUUFBUSxlQUFlLG1CQUFtQixpQkFBaUIsY0FBYyxjQUFjLHVDQUF1QyxZQUFZLG1DQUFtQyxXQUFXLHFCQUFxQixFQUFFLGNBQWMsOEJBQThCLHVCQUF1QixFQUFFLCtCQUErQix1QkFBdUIsRUFBRSw2QkFBNkIsV0FBVyw4Q0FBOEMsOEZBQThGLHVRQUF1USxvQkFBb0Isa0lBQWtJLHlDQUF5QyxnREFBZ0QscUlBQXFJLHlLQUF5SyxrSkFBa0osR0FBRyx5QkFBeUIsRUFBRSw2QkFBNkIsV0FBVyw4Q0FBOEMsOEZBQThGLCtUQUErVCxzQkFBc0IsNFNBQTRTLEVBQUUsSUFBSSxFQUFFLCtCQUErQix1RUFBdUUsMEJBQTBCLG9FQUFvRSxtREFBbUQsdUhBQXVILCtFQUErRSwrQkFBK0Isc0dBQXNHLG9DQUFvQyxxR0FBcUcsZUFBZSw0QkFBNEIsS0FBSyxHQUFHLE9BQU8sc0NBQXNDLFdBQVcsT0FBTywwQkFBMEIsb0JBQW9CLDZGQUE2RixxTUFBcU0sOEJBQThCLDBHQUEwRywwQkFBMEIsZ0NBQWdDLHNGQUFzRiwySUFBMkksb0dBQW9HLFdBQVcsd0JBQXdCLDBFQUEwRSxnQ0FBZ0MsMkNBQTJDLGdDQUFnQywyQ0FBMkMsb0VBQW9FLG1HQUFtRywrQ0FBK0MsZ0VBQWdFLHFCQUFxQixzRkFBc0YsZ0lBQWdJLGVBQWUseUJBQXlCLG9CQUFvQixrQ0FBa0MsMEJBQTBCLGNBQWMsZ0JBQWdCLDBCQUEwQixrQkFBa0IsYUFBYSxVQUFVLGdFQUFnRSx3REFBd0Qsb0JBQW9CLHlCQUF5QixjQUFjLDRCQUE0QixnREFBZ0QsMEJBQTBCLGtEQUFrRCxZQUFZLGFBQWEsK0JBQStCLHVCQUF1QixzREFBc0Qsa0JBQWtCLE9BQU8saUNBQWlDLHlCQUF5Qiw2Q0FBNkMsMEJBQTBCLG1DQUFtQyxrQ0FBa0MsWUFBWSxhQUFhLCtCQUErQix1QkFBdUIsZ0RBQWdELGdDQUFnQyx3QkFBd0Isb0VBQW9FLGlEQUFpRCx5Q0FBeUMsVUFBVSxtRUFBbUUsK0NBQStDLHVDQUF1QyxVQUFVLGtGQUFrRixVQUFVLG9DQUFvQyw0QkFBNEIsaUZBQWlGLFVBQVUsb0NBQW9DLDRCQUE0Qiw2REFBNkQsZ0NBQWdDLHdCQUF3QixpRkFBaUYsVUFBVSwrQ0FBK0MsdUNBQXVDLGdGQUFnRixVQUFVLCtDQUErQyx1Q0FBdUMsMEVBQTBFLFVBQVUsb0NBQW9DLDRCQUE0Qix5RUFBeUUsVUFBVSxvQ0FBb0MsNEJBQTRCLGdGQUFnRixVQUFVLG9DQUFvQyw0QkFBNEIsK0VBQStFLFVBQVUsZ0NBQWdDLHdCQUF3QiwyRUFBMkUsVUFBVSw2Q0FBNkMscUNBQXFDLDBFQUEwRSxVQUFVLHlDQUF5QyxpQ0FBaUMsbURBQW1ELDBCQUEwQixxREFBcUQsU0FBUyxhQUFhLGtDQUFrQywwQkFBMEIseURBQXlELGtCQUFrQixPQUFPLDRCQUE0QixvQkFBb0IsZ0RBQWdELDZCQUE2QixtQ0FBbUMsa0NBQWtDLFNBQVMsYUFBYSxrQ0FBa0MsMEJBQTBCLG1EQUFtRCxpQ0FBaUMseUJBQXlCLHVFQUF1RSxtREFBbUQsMkNBQTJDLFVBQVUsc0VBQXNFLGlEQUFpRCx5Q0FBeUMsVUFBVSxxRkFBcUYsVUFBVSxtQ0FBbUMsMkJBQTJCLG9GQUFvRixVQUFVLG1DQUFtQywyQkFBMkIsZ0VBQWdFLDZCQUE2QixxQkFBcUIsb0ZBQW9GLFVBQVUsOENBQThDLHNDQUFzQyxtRkFBbUYsVUFBVSxnREFBZ0Qsd0NBQXdDLDZFQUE2RSxVQUFVLG1DQUFtQywyQkFBMkIsNEVBQTRFLFVBQVUsbUNBQW1DLDJCQUEyQixtRkFBbUYsVUFBVSxtQ0FBbUMsMkJBQTJCLGtGQUFrRixVQUFVLGdDQUFnQyx3QkFBd0IsOEVBQThFLFVBQVUsNENBQTRDLG9DQUFvQyw2RUFBNkUsVUFBVSx5Q0FBeUMsaUNBQWlDLGlEQUFpRCwwQkFBMEIsbURBQW1ELFlBQVksYUFBYSwwQ0FBMEMsa0NBQWtDLHVEQUF1RCxrQkFBa0IsT0FBTyxnQ0FBZ0Msd0JBQXdCLDhDQUE4QywyQkFBMkIsaUNBQWlDLG9DQUFvQyxXQUFXLGFBQWEsK0JBQStCLHVCQUF1QixpREFBaUQsZ0NBQWdDLHdCQUF3QixxRUFBcUUsaURBQWlELHlDQUF5QyxVQUFVLG9FQUFvRSxpREFBaUQseUNBQXlDLFVBQVUsbUZBQW1GLFVBQVUsb0NBQW9DLDRCQUE0QixrRkFBa0YsVUFBVSxvQ0FBb0MsNEJBQTRCLDhEQUE4RCwrQkFBK0IsdUJBQXVCLGtGQUFrRixVQUFVLCtDQUErQyx1Q0FBdUMsaUZBQWlGLFVBQVUsZ0RBQWdELHdDQUF3QywyRUFBMkUsVUFBVSxvQ0FBb0MsNEJBQTRCLDBFQUEwRSxVQUFVLG9DQUFvQyw0QkFBNEIsaUZBQWlGLFVBQVUsb0NBQW9DLDRCQUE0QixnRkFBZ0YsVUFBVSxnQ0FBZ0Msd0JBQXdCLDRFQUE0RSxVQUFVLDZDQUE2QyxxQ0FBcUMsMkVBQTJFLFVBQVUseUNBQXlDLGlDQUFpQyxrREFBa0QsMEJBQTBCLG9EQUFvRCxXQUFXLGFBQWEsMENBQTBDLGtDQUFrQyx3REFBd0Qsa0JBQWtCLE9BQU8saUNBQWlDLHlCQUF5QiwrQ0FBK0MsNEJBQTRCLGlDQUFpQyxvQ0FBb0MsVUFBVSxhQUFhLGtDQUFrQywwQkFBMEIsa0RBQWtELGlDQUFpQyx5QkFBeUIsc0VBQXNFLG1EQUFtRCwyQ0FBMkMsVUFBVSxxRUFBcUUsbURBQW1ELDJDQUEyQyxVQUFVLG9GQUFvRixVQUFVLG1DQUFtQywyQkFBMkIsbUZBQW1GLFVBQVUsbUNBQW1DLDJCQUEyQiwrREFBK0QsOEJBQThCLHNCQUFzQixtRkFBbUYsVUFBVSw4Q0FBOEMsc0NBQXNDLGtGQUFrRixVQUFVLCtDQUErQyx1Q0FBdUMsNEVBQTRFLFVBQVUsbUNBQW1DLDJCQUEyQiwyRUFBMkUsVUFBVSxtQ0FBbUMsMkJBQTJCLGtGQUFrRixVQUFVLG1DQUFtQywyQkFBMkIsaUZBQWlGLFVBQVUsZ0NBQWdDLHdCQUF3Qiw2RUFBNkUsVUFBVSw0Q0FBNEMsb0NBQW9DLDRFQUE0RSxVQUFVLHlDQUF5QyxpQ0FBaUMsZUFBZSxrQkFBa0IsV0FBVyxrQkFBa0IsZ0JBQWdCLG9CQUFvQixrQkFBa0Isc0JBQXNCLG1DQUFtQyxrQ0FBa0Msc0JBQXNCLGdDQUFnQyxvQkFBb0IsaUJBQWlCLGdDQUFnQyxvQkFBb0IsZUFBZSxpQ0FBaUMsZ0JBQWdCLDZCQUE2QixnREFBZ0Qsa0VBQWtFLDBEQUEwRCxrREFBa0QsaUdBQWlHLGlDQUFpQyxvQkFBb0IsaURBQWlELCtEQUErRCx1REFBdUQsZ0RBQWdELHdDQUF3QyxnQ0FBZ0MsK0JBQStCLGtCQUFrQixRQUFRLFNBQVMsa0JBQWtCLFdBQVcsV0FBVyxVQUFVLG9CQUFvQix1QkFBdUIsb0JBQW9CLGdCQUFnQixrQkFBa0Isc0JBQXNCLHNCQUFzQixrQkFBa0IsVUFBVSxTQUFTLFFBQVEsV0FBVyxvREFBb0QsNENBQTRDLG1DQUFtQywyQkFBMkIsc0JBQXNCLFdBQVcsV0FBVyxpQkFBaUIsMkZBQTJGLGdEQUFnRCx3Q0FBd0MsMEZBQTBGLDZDQUE2QyxxQ0FBcUMsNEhBQTRILDhDQUE4QyxzQ0FBc0MsMkhBQTJILDZDQUE2QyxxQ0FBcUMsMkhBQTJILGlEQUFpRCx5Q0FBeUMsMEhBQTBILGdEQUFnRCx3Q0FBd0MseUJBQXlCLGNBQWMsY0FBYyw2QkFBNkIsTUFBTTs7Ozs7Ozs7Ozs7Ozs7OztBQ0ExMm1EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCLDZCQUE2QixnQkFBZ0I7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHFCQUFxQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQiwwQ0FBMEM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVUsSUFBSTtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBLGtCQUFrQixFQUFFLEVBQUUsRUFBRTtBQUN4QjtBQUNBLDBCQUEwQixHQUFHO0FBQzdCO0FBQ0Esa0JBQWtCLEdBQUc7QUFDckIsa0JBQWtCLEVBQUUsRUFBRSxHQUFHO0FBQ3pCO0FBQ0E7QUFDQSxtQkFBbUIsR0FBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBLHdCQUF3QixJQUFJO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUssRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUUsSUFBSSxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLENBQUM7QUFDRDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLENBQUM7QUFDRDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxjQUFjO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVSxXQUFXO0FBQ2hDLFdBQVcsVUFBVSxXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx3QkFBd0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOEJBQThCO0FBQzVELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3Qyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JELGtFQUFrRTtBQUNsRSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtCQUFrQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywrQ0FBK0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxTQUFTLHVDQUF1QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwR0FBMEc7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdCQUF3QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdCQUF3QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMEJBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNDQUFzQyxjQUFjO0FBQ3BGO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekMsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGFBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZSxPQUFPLGNBQWM7QUFDM0UsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQixXQUFXO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0NBQXNDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsVUFBVSxVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkJBQTJCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJCQUEyQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0Qjs7Ozs7Ozs7Ozs7Ozs7OztBQ3BtTHJCO0FBQ1Asd0NBQXdDLDhCQUE4QjtBQUN0RTtBQUNBLGtCQUFrQixPQUFPOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hCc0I7QUFDVztBQUNqQztBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxFQUFFLDZDQUFDO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2Q0FBQztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZDQUFDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2Q0FBQztBQUNwQixrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUFDO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw2Q0FBQztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsbUJBQW1CLDZDQUFDO0FBQ3BCLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDZDQUFDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRSw2Q0FBQztBQUNILEVBQUUsNkNBQUM7QUFDSCxFQUFFLDZDQUFDO0FBQ0gsRUFBRSw2Q0FBQztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2Q0FBQztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDLE1BQU0sNkNBQUM7QUFDUDtBQUNBLFFBQVEsNkNBQUM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwTWE7QUFDYjtBQUNBO0FBQ0E7QUFDc0I7QUFDdEI7QUFDc0M7QUFDRTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsNkJBQTZCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVCQUF1QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsUUFBUTtBQUNSLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQSxnQkFBZ0IsZ0ZBQWdGO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sNkNBQUM7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVLEdBQUc7QUFDYjtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSSw2Q0FBQztBQUNMLGdCQUFnQix3REFBSyxVQUFVLDZDQUFDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQ0FBMEM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw2Q0FBQztBQUNILGtCQUFrQiwwQkFBMEI7QUFDNUMseUJBQXlCLFFBQVEsZ0dBQWdHLDZDQUFDO0FBQ2xJO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyQjtBQUMzQjs7Ozs7O1VDM29CQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsaUNBQWlDLFdBQVc7V0FDNUM7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTmE7QUFDYjtBQUNzQjtBQUN5QztBQUN6QjtBQUNVO0FBQ2Y7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRTtBQUNoQyw4QkFBOEIsRUFBRSxlQUFlLEVBQUU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw2Q0FBQztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDZDQUFDO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDZDQUFDO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZDQUFDO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0EsZ0JBQWdCLGtEQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQUM7QUFDRCw2Q0FBQztBQUNELDZDQUFDO0FBQ0QsNkNBQUM7QUFDRDtBQUNBLGdFQUFnQixpQkFBaUI7QUFDakMsMEJBQTBCLDhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlld0V2ZW50cy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJ3ZWJwYWNrOi8vdmlld0V2ZW50cy8uL3NyYy9qUGxvdC5qcyIsIndlYnBhY2s6Ly92aWV3RXZlbnRzLy4vc3JjL2pzL3F1YWR0cmVlLmpzIiwid2VicGFjazovL3ZpZXdFdmVudHMvLi9zcmMvanMvdGlwcHkuYWxsLm1pbi5qcyIsIndlYnBhY2s6Ly92aWV3RXZlbnRzLy4vc3JjL2pzL3VQbG90LmVzbS5qcyIsIndlYnBhY2s6Ly92aWV3RXZlbnRzLy4vc3JjL2xpYi5qcyIsIndlYnBhY2s6Ly92aWV3RXZlbnRzLy4vc3JjL21pZGlkcml2ZXIuanMiLCJ3ZWJwYWNrOi8vdmlld0V2ZW50cy8uL3NyYy91UGxvdHRlci5qcyIsIndlYnBhY2s6Ly92aWV3RXZlbnRzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3ZpZXdFdmVudHMvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vdmlld0V2ZW50cy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vdmlld0V2ZW50cy93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3ZpZXdFdmVudHMvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly92aWV3RXZlbnRzL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vdmlld0V2ZW50cy8uL3NyYy92aWV3RXZlbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My43LjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMjMtMDgtMjhUMTM6MzdaXG4gKi9cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0IHRyYWMtMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBmbGF0ID0gYXJyLmZsYXQgPyBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuZmxhdC5jYWxsKCBhcnJheSApO1xufSA6IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0cmV0dXJuIGFyci5jb25jYXQuYXBwbHkoIFtdLCBhcnJheSApO1xufTtcblxuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuXHRcdC8vIEluIHNvbWUgYnJvd3NlcnMsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCA8b2JqZWN0PiBlbGVtZW50c1xuXHRcdC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG5cdFx0Ly8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuXHRcdC8vIFN1cHBvcnQ6IFF0V2ViIDw9My44LjUsIFdlYktpdCA8PTUzNC4zNCwgd2todG1sdG9wZGYgdG9vbCA8PTAuMTIuNVxuXHRcdC8vIFBsdXMgZm9yIG9sZCBXZWJLaXQsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCBjb2xsZWN0aW9uc1xuXHRcdC8vIChlLmcuLCBgdHlwZW9mIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZGl2XCIpID09PSBcImZ1bmN0aW9uXCJgKS4gKGdoLTQ3NTYpXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiICYmXG5cdFx0XHR0eXBlb2Ygb2JqLml0ZW0gIT09IFwiZnVuY3Rpb25cIjtcblx0fTtcblxuXG52YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH07XG5cblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG5cblxuXHR2YXIgcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyA9IHtcblx0XHR0eXBlOiB0cnVlLFxuXHRcdHNyYzogdHJ1ZSxcblx0XHRub25jZTogdHJ1ZSxcblx0XHRub01vZHVsZTogdHJ1ZVxuXHR9O1xuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIG5vZGUsIGRvYyApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgaSwgdmFsLFxuXHRcdFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHRmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA2NCssIEVkZ2UgMTgrXG5cdFx0XHRcdC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgXCJub25jZVwiIHByb3BlcnR5IG9uIHNjcmlwdHMuXG5cdFx0XHRcdC8vIE9uIHRoZSBvdGhlciBoYW5kLCBqdXN0IHVzaW5nIGBnZXRBdHRyaWJ1dGVgIGlzIG5vdCBlbm91Z2ggYXNcblx0XHRcdFx0Ly8gdGhlIGBub25jZWAgYXR0cmlidXRlIGlzIHJlc2V0IHRvIGFuIGVtcHR5IHN0cmluZyB3aGVuZXZlciBpdFxuXHRcdFx0XHQvLyBiZWNvbWVzIGJyb3dzaW5nLWNvbnRleHQgY29ubmVjdGVkLlxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL2lzc3Vlcy8yMzY5XG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNub25jZS1hdHRyaWJ1dGVzXG5cdFx0XHRcdC8vIFRoZSBgbm9kZS5nZXRBdHRyaWJ1dGVgIGNoZWNrIHdhcyBhZGRlZCBmb3IgdGhlIHNha2Ugb2Zcblx0XHRcdFx0Ly8gYGpRdWVyeS5nbG9iYWxFdmFsYCBzbyB0aGF0IGl0IGNhbiBmYWtlIGEgbm9uY2UtY29udGFpbmluZyBub2RlXG5cdFx0XHRcdC8vIHZpYSBhbiBvYmplY3QuXG5cdFx0XHRcdHZhbCA9IG5vZGVbIGkgXSB8fCBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSggaSApO1xuXHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKCBpLCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cblxuXG5mdW5jdGlvbiB0b1R5cGUoIG9iaiApIHtcblx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0dHlwZW9mIG9iajtcbn1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyIHZlcnNpb24gPSBcIjMuNy4xXCIsXG5cblx0cmh0bWxTdWZmaXggPSAvSFRNTCQvaSxcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGV2ZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LmdyZXAoIHRoaXMsIGZ1bmN0aW9uKCBfZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAoIGkgKyAxICkgJSAyO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdG9kZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGkgJSAyO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBPYmplY3QucHJvdG90eXBlIHBvbGx1dGlvblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggbmFtZSA9PT0gXCJfX3Byb3RvX19cIiB8fCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cdFx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cblx0XHRcdFx0XHQvLyBFbnN1cmUgcHJvcGVyIHR5cGUgZm9yIHRoZSBzb3VyY2UgdmFsdWVcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICYmICFBcnJheS5pc0FycmF5KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0gW107XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggIWNvcHlJc0FycmF5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHt9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBwcm92aWRlZCBjb250ZXh0OyBmYWxscyBiYWNrIHRvIHRoZSBnbG9iYWwgb25lXG5cdC8vIGlmIG5vdCBzcGVjaWZpZWQuXG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlLCBvcHRpb25zLCBkb2MgKSB7XG5cdFx0RE9NRXZhbCggY29kZSwgeyBub25jZTogb3B0aW9ucyAmJiBvcHRpb25zLm5vbmNlIH0sIGRvYyApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblxuXHQvLyBSZXRyaWV2ZSB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcblx0dGV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5vZGUsXG5cdFx0XHRyZXQgPSBcIlwiLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHRpZiAoICFub2RlVHlwZSApIHtcblxuXHRcdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHRcdHdoaWxlICggKCBub2RlID0gZWxlbVsgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0XHRyZXQgKz0galF1ZXJ5LnRleHQoIG5vZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9XG5cdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRvY3VtZW50RWxlbWVudC50ZXh0Q29udGVudDtcblx0XHR9XG5cdFx0aWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0XHR9XG5cblx0XHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdGlzWE1MRG9jOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZXNwYWNlID0gZWxlbSAmJiBlbGVtLm5hbWVzcGFjZVVSSSxcblx0XHRcdGRvY0VsZW0gPSBlbGVtICYmICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGVcblx0XHQvLyBkb2N1bWVudCBmcmFnbWVudHMuXG5cdFx0cmV0dXJuICFyaHRtbFN1ZmZpeC50ZXN0KCBuYW1lc3BhY2UgfHwgZG9jRWxlbSAmJiBkb2NFbGVtLm5vZGVOYW1lIHx8IFwiSFRNTFwiICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gZmxhdCggcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0XHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0gdG9UeXBlKCBvYmogKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cblx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn1cbnZhciBwb3AgPSBhcnIucG9wO1xuXG5cbnZhciBzb3J0ID0gYXJyLnNvcnQ7XG5cblxudmFyIHNwbGljZSA9IGFyci5zcGxpY2U7XG5cblxudmFyIHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCI7XG5cblxudmFyIHJ0cmltQ1NTID0gbmV3IFJlZ0V4cChcblx0XCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIixcblx0XCJnXCJcbik7XG5cblxuXG5cbi8vIE5vdGU6IGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcbmpRdWVyeS5jb250YWlucyA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHR2YXIgYnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cblx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErXG5cdFx0Ly8gSUUgZG9lc24ndCBoYXZlIGBjb250YWluc2Agb24gU1ZHLlxuXHRcdGEuY29udGFpbnMgP1xuXHRcdFx0YS5jb250YWlucyggYnVwICkgOlxuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdCkgKTtcbn07XG5cblxuXG5cbi8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG4vLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcbnZhciByY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFx4ODAtXFx1RkZGRlxcdy1dL2c7XG5cbmZ1bmN0aW9uIGZjc3Nlc2NhcGUoIGNoLCBhc0NvZGVQb2ludCApIHtcblx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHR9XG5cblx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcbn1cblxualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuICggc2VsICsgXCJcIiApLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblxuXG5cbnZhciBwcmVmZXJyZWREb2MgPSBkb2N1bWVudCxcblx0cHVzaE5hdGl2ZSA9IHB1c2g7XG5cbiggZnVuY3Rpb24oKSB7XG5cbnZhciBpLFxuXHRFeHByLFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblx0cHVzaCA9IHB1c2hOYXRpdmUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRkb2N1bWVudCxcblx0ZG9jdW1lbnRFbGVtZW50LFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRtYXRjaGVzLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvLFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfFwiICtcblx0XHRcImxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jaWRlbnQtdG9rZW4tZGlhZ3JhbVxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCI/fFxcXFxcXFxcW15cXFxcclxcXFxuXFxcXGZdfFtcXFxcdy1dfFteXFwwLVxcXFx4N2ZdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwczovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgK1xuXHRcdHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblxuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblxuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRybGVhZGluZ0NvbWJpbmF0b3IgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgK1xuXHRcdHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyZGVzY2VuZCA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcInw+XCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdElEOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0Q0xBU1M6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0VEFHOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0QVRUUjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0UFNFVURPOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRDSElMRDogbmV3IFJlZ0V4cChcblx0XHRcdFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArXG5cdFx0XHRcdHdoaXRlc3BhY2UgKyBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArXG5cdFx0XHRcdHdoaXRlc3BhY2UgKyBcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRib29sOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdG5lZWRzQ29udGV4dDogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiP3xcXFxcXFxcXChbXlxcXFxyXFxcXG5cXFxcZl0pXCIsIFwiZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBlc2NhcGUsIG5vbkhleCApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZS5zbGljZSggMSApIC0gMHgxMDAwMDtcblxuXHRcdGlmICggbm9uSGV4ICkge1xuXG5cdFx0XHQvLyBTdHJpcCB0aGUgYmFja3NsYXNoIHByZWZpeCBmcm9tIGEgbm9uLWhleCBlc2NhcGUgc2VxdWVuY2Vcblx0XHRcdHJldHVybiBub25IZXg7XG5cdFx0fVxuXG5cdFx0Ly8gUmVwbGFjZSBhIGhleGFkZWNpbWFsIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbmNvZGVkIFVuaWNvZGUgY29kZSBwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTErXG5cdFx0Ly8gRm9yIHZhbHVlcyBvdXRzaWRlIHRoZSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmUgKEJNUCksIG1hbnVhbGx5IGNvbnN0cnVjdCBhXG5cdFx0Ly8gc3Vycm9nYXRlIHBhaXJcblx0XHRyZXR1cm4gaGlnaCA8IDAgP1xuXHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzOyBzZWUgYHNldERvY3VtZW50YC5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUUvRWRnZS5cblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0aW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIG5vZGVOYW1lKCBlbGVtLCBcImZpZWxkc2V0XCIgKTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBBY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gdGhyb3cgdW5leHBlY3RlZGx5XG4vLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzOTNcbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdCggYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSApLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0ge1xuXHRcdGFwcGx5OiBmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoTmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoIGVscyApICk7XG5cdFx0fSxcblx0XHRjYWxsOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdFx0cHVzaE5hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKSApO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gZmluZCggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmICggbWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoICggbSA9IG1hdGNoWyAxIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHVzaC5jYWxsKCByZXN1bHRzLCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKCBlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgJiZcblx0XHRcdFx0XHRcdFx0ZmluZC5jb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cHVzaC5jYWxsKCByZXN1bHRzLCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWyAyIF0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggbSA9IG1hdGNoWyAzIF0gKSAmJiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoICFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCAhcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXG5cdFx0XHRcdC8vIHFTQSBjb25zaWRlcnMgZWxlbWVudHMgb3V0c2lkZSBhIHNjb3Bpbmcgcm9vdCB3aGVuIGV2YWx1YXRpbmcgY2hpbGQgb3Jcblx0XHRcdFx0Ly8gZGVzY2VuZGFudCBjb21iaW5hdG9ycywgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudC5cblx0XHRcdFx0Ly8gSW4gc3VjaCBjYXNlcywgd2Ugd29yayBhcm91bmQgdGhlIGJlaGF2aW9yIGJ5IHByZWZpeGluZyBldmVyeSBzZWxlY3RvciBpbiB0aGVcblx0XHRcdFx0Ly8gbGlzdCB3aXRoIGFuIElEIHNlbGVjdG9yIHJlZmVyZW5jaW5nIHRoZSBzY29wZSBjb250ZXh0LlxuXHRcdFx0XHQvLyBUaGUgdGVjaG5pcXVlIGhhcyB0byBiZSB1c2VkIGFzIHdlbGwgd2hlbiBhIGxlYWRpbmcgY29tYmluYXRvciBpcyB1c2VkXG5cdFx0XHRcdC8vIGFzIHN1Y2ggc2VsZWN0b3JzIGFyZSBub3QgcmVjb2duaXplZCBieSBxdWVyeVNlbGVjdG9yQWxsLlxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB0ZWNobmlxdWUuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIHJkZXNjZW5kLnRlc3QoIHNlbGVjdG9yICkgfHwgcmxlYWRpbmdDb21iaW5hdG9yLnRlc3QoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblxuXHRcdFx0XHRcdC8vIFdlIGNhbiB1c2UgOnNjb3BlIGluc3RlYWQgb2YgdGhlIElEIGhhY2sgaWYgdGhlIGJyb3dzZXJcblx0XHRcdFx0XHQvLyBzdXBwb3J0cyBpdCAmIGlmIHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGUgY29udGV4dC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuXG5cdFx0XHRcdFx0Ly8gc3RyaWN0LWNvbXBhcmluZyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAhPSBjb250ZXh0IHx8ICFzdXBwb3J0LnNjb3BlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFx0aWYgKCAoIG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSApICkge1xuXHRcdFx0XHRcdFx0XHRuaWQgPSBqUXVlcnkuZXNjYXBlU2VsZWN0b3IoIG5pZCApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKCBuaWQgPSBleHBhbmRvICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1sgaSBdID0gKCBuaWQgPyBcIiNcIiArIG5pZCA6IFwiOnNjb3BlXCIgKSArIFwiIFwiICtcblx0XHRcdFx0XHRcdFx0dG9TZWxlY3RvciggZ3JvdXBzWyBpIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW1DU1MsIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzXG5cdFx0Ly8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9pc3N1ZXMvMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblxuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKCBjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlICk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgalF1ZXJ5IHNlbGVjdG9yIG1vZHVsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gbm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAoIG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSB8fCBub2RlTmFtZSggZWxlbSwgXCJidXR0b25cIiApICkgJiZcblx0XHRcdGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0aWYgKCBcImZvcm1cIiBpbiBlbGVtICkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuXHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcblx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMStcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdGluRGlzYWJsZWRGaWVsZHNldCggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuXHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKCBqID0gbWF0Y2hJbmRleGVzWyBpIF0gKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbIGogXSA9ICEoIG1hdGNoZXNbIGogXSA9IHNlZWRbIGogXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBqUXVlcnkgc2VsZWN0b3IgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtub2RlXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBzZXREb2N1bWVudCggbm9kZSApIHtcblx0dmFyIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCBkb2MgPT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWpRdWVyeS5pc1hNTERvYyggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBpT1MgNyBvbmx5LCBJRSA5IC0gMTErXG5cdC8vIE9sZGVyIGJyb3dzZXJzIGRpZG4ndCBzdXBwb3J0IHVucHJlZml4ZWQgYG1hdGNoZXNgLlxuXHRtYXRjaGVzID0gZG9jdW1lbnRFbGVtZW50Lm1hdGNoZXMgfHxcblx0XHRkb2N1bWVudEVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jdW1lbnRFbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzXG5cdC8vIChzZWUgdHJhYy0xMzkzNikuXG5cdC8vIExpbWl0IHRoZSBmaXggdG8gSUUgJiBFZGdlIExlZ2FjeTsgZGVzcGl0ZSBFZGdlIDE1KyBpbXBsZW1lbnRpbmcgYG1hdGNoZXNgLFxuXHQvLyBhbGwgSUUgOSsgYW5kIEVkZ2UgTGVnYWN5IHZlcnNpb25zIGltcGxlbWVudCBgbXNNYXRjaGVzU2VsZWN0b3JgIGFzIHdlbGwuXG5cdGlmICggZG9jdW1lbnRFbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yICYmXG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdHByZWZlcnJlZERvYyAhPSBkb2N1bWVudCAmJlxuXHRcdCggc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcgKSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXG5cdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBqUXVlcnkuZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8XG5cdFx0XHQhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGpRdWVyeS5leHBhbmRvICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlLlxuXHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0cmV0dXJuIG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXG5cdC8vIElFL0VkZ2UgZG9uJ3Qgc3VwcG9ydCB0aGUgOnNjb3BlIHBzZXVkby1jbGFzcy5cblx0c3VwcG9ydC5zY29wZSA9IGFzc2VydCggZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOnNjb3BlXCIgKTtcblx0fSApO1xuXG5cdC8vIFN1cHBvcnQ6IENocm9tZSAxMDUgLSAxMTEgb25seSwgU2FmYXJpIDE1LjQgLSAxNi4zIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRoZSBgOmhhcygpYCBhcmd1bWVudCBpcyBwYXJzZWQgdW5mb3JnaXZpbmdseS5cblx0Ly8gV2UgaW5jbHVkZSBgKmAgaW4gdGhlIHRlc3QgdG8gZGV0ZWN0IGJ1Z2d5IGltcGxlbWVudGF0aW9ucyB0aGF0IGFyZVxuXHQvLyBfc2VsZWN0aXZlbHlfIGZvcmdpdmluZyAoc3BlY2lmaWNhbGx5IHdoZW4gdGhlIGxpc3QgaW5jbHVkZXMgYXQgbGVhc3Rcblx0Ly8gb25lIHZhbGlkIHNlbGVjdG9yKS5cblx0Ly8gTm90ZSB0aGF0IHdlIHRyZWF0IGNvbXBsZXRlIGxhY2sgb2Ygc3VwcG9ydCBmb3IgYDpoYXMoKWAgYXMgaWYgaXQgd2VyZVxuXHQvLyBzcGVjLWNvbXBsaWFudCBzdXBwb3J0LCB3aGljaCBpcyBmaW5lIGJlY2F1c2UgdXNlIG9mIGA6aGFzKClgIGluIHN1Y2hcblx0Ly8gZW52aXJvbm1lbnRzIHdpbGwgZmFpbCBpbiB0aGUgcVNBIHBhdGggYW5kIGZhbGwgYmFjayB0byBqUXVlcnkgdHJhdmVyc2FsXG5cdC8vIGFueXdheS5cblx0c3VwcG9ydC5jc3NIYXMgPSBhc3NlcnQoIGZ1bmN0aW9uKCkge1xuXHRcdHRyeSB7XG5cdFx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBcIjpoYXMoKiw6anFmYWtlKVwiICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0gKTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXIuSUQgPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcImlkXCIgKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZC5JRCA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXIuSUQgPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0RXhwci5maW5kLklEID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1zWyBpKysgXSApICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmQuVEFHID0gZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdH1cblx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmQuQ0xBU1MgPSBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0cmJ1Z2d5UVNBID0gW107XG5cblx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0XHR2YXIgaW5wdXQ7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID1cblx0XHRcdFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJyBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgZGlzYWJsZWQ9J2Rpc2FibGVkJz5cIiArXG5cdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBpT1MgPD03IC0gOCBvbmx5XG5cdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseSBpbiBzb21lIFhNTCBkb2N1bWVudHNcblx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltzZWxlY3RlZF1cIiApLmxlbmd0aCApIHtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogaU9TIDw9NyAtIDggb25seVxuXHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJ+PVwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogaU9TIDggb25seVxuXHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIi4jLitbK35dXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0xMDUrLCBGaXJlZm94IDw9MTA0KywgU2FmYXJpIDw9MTUuNCtcblx0XHQvLyBJbiBzb21lIG9mIHRoZSBkb2N1bWVudCBraW5kcywgdGhlc2Ugc2VsZWN0b3JzIHdvdWxkbid0IHdvcmsgbmF0aXZlbHkuXG5cdFx0Ly8gVGhpcyBpcyBwcm9iYWJseSBPSyBidXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdlIHdhbnQgdG8gbWFpbnRhaW5cblx0XHQvLyBoYW5kbGluZyB0aGVtIHRocm91Z2ggalF1ZXJ5IHRyYXZlcnNhbCBpbiBqUXVlcnkgMy54LlxuXHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmNoZWNrZWRcIiApLmxlbmd0aCApIHtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjpjaGVja2VkXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExK1xuXHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTEwNSssIEZpcmVmb3ggPD0xMDQrLCBTYWZhcmkgPD0xNS40K1xuXHRcdC8vIEluIHNvbWUgb2YgdGhlIGRvY3VtZW50IGtpbmRzLCB0aGVzZSBzZWxlY3RvcnMgd291bGRuJ3Qgd29yayBuYXRpdmVseS5cblx0XHQvLyBUaGlzIGlzIHByb2JhYmx5IE9LIGJ1dCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2Ugd2FudCB0byBtYWludGFpblxuXHRcdC8vIGhhbmRsaW5nIHRoZW0gdGhyb3VnaCBqUXVlcnkgdHJhdmVyc2FsIGluIGpRdWVyeSAzLnguXG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmRpc2FibGVkXCIgKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUgMTEvRWRnZSBkb24ndCBmaW5kIGVsZW1lbnRzIG9uIGEgYFtuYW1lPScnXWAgcXVlcnkgaW4gc29tZSBjYXNlcy5cblx0XHQvLyBBZGRpbmcgYSB0ZW1wb3JhcnkgYXR0cmlidXRlIHRvIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIHNlbGVjdGlvbiB3b3Jrc1xuXHRcdC8vIGFyb3VuZCB0aGUgaXNzdWUuXG5cdFx0Ly8gSW50ZXJlc3RpbmdseSwgSUUgMTAgJiBvbGRlciBkb24ndCBzZWVtIHRvIGhhdmUgdGhlIGlzc3VlLlxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJcIiApO1xuXHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW25hbWU9JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIio9XCIgK1xuXHRcdFx0XHR3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHR9XG5cdH0gKTtcblxuXHRpZiAoICFzdXBwb3J0LmNzc0hhcyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSAxMDUgLSAxMTArLCBTYWZhcmkgMTUuNCAtIDE2LjMrXG5cdFx0Ly8gT3VyIHJlZ3VsYXIgYHRyeS1jYXRjaGAgbWVjaGFuaXNtIGZhaWxzIHRvIGRldGVjdCBuYXRpdmVseS11bnN1cHBvcnRlZFxuXHRcdC8vIHBzZXVkby1jbGFzc2VzIGluc2lkZSBgOmhhcygpYCAoc3VjaCBhcyBgOmhhcyg6Y29udGFpbnMoXCJGb29cIikpYClcblx0XHQvLyBpbiBicm93c2VycyB0aGF0IHBhcnNlIHRoZSBgOmhhcygpYCBhcmd1bWVudCBhcyBhIGZvcmdpdmluZyBzZWxlY3RvciBsaXN0LlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9zZWxlY3RvcnMvI3JlbGF0aW9uYWwgbm93IHJlcXVpcmVzIHRoZSBhcmd1bWVudFxuXHRcdC8vIHRvIGJlIHBhcnNlZCB1bmZvcmdpdmluZ2x5LCBidXQgYnJvd3NlcnMgaGF2ZSBub3QgeWV0IGZ1bGx5IGFkanVzdGVkLlxuXHRcdHJidWdneVFTQS5wdXNoKCBcIjpoYXNcIiApO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbiggXCJ8XCIgKSApO1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCggIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSApICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcblx0XHRcdFx0ZmluZC5jb250YWlucyggcHJlZmVycmVkRG9jLCBhICkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRmaW5kLmNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGIgKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mLmNhbGwoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZi5jYWxsKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufVxuXG5maW5kLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBmaW5kKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuZmluZC5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblxuXHRpZiAoIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggZXhwciwgdHJ1ZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmaW5kKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuZmluZC5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblxuZmluZC5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSB0cmFjLTEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0aWYgKCB2YWwgIT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG59O1xuXG5maW5kLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cbmpRdWVyeS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdC8vXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjArXG5cdC8vIFRlc3RpbmcgZm9yIGRldGVjdGluZyBkdXBsaWNhdGVzIGlzIHVucHJlZGljdGFibGUgc28gaW5zdGVhZCBhc3N1bWUgd2UgY2FuJ3Rcblx0Ly8gZGVwZW5kIG9uIGR1cGxpY2F0ZSBkZXRlY3Rpb24gaW4gYWxsIGJyb3dzZXJzIHdpdGhvdXQgYSBzdGFibGUgc29ydC5cblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuc29ydFN0YWJsZTtcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiBzbGljZS5jYWxsKCByZXN1bHRzLCAwICk7XG5cdHNvcnQuY2FsbCggcmVzdWx0cywgc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSByZXN1bHRzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRzcGxpY2UuY2FsbCggcmVzdWx0cywgZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG5qUXVlcnkuZm4udW5pcXVlU29ydCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS51bmlxdWVTb3J0KCBzbGljZS5hcHBseSggdGhpcyApICkgKTtcbn07XG5cbkV4cHIgPSBqUXVlcnkuZXhwciA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRBVFRSOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbIDMgXSA9ICggbWF0Y2hbIDMgXSB8fCBtYXRjaFsgNCBdIHx8IG1hdGNoWyA1IF0gfHwgXCJcIiApXG5cdFx0XHRcdC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAyIF0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbIDMgXSA9IFwiIFwiICsgbWF0Y2hbIDMgXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0Q0hJTEQ6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblxuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWyAxIF0gPSBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbIDEgXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdFx0ZmluZC5lcnJvciggbWF0Y2hbIDAgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbIDQgXSA9ICsoIG1hdGNoWyA0IF0gP1xuXHRcdFx0XHRcdG1hdGNoWyA1IF0gKyAoIG1hdGNoWyA2IF0gfHwgMSApIDpcblx0XHRcdFx0XHQyICogKCBtYXRjaFsgMyBdID09PSBcImV2ZW5cIiB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiIClcblx0XHRcdFx0KTtcblx0XHRcdFx0bWF0Y2hbIDUgXSA9ICsoICggbWF0Y2hbIDcgXSArIG1hdGNoWyA4IF0gKSB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0ZmluZC5lcnJvciggbWF0Y2hbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFBTRVVETzogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbIDYgXSAmJiBtYXRjaFsgMiBdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwci5DSElMRC50ZXN0KCBtYXRjaFsgMCBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gbWF0Y2hbIDQgXSB8fCBtYXRjaFsgNSBdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoIGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApICkgJiZcblxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KCBleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGggKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFsgMCBdID0gbWF0Y2hbIDAgXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWyAyIF0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0VEFHOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBleHBlY3RlZE5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlTmFtZSggZWxlbSwgZXhwZWN0ZWROb2RlTmFtZSApO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRDTEFTUzogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KCBwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArXG5cdFx0XHRcdFx0XCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApICkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KFxuXHRcdFx0XHRcdFx0dHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8XG5cdFx0XHRcdFx0XHRcdHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fFxuXHRcdFx0XHRcdFx0XHRcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRBVFRSOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwiPVwiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQgPT09IGNoZWNrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwiIT1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0ICE9PSBjaGVjaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcIl49XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwiKj1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcIiQ9XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9wZXJhdG9yID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApXG5cdFx0XHRcdFx0XHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3BlcmF0b3IgPT09IFwifD1cIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdENISUxEOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgX2FyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gbm9kZVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZU5hbWUoIG5vZGUsIG5hbWUgKSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IHBhcmVudFsgZXhwYW5kbyBdIHx8ICggcGFyZW50WyBleHBhbmRvIF0gPSB7fSApO1xuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IG91dGVyQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoIGRpZmYgPSBub2RlSW5kZXggPSAwICkgfHwgc3RhcnQucG9wKCkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKCBlbGVtWyBleHBhbmRvIF0gPSB7fSApO1xuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gb3V0ZXJDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlTmFtZSggbm9kZSwgbmFtZSApIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFBTRVVETzogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdGZpbmQuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBqUXVlcnkgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YuY2FsbCggc2VlZCwgbWF0Y2hlZFsgaSBdICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRub3Q6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltQ1NTLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaSBdID0gISggbWF0Y2hlc1sgaSBdID0gZWxlbSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvaXNzdWVzLzI5OSlcblx0XHRcdFx0XHRpbnB1dFsgMCBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0aGFzOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGZpbmQoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Y29udGFpbnM6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGpRdWVyeS50ZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0bGFuZzogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblxuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdCggbGFuZyB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdGZpbmQuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKCBlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggXCJ4bWw6bGFuZ1wiICkgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoIFwibGFuZ1wiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoICggZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSApICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0dGFyZ2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRyb290OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSxcblxuXHRcdGZvY3VzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmXG5cdFx0XHRcdGRvY3VtZW50Lmhhc0ZvY3VzKCkgJiZcblx0XHRcdFx0ISEoIGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXggKTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0ZW5hYmxlZDogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0ZGlzYWJsZWQ6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRjaGVja2VkOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHJldHVybiAoIG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSAmJiAhIWVsZW0uY2hlY2tlZCApIHx8XG5cdFx0XHRcdCggbm9kZU5hbWUoIGVsZW0sIFwib3B0aW9uXCIgKSAmJiAhIWVsZW0uc2VsZWN0ZWQgKTtcblx0XHR9LFxuXG5cdFx0c2VsZWN0ZWQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExK1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG5cdFx0XHQvLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gdHJlYXQgdGhlIGRlZmF1bHQgb3B0aW9uIGFzXG5cdFx0XHQvLyBzZWxlY3RlZCB3aGVuIGluIGFuIG9wdGdyb3VwLlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdGVtcHR5OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zLmVtcHR5KCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRoZWFkZXI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRpbnB1dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdGJ1dHRvbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fFxuXHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJidXR0b25cIiApO1xuXHRcdH0sXG5cblx0XHR0ZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSAmJiBlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDEwIG9ubHlcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhclxuXHRcdFx0XHQvLyB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSApID09IG51bGwgfHxcblx0XHRcdFx0XHRhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRmaXJzdDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSApLFxuXG5cdFx0bGFzdDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9ICksXG5cblx0XHRlcTogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSApLFxuXG5cdFx0ZXZlbjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdG9kZDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdGx0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGk7XG5cblx0XHRcdGlmICggYXJndW1lbnQgPCAwICkge1xuXHRcdFx0XHRpID0gYXJndW1lbnQgKyBsZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKCBhcmd1bWVudCA+IGxlbmd0aCApIHtcblx0XHRcdFx0aSA9IGxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGkgPSBhcmd1bWVudDtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdGd0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9IClcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zLm50aCA9IEV4cHIucHNldWRvcy5lcTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG5mdW5jdGlvbiB0b2tlbml6ZSggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8ICggbWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFsgMCBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICggdG9rZW5zID0gW10gKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAoIG1hdGNoID0gcmxlYWRpbmdDb21iaW5hdG9yLmV4ZWMoIHNvRmFyICkgKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goIHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWyAwIF0ucmVwbGFjZSggcnRyaW1DU1MsIFwiIFwiIClcblx0XHRcdH0gKTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoICggbWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApICkgJiYgKCAhcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdCggbWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkgKSApICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goIHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0aWYgKCBwYXJzZU9ubHkgKSB7XG5cdFx0cmV0dXJuIHNvRmFyLmxlbmd0aDtcblx0fVxuXG5cdHJldHVybiBzb0ZhciA/XG5cdFx0ZmluZC5lcnJvciggc2VsZWN0b3IgKSA6XG5cblx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbIGkgXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8ICggZWxlbVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIG5vZGVOYW1lKCBlbGVtLCBza2lwICkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKCBvbGRDYWNoZSA9IG91dGVyQ2FjaGVbIGtleSBdICkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKCBuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKCBuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1sgaSBdKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWyAwIF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0ZmluZCggc2VsZWN0b3IsIGNvbnRleHRzWyBpIF0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoICggZWxlbSA9IHVubWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSwgbWF0Y2hlck91dCxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fFxuXHRcdFx0XHRtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIixcblx0XHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zO1xuXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlclxuXHRcdFx0Ly8gb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdG1hdGNoZXJPdXQgPSBwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFtdIDpcblxuXHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0cmVzdWx0cztcblxuXHRcdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVySW47XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoIGVsZW0gPSB0ZW1wWyBpIF0gKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwWyBpIF0gXSA9ICEoIG1hdGNoZXJJblsgcG9zdE1hcFsgaSBdIF0gPSBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goICggbWF0Y2hlckluWyBpIF0gPSBlbGVtICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKCBtYXRjaGVyT3V0ID0gW10gKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gbWF0Y2hlck91dFsgaSBdICkgJiZcblx0XHRcdFx0XHRcdCggdGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mLmNhbGwoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFsgaSBdICkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFsgdGVtcCBdID0gISggcmVzdWx0c1sgdGVtcCBdID0gZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgMCBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbIFwiIFwiIF0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoIGNoZWNrQ29udGV4dCA9IGNvbnRleHQgKS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudFxuXHRcdFx0Ly8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9pc3N1ZXMvMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBpIF0udHlwZSBdICkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvciggZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIgKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1sgaSBdLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zWyBpIF0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBqIF0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxIClcblx0XHRcdFx0XHRcdFx0LmNvbmNhdCggeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0gKVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW1DU1MsIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKCB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZC5UQUcoIFwiKlwiLCBvdXRlcm1vc3QgKSxcblxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKCBkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSApLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogaU9TIDw9NyAtIDkgb25seVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nXG5cdFx0XHQvLyBlbGVtZW50cyBieSBpZC4gKHNlZSB0cmFjLTE0MTQyKVxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHB1c2guY2FsbCggcmVzdWx0cywgZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtICkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBzZXRNYXRjaGVyc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEoIHVubWF0Y2hlZFsgaSBdIHx8IHNldE1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbIGkgXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbIGkgXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsXG5cdFx0XHRtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn1cblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIGpRdWVyeSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggalF1ZXJ5IHNlbGVjdG9yIGNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5mdW5jdGlvbiBzZWxlY3QoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoICggc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvciApICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICggdG9rZW4gPSB0b2tlbnNbIDAgXSApLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgMSBdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kLklEKFxuXHRcdFx0XHR0b2tlbi5tYXRjaGVzWyAwIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0Y29udGV4dFxuXHRcdFx0KSB8fCBbXSApWyAwIF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1sgaSBdO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICggdHlwZSA9IHRva2VuLnR5cGUgKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKCBmaW5kID0gRXhwci5maW5kWyB0eXBlIF0gKSApIHtcblxuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoIHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbIDAgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1sgMCBdLnR5cGUgKSAmJlxuXHRcdFx0XHRcdFx0dGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSApICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCAtIDQuMStcbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KCBcIlwiICkuc29ydCggc29ydE9yZGVyICkuam9pbiggXCJcIiApID09PSBleHBhbmRvO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgLSA0LjErXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJmaWVsZHNldFwiICkgKSAmIDE7XG59ICk7XG5cbmpRdWVyeS5maW5kID0gZmluZDtcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZSA9IGpRdWVyeS51bmlxdWVTb3J0O1xuXG4vLyBUaGVzZSBoYXZlIGFsd2F5cyBiZWVuIHByaXZhdGUsIGJ1dCB0aGV5IHVzZWQgdG8gYmUgZG9jdW1lbnRlZCBhcyBwYXJ0IG9mXG4vLyBTaXp6bGUgc28gbGV0J3MgbWFpbnRhaW4gdGhlbSBmb3Igbm93IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBwdXJwb3Nlcy5cbmZpbmQuY29tcGlsZSA9IGNvbXBpbGU7XG5maW5kLnNlbGVjdCA9IHNlbGVjdDtcbmZpbmQuc2V0RG9jdW1lbnQgPSBzZXREb2N1bWVudDtcbmZpbmQudG9rZW5pemUgPSB0b2tlbml6ZTtcblxuZmluZC5lc2NhcGUgPSBqUXVlcnkuZXNjYXBlU2VsZWN0b3I7XG5maW5kLmdldFRleHQgPSBqUXVlcnkudGV4dDtcbmZpbmQuaXNYTUwgPSBqUXVlcnkuaXNYTUxEb2M7XG5maW5kLnNlbGVjdG9ycyA9IGpRdWVyeS5leHByO1xuZmluZC5zdXBwb3J0ID0galF1ZXJ5LnN1cHBvcnQ7XG5maW5kLnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlU29ydDtcblxuXHQvKiBlc2xpbnQtZW5hYmxlICovXG5cbn0gKSgpO1xuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbmdsZSBlbGVtZW50XG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBGaWx0ZXJlZCBkaXJlY3RseSBmb3IgYm90aCBzaW1wbGUgYW5kIGNvbXBsZXggc2VsZWN0b3JzXG5cdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICh0cmFjLTk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICh0cmFjLTExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBqUXVlcnkjZmluZFxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIGVsZW0uY29udGVudERvY3VtZW50ICE9IG51bGwgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErXG5cdFx0XHQvLyA8b2JqZWN0PiBlbGVtZW50cyB3aXRoIG5vIGBkYXRhYCBhdHRyaWJ1dGUgaGFzIGFuIG9iamVjdFxuXHRcdFx0Ly8gYGNvbnRlbnREb2N1bWVudGAgd2l0aCBhIGBudWxsYCBwcm90b3R5cGUuXG5cdFx0XHRnZXRQcm90byggZWxlbS5jb250ZW50RG9jdW1lbnQgKSApIHtcblxuXHRcdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuXHRcdC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuXHRcdC8vIGRvbid0IHN1cHBvcnQgaXQuXG5cdFx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG5cdFx0XHRlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuXHRcdFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxuXHRcdFx0Ly8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcblx0XHRcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBfaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLmVycm9yICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIGVycm9yLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldEVycm9ySG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MuZXJyb3IgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0RXJyb3JIb29rKCk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgZGVwcmVjYXRlZCBhbGlhcyBvZiB0aGUgYWJvdmUuIFdoaWxlIHRoZSBuYW1lIHN1Z2dlc3RzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gcmV0dXJuaW5nIHRoZSBzdGFjaywgbm90IGFuIGVycm9yIGluc3RhbmNlLCBqUXVlcnkganVzdCBwYXNzZXNcblx0XHRcdFx0XHRcdFx0XHQvLyBpdCBkaXJlY3RseSB0byBgY29uc29sZS53YXJuYCBzbyBib3RoIHdpbGwgd29yazsgYW4gaW5zdGFuY2Vcblx0XHRcdFx0XHRcdFx0XHQvLyBqdXN0IGJldHRlciBjb29wZXJhdGVzIHdpdGggc291cmNlIG1hcHMuXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MuZXJyb3IgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDMgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2ssXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgcHJpbWFyeSBEZWZlcnJlZFxuXHRcdFx0cHJpbWFyeSA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRwcmltYXJ5LnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBwcmltYXJ5LmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIHByaW1hcnkucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggcHJpbWFyeS5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRpc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gcHJpbWFyeS50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBwcmltYXJ5LnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBwcmltYXJ5LnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxuLy8gSWYgYGpRdWVyeS5EZWZlcnJlZC5nZXRFcnJvckhvb2tgIGlzIGRlZmluZWQsIGBhc3luY0Vycm9yYCBpcyBhbiBlcnJvclxuLy8gY2FwdHVyZWQgYmVmb3JlIHRoZSBhc3luYyBiYXJyaWVyIHRvIGdldCB0aGUgb3JpZ2luYWwgZXJyb3IgY2F1c2Vcbi8vIHdoaWNoIG1heSBvdGhlcndpc2UgYmUgaGlkZGVuLlxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIGFzeW5jRXJyb3IgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLFxuXHRcdFx0ZXJyb3Iuc3RhY2ssIGFzeW5jRXJyb3IgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlIHRyYWMtNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIHRvVHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwgX2tleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggX2FsbCwgbGV0dGVyICkge1xuXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICh0cmFjLTk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSB0cmFjLTgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBjYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICh0cmFjLTE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuXHR2YXIgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cdFx0fSxcblx0XHRjb21wb3NlZCA9IHsgY29tcG9zZWQ6IHRydWUgfTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBpT1MgMTAuMCAtIDEwLjIgb25seVxuXHQvLyBDaGVjayBhdHRhY2htZW50IGFjcm9zcyBzaGFkb3cgRE9NIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAoZ2gtMzUwNClcblx0Ly8gU3VwcG9ydDogaU9TIDEwLjAtMTAuMiBvbmx5XG5cdC8vIEVhcmx5IGlPUyAxMCB2ZXJzaW9ucyBzdXBwb3J0IGBhdHRhY2hTaGFkb3dgIGJ1dCBub3QgYGdldFJvb3ROb2RlYCxcblx0Ly8gbGVhZGluZyB0byBlcnJvcnMuIFdlIG5lZWQgdG8gY2hlY2sgZm9yIGBnZXRSb290Tm9kZWAuXG5cdGlmICggZG9jdW1lbnRFbGVtZW50LmdldFJvb3ROb2RlICkge1xuXHRcdGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Um9vdE5vZGUoIGNvbXBvc2VkICkgPT09IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHR9O1xuXHR9XG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0aXNBdHRhY2hlZCggZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICh0cmFjLTExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAodHJhYy0xNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdC8vIElFIDw9OSByZXBsYWNlcyA8b3B0aW9uPiB0YWdzIHdpdGggdGhlaXIgY29udGVudHMgd2hlbiBpbnNlcnRlZCBvdXRzaWRlIG9mXG5cdC8vIHRoZSBzZWxlY3QgZWxlbWVudC5cblx0ZGl2LmlubmVySFRNTCA9IFwiPG9wdGlvbj48L29wdGlvbj5cIjtcblx0c3VwcG9ydC5vcHRpb24gPSAhIWRpdi5sYXN0Q2hpbGQ7XG59ICkoKTtcblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAodHJhYy0xMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuaWYgKCAhc3VwcG9ydC5vcHRpb24gKSB7XG5cdHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbiA9IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXTtcbn1cblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKHRyYWMtMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgYXR0YWNoZWQsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICh0cmFjLTEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRhdHRhY2hlZCA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggYXR0YWNoZWQgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbnZhciBydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIE9ubHkgYXR0YWNoIGV2ZW50cyB0byBvYmplY3RzIHRoYXQgYWNjZXB0IGRhdGFcblx0XHRpZiAoICFhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApO1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXG5cdFx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKSxcblxuXHRcdFx0aGFuZGxlcnMgPSAoXG5cdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0KVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGV2ZW50IGlzIG5hbWVzcGFjZWQsIHRoZW4gZWFjaCBoYW5kbGVyIGlzIG9ubHkgaW52b2tlZCBpZiBpdCBpc1xuXHRcdFx0XHQvLyBzcGVjaWFsbHkgdW5pdmVyc2FsIG9yIGl0cyBuYW1lc3BhY2VzIGFyZSBhIHN1cGVyc2V0IG9mIHRoZSBldmVudCdzLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGhhbmRsZU9iai5uYW1lc3BhY2UgPT09IGZhbHNlIHx8XG5cdFx0XHRcdFx0ZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAodHJhYy0xMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKHRyYWMtNjkxMSwgdHJhYy04MTY1LCB0cmFjLTExMzgyLCB0cmFjLTExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKHRyYWMtMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgdG8gZW5zdXJlIGNvcnJlY3Qgc3RhdGUgZm9yIGNoZWNrYWJsZSBpbnB1dHNcblx0XHRcdHNldHVwOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdC8vIGRhdGFQcml2LnNldCggZWwsIFwiY2xpY2tcIiwgLi4uIClcblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJpbmcgYSBjbGlja1xuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBzdXBwcmVzcyBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdC8vIEFsc28gcHJldmVudCBpdCBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGEgbGV2ZXJhZ2VkIG5hdGl2ZS1ldmVudCBzdGFja1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdFx0cmV0dXJuIHJjaGVja2FibGVUeXBlLnRlc3QoIHRhcmdldC50eXBlICkgJiZcblx0XHRcdFx0XHR0YXJnZXQuY2xpY2sgJiYgbm9kZU5hbWUoIHRhcmdldCwgXCJpbnB1dFwiICkgJiZcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRhcmdldCwgXCJjbGlja1wiICkgfHxcblx0XHRcdFx0XHRub2RlTmFtZSggdGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIEVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBoYW5kbGVzIG1hbnVhbGx5LXRyaWdnZXJlZFxuLy8gc3ludGhldGljIGV2ZW50cyBieSBpbnRlcnJ1cHRpbmcgcHJvZ3Jlc3MgdW50aWwgcmVpbnZva2VkIGluIHJlc3BvbnNlIHRvXG4vLyAqbmF0aXZlKiBldmVudHMgdGhhdCBpdCBmaXJlcyBkaXJlY3RseSwgZW5zdXJpbmcgdGhhdCBzdGF0ZSBjaGFuZ2VzIGhhdmVcbi8vIGFscmVhZHkgb2NjdXJyZWQgYmVmb3JlIG90aGVyIGxpc3RlbmVycyBhcmUgaW52b2tlZC5cbmZ1bmN0aW9uIGxldmVyYWdlTmF0aXZlKCBlbCwgdHlwZSwgaXNTZXR1cCApIHtcblxuXHQvLyBNaXNzaW5nIGBpc1NldHVwYCBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWlzU2V0dXAgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXN1bHQsXG5cdFx0XHRcdHNhdmVkID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdGlmICggKCBldmVudC5pc1RyaWdnZXIgJiAxICkgJiYgdGhpc1sgdHlwZSBdICkge1xuXG5cdFx0XHRcdC8vIEludGVycnVwdCBwcm9jZXNzaW5nIG9mIHRoZSBvdXRlciBzeW50aGV0aWMgLnRyaWdnZXIoKWVkIGV2ZW50XG5cdFx0XHRcdGlmICggIXNhdmVkICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgYXJndW1lbnRzIGZvciB1c2Ugd2hlbiBoYW5kbGluZyB0aGUgaW5uZXIgbmF0aXZlIGV2ZW50XG5cdFx0XHRcdFx0Ly8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IChhbiBldmVudCBvYmplY3QpLCBzbyB0aGlzIGFycmF5XG5cdFx0XHRcdFx0Ly8gd2lsbCBub3QgYmUgY29uZnVzZWQgd2l0aCBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0LlxuXHRcdFx0XHRcdHNhdmVkID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBzYXZlZCApO1xuXG5cdFx0XHRcdFx0Ly8gVHJpZ2dlciB0aGUgbmF0aXZlIGV2ZW50IGFuZCBjYXB0dXJlIGl0cyByZXN1bHRcblx0XHRcdFx0XHR0aGlzWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRyZXN1bHQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIGZhbHNlICk7XG5cblx0XHRcdFx0XHRpZiAoIHNhdmVkICE9PSByZXN1bHQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhbmNlbCB0aGUgb3V0ZXIgc3ludGhldGljIGV2ZW50XG5cdFx0XHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IGZvciBhbiBldmVudCB3aXRoIGEgYnViYmxpbmcgc3Vycm9nYXRlXG5cdFx0XHRcdC8vIChmb2N1cyBvciBibHVyKSwgYXNzdW1lIHRoYXQgdGhlIHN1cnJvZ2F0ZSBhbHJlYWR5IHByb3BhZ2F0ZWQgZnJvbSB0cmlnZ2VyaW5nXG5cdFx0XHRcdC8vIHRoZSBuYXRpdmUgZXZlbnQgYW5kIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbmluZyBhZ2FpbiBoZXJlLlxuXHRcdFx0XHQvLyBUaGlzIHRlY2huaWNhbGx5IGdldHMgdGhlIG9yZGVyaW5nIHdyb25nIHcuci50LiB0byBgLnRyaWdnZXIoKWAgKGluIHdoaWNoIHRoZVxuXHRcdFx0XHQvLyBidWJibGluZyBzdXJyb2dhdGUgcHJvcGFnYXRlcyAqYWZ0ZXIqIHRoZSBub24tYnViYmxpbmcgYmFzZSksIGJ1dCB0aGF0IHNlZW1zXG5cdFx0XHRcdC8vIGxlc3MgYmFkIHRoYW4gZHVwbGljYXRpb24uXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fSApLmRlbGVnYXRlVHlwZSApIHtcblx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgbmF0aXZlIGV2ZW50IHRyaWdnZXJlZCBhYm92ZSwgZXZlcnl0aGluZyBpcyBub3cgaW4gb3JkZXJcblx0XHRcdC8vIEZpcmUgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IHdpdGggdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggc2F2ZWQgKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIGpRdWVyeS5ldmVudC50cmlnZ2VyKFxuXHRcdFx0XHRcdHNhdmVkWyAwIF0sXG5cdFx0XHRcdFx0c2F2ZWQuc2xpY2UoIDEgKSxcblx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdCkgKTtcblxuXHRcdFx0XHQvLyBBYm9ydCBoYW5kbGluZyBvZiB0aGUgbmF0aXZlIGV2ZW50IGJ5IGFsbCBqUXVlcnkgaGFuZGxlcnMgd2hpbGUgYWxsb3dpbmdcblx0XHRcdFx0Ly8gbmF0aXZlIGhhbmRsZXJzIG9uIHRoZSBzYW1lIGVsZW1lbnQgdG8gcnVuLiBPbiB0YXJnZXQsIHRoaXMgaXMgYWNoaWV2ZWRcblx0XHRcdFx0Ly8gYnkgc3RvcHBpbmcgaW1tZWRpYXRlIHByb3BhZ2F0aW9uIGp1c3Qgb24gdGhlIGpRdWVyeSBldmVudC4gSG93ZXZlcixcblx0XHRcdFx0Ly8gdGhlIG5hdGl2ZSBldmVudCBpcyByZS13cmFwcGVkIGJ5IGEgalF1ZXJ5IG9uZSBvbiBlYWNoIGxldmVsIG9mIHRoZVxuXHRcdFx0XHQvLyBwcm9wYWdhdGlvbiBzbyB0aGUgb25seSB3YXkgdG8gc3RvcCBpdCBmb3IgalF1ZXJ5IGlzIHRvIHN0b3AgaXQgZm9yXG5cdFx0XHRcdC8vIGV2ZXJ5b25lIHZpYSBuYXRpdmUgYHN0b3BQcm9wYWdhdGlvbigpYC4gVGhpcyBpcyBub3QgYSBwcm9ibGVtIGZvclxuXHRcdFx0XHQvLyBmb2N1cy9ibHVyIHdoaWNoIGRvbid0IGJ1YmJsZSwgYnV0IGl0IGRvZXMgYWxzbyBzdG9wIGNsaWNrIG9uIGNoZWNrYm94ZXNcblx0XHRcdFx0Ly8gYW5kIHJhZGlvcy4gV2UgYWNjZXB0IHRoaXMgbGltaXRhdGlvbi5cblx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICh0cmFjLTUwNCwgdHJhYy0xMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNvZGU6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXHR3aGljaDogdHJ1ZVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxualF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIHR5cGUsIGRlbGVnYXRlVHlwZSApIHtcblxuXHRmdW5jdGlvbiBmb2N1c01hcHBlZEhhbmRsZXIoIG5hdGl2ZUV2ZW50ICkge1xuXHRcdGlmICggZG9jdW1lbnQuZG9jdW1lbnRNb2RlICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMStcblx0XHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBmb2N1c2luL2ZvY3Vzb3V0IGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHNcblx0XHRcdC8vIGZvY3VzL2JsdXIuIFRoaXMgaXMgYmVjYXVzZSB0aGUgZm9ybWVyIGFyZSBzeW5jaHJvbm91cyBpbiBJRSB3aGlsZSB0aGUgbGF0dGVyXG5cdFx0XHQvLyBhcmUgYXN5bmMuIEluIG90aGVyIGJyb3dzZXJzLCBhbGwgdGhvc2UgaGFuZGxlcnMgYXJlIGludm9rZWQgc3luY2hyb25vdXNseS5cblxuXHRcdFx0Ly8gYGhhbmRsZWAgZnJvbSBwcml2YXRlIGRhdGEgd291bGQgYWxyZWFkeSB3cmFwIHRoZSBldmVudCwgYnV0IHdlIG5lZWRcblx0XHRcdC8vIHRvIGNoYW5nZSB0aGUgYHR5cGVgIGhlcmUuXG5cdFx0XHR2YXIgaGFuZGxlID0gZGF0YVByaXYuZ2V0KCB0aGlzLCBcImhhbmRsZVwiICksXG5cdFx0XHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblx0XHRcdGV2ZW50LnR5cGUgPSBuYXRpdmVFdmVudC50eXBlID09PSBcImZvY3VzaW5cIiA/IFwiZm9jdXNcIiA6IFwiYmx1clwiO1xuXHRcdFx0ZXZlbnQuaXNTaW11bGF0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBGaXJzdCwgaGFuZGxlIGZvY3VzaW4vZm9jdXNvdXRcblx0XHRcdGhhbmRsZSggbmF0aXZlRXZlbnQgKTtcblxuXHRcdFx0Ly8gLi4udGhlbiwgaGFuZGxlIGZvY3VzL2JsdXJcblx0XHRcdC8vXG5cdFx0XHQvLyBmb2N1cy9ibHVyIGRvbid0IGJ1YmJsZSB3aGlsZSBmb2N1c2luL2ZvY3Vzb3V0IGRvOyBzaW11bGF0ZSB0aGUgZm9ybWVyIGJ5IG9ubHlcblx0XHRcdC8vIGludm9raW5nIHRoZSBoYW5kbGVyIGF0IHRoZSBsb3dlciBsZXZlbC5cblx0XHRcdGlmICggZXZlbnQudGFyZ2V0ID09PSBldmVudC5jdXJyZW50VGFyZ2V0ICkge1xuXG5cdFx0XHRcdC8vIFRoZSBzZXR1cCBwYXJ0IGNhbGxzIGBsZXZlcmFnZU5hdGl2ZWAsIHdoaWNoLCBpbiB0dXJuLCBjYWxsc1xuXHRcdFx0XHQvLyBgalF1ZXJ5LmV2ZW50LmFkZGAsIHNvIGV2ZW50IGhhbmRsZSB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIHNldFxuXHRcdFx0XHQvLyBieSB0aGlzIHBvaW50LlxuXHRcdFx0XHRoYW5kbGUoIGV2ZW50ICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIG5vbi1JRSBicm93c2VycywgYXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudFxuXHRcdFx0Ly8gd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0LlxuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBkZWxlZ2F0ZVR5cGUsIG5hdGl2ZUV2ZW50LnRhcmdldCxcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKSApO1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gPSB7XG5cblx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdHZhciBhdHRhY2hlcztcblxuXHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJmb2N1c1wiLCAuLi4gKVxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImJsdXJcIiwgLi4uIClcblx0XHRcdGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlLCB0cnVlICk7XG5cblx0XHRcdGlmICggZG9jdW1lbnQuZG9jdW1lbnRNb2RlICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMStcblx0XHRcdFx0Ly8gV2UgdXNlIHRoZSBzYW1lIG5hdGl2ZSBoYW5kbGVyIGZvciBmb2N1c2luICYgZm9jdXMgKGFuZCBmb2N1c291dCAmIGJsdXIpXG5cdFx0XHRcdC8vIHNvIHdlIG5lZWQgdG8gY29vcmRpbmF0ZSBzZXR1cCAmIHRlYXJkb3duIHBhcnRzIGJldHdlZW4gdGhvc2UgZXZlbnRzLlxuXHRcdFx0XHQvLyBVc2UgYGRlbGVnYXRlVHlwZWAgYXMgdGhlIGtleSBhcyBgdHlwZWAgaXMgYWxyZWFkeSB1c2VkIGJ5IGBsZXZlcmFnZU5hdGl2ZWAuXG5cdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuZ2V0KCB0aGlzLCBkZWxlZ2F0ZVR5cGUgKTtcblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCBkZWxlZ2F0ZVR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgZGVsZWdhdGVUeXBlLCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSApO1xuXG5cdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGF0dGFjaGVzO1xuXG5cdFx0XHRpZiAoIGRvY3VtZW50LmRvY3VtZW50TW9kZSApIHtcblx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIGRlbGVnYXRlVHlwZSApIC0gMTtcblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCBkZWxlZ2F0ZVR5cGUsIGZvY3VzTWFwcGVkSGFuZGxlciApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggdGhpcywgZGVsZWdhdGVUeXBlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBkZWxlZ2F0ZVR5cGUsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGluZGljYXRlIHN0YW5kYXJkIHRlYXJkb3duIHNob3VsZCBiZSBhcHBsaWVkXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gU3VwcHJlc3MgbmF0aXZlIGZvY3VzIG9yIGJsdXIgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZVxuXHRcdC8vIGEgbGV2ZXJhZ2VkIG5hdGl2ZS1ldmVudCBzdGFja1xuXHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBldmVudC50YXJnZXQsIHR5cGUgKTtcblx0XHR9LFxuXG5cdFx0ZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcblx0fTtcblxuXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcblx0Ly8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuXHQvLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuXHQvL1xuXHQvLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcblx0Ly8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG5cdC8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuXHQvLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuXHQvL1xuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErXG5cdC8vIFRvIHByZXNlcnZlIHJlbGF0aXZlIGZvY3VzaW4vZm9jdXMgJiBmb2N1c291dC9ibHVyIGV2ZW50IG9yZGVyIGd1YXJhbnRlZWQgb24gdGhlIDMueCBicmFuY2gsXG5cdC8vIGF0dGFjaCBhIHNpbmdsZSBoYW5kbGVyIGZvciBib3RoIGV2ZW50cyBpbiBJRS5cblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGRlbGVnYXRlVHlwZSBdID0ge1xuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSGFuZGxlOiByZWd1bGFyIG5vZGVzICh2aWEgYHRoaXMub3duZXJEb2N1bWVudGApLCB3aW5kb3dcblx0XHRcdC8vICh2aWEgYHRoaXMuZG9jdW1lbnRgKSAmIGRvY3VtZW50ICh2aWEgYHRoaXNgKS5cblx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRkYXRhSG9sZGVyID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlID8gdGhpcyA6IGRvYyxcblx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5nZXQoIGRhdGFIb2xkZXIsIGRlbGVnYXRlVHlwZSApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErXG5cdFx0XHQvLyBXZSB1c2UgdGhlIHNhbWUgbmF0aXZlIGhhbmRsZXIgZm9yIGZvY3VzaW4gJiBmb2N1cyAoYW5kIGZvY3Vzb3V0ICYgYmx1cilcblx0XHRcdC8vIHNvIHdlIG5lZWQgdG8gY29vcmRpbmF0ZSBzZXR1cCAmIHRlYXJkb3duIHBhcnRzIGJldHdlZW4gdGhvc2UgZXZlbnRzLlxuXHRcdFx0Ly8gVXNlIGBkZWxlZ2F0ZVR5cGVgIGFzIHRoZSBrZXkgYXMgYHR5cGVgIGlzIGFscmVhZHkgdXNlZCBieSBgbGV2ZXJhZ2VOYXRpdmVgLlxuXHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdGlmICggZG9jdW1lbnQuZG9jdW1lbnRNb2RlICkge1xuXHRcdFx0XHRcdHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggZGVsZWdhdGVUeXBlLCBmb2N1c01hcHBlZEhhbmRsZXIgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGRhdGFQcml2LnNldCggZGF0YUhvbGRlciwgZGVsZWdhdGVUeXBlLCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHR9LFxuXHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRkYXRhSG9sZGVyID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlID8gdGhpcyA6IGRvYyxcblx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5nZXQoIGRhdGFIb2xkZXIsIGRlbGVnYXRlVHlwZSApIC0gMTtcblxuXHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdGlmICggZG9jdW1lbnQuZG9jdW1lbnRNb2RlICkge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggZGVsZWdhdGVUeXBlLCBmb2N1c01hcHBlZEhhbmRsZXIgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgZm9jdXNNYXBwZWRIYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkYXRhSG9sZGVyLCBkZWxlZ2F0ZVR5cGUgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFQcml2LnNldCggZGF0YUhvbGRlciwgZGVsZWdhdGVUeXBlLCBhdHRhY2hlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn0gKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCFcXFtDREFUQVxcW3xcXF1cXF0+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmdldCggc3JjICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRlc3QsIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBmbGF0KCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKHRyYWMtODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmUtZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgJiYgKCBub2RlLnR5cGUgfHwgXCJcIiApLnRvTG93ZXJDYXNlKCkgICE9PSBcIm1vZHVsZVwiICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICYmICFub2RlLm5vTW9kdWxlICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMsIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5vbmNlOiBub2RlLm5vbmNlIHx8IG5vZGUuZ2V0QXR0cmlidXRlKCBcIm5vbmNlXCIgKVxuXHRcdFx0XHRcdFx0XHRcdH0sIGRvYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFVud3JhcCBhIENEQVRBIHNlY3Rpb24gY29udGFpbmluZyBzY3JpcHQgY29udGVudHMuIFRoaXMgc2hvdWxkbid0IGJlXG5cdFx0XHRcdFx0XHRcdC8vIG5lZWRlZCBhcyBpbiBYTUwgZG9jdW1lbnRzIHRoZXkncmUgYWxyZWFkeSBub3QgdmlzaWJsZSB3aGVuXG5cdFx0XHRcdFx0XHRcdC8vIGluc3BlY3RpbmcgZWxlbWVudCBjb250ZW50cyBhbmQgaW4gSFRNTCBkb2N1bWVudHMgdGhleSBoYXZlIG5vXG5cdFx0XHRcdFx0XHRcdC8vIG1lYW5pbmcgYnV0IHdlJ3JlIHByZXNlcnZpbmcgdGhhdCBsb2dpYyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgd2lsbCBiZSByZW1vdmVkIGNvbXBsZXRlbHkgaW4gNC4wLiBTZWUgZ2gtNDkwNC5cblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgbm9kZSwgZG9jICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBpc0F0dGFjaGVkKCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBqUXVlcnkjZmluZCBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOlxuXHRcdFx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgcmN1c3RvbVByb3AgPSAvXi0tLztcblxuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAodHJhYy0xNTA5OCwgdHJhYy0xNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suY2FsbCggZWxlbSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG52YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cCggY3NzRXhwYW5kLmpvaW4oIFwifFwiICksIFwiaVwiICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXG5cdFx0XHRcIm1hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFwiO1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcIndpZHRoOjYwJTt0b3A6MSVcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5tYXJnaW5MZWZ0ICkgPT09IDEyO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLnJpZ2h0ID0gXCI2MCVcIjtcblx0XHRwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHRcdC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUud2lkdGggKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHQvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9NjRcblx0XHQvLyBEb24ndCBnZXQgdHJpY2tlZCB3aGVuIHpvb20gYWZmZWN0cyBvZmZzZXRXaWR0aCAoZ2gtNDAyOSlcblx0XHRkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0c2Nyb2xsYm94U2l6ZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2Lm9mZnNldFdpZHRoIC8gMyApID09PSAxMjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiByb3VuZFBpeGVsTWVhc3VyZXMoIG1lYXN1cmUgKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIHBhcnNlRmxvYXQoIG1lYXN1cmUgKSApO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcblx0XHRyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKHRyYWMtODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fSxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEJlaGF2aW9yIGluIElFIDkgaXMgbW9yZSBzdWJ0bGUgdGhhbiBpbiBuZXdlciB2ZXJzaW9ucyAmIGl0IHBhc3Nlc1xuXHRcdC8vIHNvbWUgdmVyc2lvbnMgb2YgdGhpcyB0ZXN0OyBtYWtlIHN1cmUgbm90IHRvIG1ha2UgaXQgcGFzcyB0aGVyZSFcblx0XHQvL1xuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNzArXG5cdFx0Ly8gT25seSBGaXJlZm94IGluY2x1ZGVzIGJvcmRlciB3aWR0aHNcblx0XHQvLyBpbiBjb21wdXRlZCBkaW1lbnNpb25zLiAoZ2gtNDUyOSlcblx0XHRyZWxpYWJsZVRyRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGFibGUsIHRyLCB0ckNoaWxkLCB0clN0eWxlO1xuXHRcdFx0aWYgKCByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidGFibGVcIiApO1xuXHRcdFx0XHR0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidHJcIiApO1xuXHRcdFx0XHR0ckNoaWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdFx0XHRcdHRhYmxlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7Ym9yZGVyLWNvbGxhcHNlOnNlcGFyYXRlXCI7XG5cdFx0XHRcdHRyLnN0eWxlLmNzc1RleHQgPSBcImJveC1zaXppbmc6Y29udGVudC1ib3g7Ym9yZGVyOjFweCBzb2xpZFwiO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA4Nitcblx0XHRcdFx0Ly8gSGVpZ2h0IHNldCB0aHJvdWdoIGNzc1RleHQgZG9lcyBub3QgZ2V0IGFwcGxpZWQuXG5cdFx0XHRcdC8vIENvbXB1dGVkIGhlaWdodCB0aGVuIGNvbWVzIGJhY2sgYXMgMC5cblx0XHRcdFx0dHIuc3R5bGUuaGVpZ2h0ID0gXCIxcHhcIjtcblx0XHRcdFx0dHJDaGlsZC5zdHlsZS5oZWlnaHQgPSBcIjlweFwiO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgOCBDaHJvbWUgODYrXG5cdFx0XHRcdC8vIEluIG91ciBib2R5QmFja2dyb3VuZC5odG1sIGlmcmFtZSxcblx0XHRcdFx0Ly8gZGlzcGxheSBmb3IgYWxsIGRpdiBlbGVtZW50cyBpcyBzZXQgdG8gXCJpbmxpbmVcIixcblx0XHRcdFx0Ly8gd2hpY2ggY2F1c2VzIGEgcHJvYmxlbSBvbmx5IGluIEFuZHJvaWQgOCBDaHJvbWUgODYuXG5cdFx0XHRcdC8vIEVuc3VyaW5nIHRoZSBkaXYgaXMgYGRpc3BsYXk6IGJsb2NrYFxuXHRcdFx0XHQvLyBnZXRzIGFyb3VuZCB0aGlzIGlzc3VlLlxuXHRcdFx0XHR0ckNoaWxkLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cblx0XHRcdFx0ZG9jdW1lbnRFbGVtZW50XG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0YWJsZSApXG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0ciApXG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0ckNoaWxkICk7XG5cblx0XHRcdFx0dHJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCB0ciApO1xuXHRcdFx0XHRyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9ICggcGFyc2VJbnQoIHRyU3R5bGUuaGVpZ2h0LCAxMCApICtcblx0XHRcdFx0XHRwYXJzZUludCggdHJTdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTAgKSArXG5cdFx0XHRcdFx0cGFyc2VJbnQoIHRyU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgsIDEwICkgKSA9PT0gdHIub2Zmc2V0SGVpZ2h0O1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggdGFibGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksIHRyYWMtMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKGdoLTMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHQvLyBJRSBvbmx5IHN1cHBvcnRzIGBcImZsb2F0XCJgIGluIGBnZXRQcm9wZXJ0eVZhbHVlYDsgaW4gY29tcHV0ZWQgc3R5bGVzXG5cdFx0Ly8gaXQncyBvbmx5IGF2YWlsYWJsZSBhcyBgXCJjc3NGbG9hdFwiYC4gV2Ugbm8gbG9uZ2VyIG1vZGlmeSBwcm9wZXJ0aWVzXG5cdFx0Ly8gc2VudCB0byBgLmNzcygpYCBhcGFydCBmcm9tIGNhbWVsQ2FzaW5nLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGJvdGguXG5cdFx0Ly8gTm9ybWFsbHksIHRoaXMgd291bGQgY3JlYXRlIGRpZmZlcmVuY2UgaW4gYmVoYXZpb3I6IGlmXG5cdFx0Ly8gYGdldFByb3BlcnR5VmFsdWVgIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLCB0aGUgdmFsdWUgcmV0dXJuZWRcblx0XHQvLyBieSBgLmNzcygpYCB3b3VsZCBiZSBgdW5kZWZpbmVkYC4gVGhpcyBpcyB1c3VhbGx5IHRoZSBjYXNlIGZvclxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBlbGVtZW50cy4gSG93ZXZlciwgaW4gSUUgZXZlbiBkaXNjb25uZWN0ZWQgZWxlbWVudHNcblx0XHQvLyB3aXRoIG5vIHN0eWxlcyByZXR1cm4gYFwibm9uZVwiYCBmb3IgYGdldFByb3BlcnR5VmFsdWUoIFwiZmxvYXRcIiApYFxuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCBpc0N1c3RvbVByb3AgJiYgcmV0ICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDEwNSssIENocm9tZSA8PTEwNStcblx0XHRcdC8vIFNwZWMgcmVxdWlyZXMgdHJpbW1pbmcgd2hpdGVzcGFjZSBmb3IgY3VzdG9tIHByb3BlcnRpZXMgKGdoLTQ5MjYpLlxuXHRcdFx0Ly8gRmlyZWZveCBvbmx5IHRyaW1zIGxlYWRpbmcgd2hpdGVzcGFjZS4gQ2hyb21lIGp1c3QgY29sbGFwc2VzXG5cdFx0XHQvLyBib3RoIGxlYWRpbmcgJiB0cmFpbGluZyB3aGl0ZXNwYWNlIHRvIGEgc2luZ2xlIHNwYWNlLlxuXHRcdFx0Ly9cblx0XHRcdC8vIEZhbGwgYmFjayB0byBgdW5kZWZpbmVkYCBpZiBlbXB0eSBzdHJpbmcgcmV0dXJuZWQuXG5cdFx0XHQvLyBUaGlzIGNvbGxhcHNlcyBhIG1pc3NpbmcgZGVmaW5pdGlvbiB3aXRoIHByb3BlcnR5IGRlZmluZWRcblx0XHRcdC8vIGFuZCBzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIGJ1dCB0aGVyZSdzIG5vIHN0YW5kYXJkIEFQSVxuXHRcdFx0Ly8gYWxsb3dpbmcgdXMgdG8gZGlmZmVyZW50aWF0ZSB0aGVtIHdpdGhvdXQgYSBwZXJmb3JtYW5jZSBwZW5hbHR5XG5cdFx0XHQvLyBhbmQgcmV0dXJuaW5nIGB1bmRlZmluZWRgIGFsaWducyB3aXRoIG9sZGVyIGpRdWVyeS5cblx0XHRcdC8vXG5cdFx0XHQvLyBydHJpbUNTUyB0cmVhdHMgVSswMDBEIENBUlJJQUdFIFJFVFVSTiBhbmQgVSswMDBDIEZPUk0gRkVFRFxuXHRcdFx0Ly8gYXMgd2hpdGVzcGFjZSB3aGlsZSBDU1MgZG9lcyBub3QsIGJ1dCB0aGlzIGlzIG5vdCBhIHByb2JsZW1cblx0XHRcdC8vIGJlY2F1c2UgQ1NTIHByZXByb2Nlc3NpbmcgcmVwbGFjZXMgdGhlbSB3aXRoIFUrMDAwQSBMSU5FIEZFRURcblx0XHRcdC8vICh3aGljaCAqaXMqIENTUyB3aGl0ZXNwYWNlKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jaW5wdXQtcHJlcHJvY2Vzc2luZ1xuXHRcdFx0cmV0ID0gcmV0LnJlcGxhY2UoIHJ0cmltQ1NTLCBcIiQxXCIgKSB8fCB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWlzQXR0YWNoZWQoIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyIGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZSxcblx0dmVuZG9yUHJvcHMgPSB7fTtcblxuLy8gUmV0dXJuIGEgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG9yIHVuZGVmaW5lZFxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJldHVybiBhIHBvdGVudGlhbGx5LW1hcHBlZCBqUXVlcnkuY3NzUHJvcHMgb3IgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHR2YXIgZmluYWwgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSB8fCB2ZW5kb3JQcm9wc1sgbmFtZSBdO1xuXG5cdGlmICggZmluYWwgKSB7XG5cdFx0cmV0dXJuIGZpbmFsO1xuXHR9XG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cdHJldHVybiB2ZW5kb3JQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9O1xuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggX2VsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XG5cdHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRleHRyYSA9IDAsXG5cdFx0ZGVsdGEgPSAwLFxuXHRcdG1hcmdpbkRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHQvLyBDb3VudCBtYXJnaW4gZGVsdGEgc2VwYXJhdGVseSB0byBvbmx5IGFkZCBpdCBhZnRlciBzY3JvbGwgZ3V0dGVyIGFkanVzdG1lbnQuXG5cdFx0Ly8gVGhpcyBpcyBuZWVkZWQgdG8gbWFrZSBuZWdhdGl2ZSBtYXJnaW5zIHdvcmsgd2l0aCBgb3V0ZXJIZWlnaHQoIHRydWUgKWAgKGdoLTM5ODIpLlxuXHRcdGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0bWFyZ2luRGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblx0XHRpZiAoICFpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gQWRkIHBhZGRpbmdcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3Jcblx0XHQvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG5cdFx0XHRpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcblx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcblx0XHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG5cdFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcblx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRkZWx0YSAtXG5cdFx0XHRleHRyYSAtXG5cdFx0XHQwLjVcblxuXHRcdC8vIElmIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyB1bmtub3duLCB0aGVuIHdlIGNhbid0IGRldGVybWluZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyXG5cdFx0Ly8gVXNlIGFuIGV4cGxpY2l0IHplcm8gdG8gYXZvaWQgTmFOIChnaC0zOTY0KVxuXHRcdCkgKSB8fCAwO1xuXHR9XG5cblx0cmV0dXJuIGRlbHRhICsgbWFyZ2luRGVsdGE7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuXHR2YXIgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC00MzIyKS5cblx0XHQvLyBGYWtlIGNvbnRlbnQtYm94IHVudGlsIHdlIGtub3cgaXQncyBuZWVkZWQgdG8ga25vdyB0aGUgdHJ1ZSB2YWx1ZS5cblx0XHRib3hTaXppbmdOZWVkZWQgPSAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IGV4dHJhLFxuXHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCxcblxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcblx0XHRvZmZzZXRQcm9wID0gXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKTtcblxuXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0Ly8gUmV0dXJuIGEgY29uZm91bmRpbmcgbm9uLXBpeGVsIHZhbHVlIG9yIGZlaWduIGlnbm9yYW5jZSwgYXMgYXBwcm9wcmlhdGUuXG5cdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdGlmICggIWV4dHJhICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cdFx0dmFsID0gXCJhdXRvXCI7XG5cdH1cblxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIFVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlLlxuXHQvLyBJbiB0aG9zZSBjYXNlcywgdGhlIGNvbXB1dGVkIHZhbHVlIGNhbiBiZSB0cnVzdGVkIHRvIGJlIGJvcmRlci1ib3guXG5cdGlmICggKCAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpICYmIGlzQm9yZGVyQm94IHx8XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMCAtIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdC8vIElFL0VkZ2UgbWlzcmVwb3J0IGBnZXRDb21wdXRlZFN0eWxlYCBvZiB0YWJsZSByb3dzIHdpdGggd2lkdGgvaGVpZ2h0XG5cdFx0Ly8gc2V0IGluIENTUyB3aGlsZSBgb2Zmc2V0KmAgcHJvcGVydGllcyByZXBvcnQgY29ycmVjdCB2YWx1ZXMuXG5cdFx0Ly8gSW50ZXJlc3RpbmdseSwgaW4gc29tZSBjYXNlcyBJRSA5IGRvZXNuJ3Qgc3VmZmVyIGZyb20gdGhpcyBpc3N1ZS5cblx0XHQhc3VwcG9ydC5yZWxpYWJsZVRyRGltZW5zaW9ucygpICYmIG5vZGVOYW1lKCBlbGVtLCBcInRyXCIgKSB8fFxuXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdFx0Ly8gVGhpcyBoYXBwZW5zIGZvciBpbmxpbmUgZWxlbWVudHMgd2l0aCBubyBleHBsaWNpdCBzZXR0aW5nIChnaC0zNTcxKVxuXHRcdHZhbCA9PT0gXCJhdXRvXCIgfHxcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgLSA0LjMgb25seVxuXHRcdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSAmJlxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoZSBlbGVtZW50IGlzIHZpc2libGUgJiBjb25uZWN0ZWRcblx0XHRlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdFx0Ly8gV2hlcmUgYXZhaWxhYmxlLCBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgYXBwcm94aW1hdGUgYm9yZGVyIGJveCBkaW1lbnNpb25zLlxuXHRcdC8vIFdoZXJlIG5vdCBhdmFpbGFibGUgKGUuZy4sIFNWRyksIGFzc3VtZSB1bnJlbGlhYmxlIGJveC1zaXppbmcgYW5kIGludGVycHJldCB0aGVcblx0XHQvLyByZXRyaWV2ZWQgdmFsdWUgYXMgYSBjb250ZW50IGJveCBkaW1lbnNpb24uXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IG9mZnNldFByb3AgaW4gZWxlbTtcblx0XHRpZiAoIHZhbHVlSXNCb3JkZXJCb3ggKSB7XG5cdFx0XHR2YWwgPSBlbGVtWyBvZmZzZXRQcm9wIF07XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBBZGp1c3QgZm9yIHRoZSBlbGVtZW50J3MgYm94IG1vZGVsXG5cdHJldHVybiAoIHZhbCArXG5cdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0ZWxlbSxcblx0XHRcdGRpbWVuc2lvbixcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXMsXG5cblx0XHRcdC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXG5cdFx0XHR2YWxcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuXHRcdGFzcGVjdFJhdGlvOiB0cnVlLFxuXHRcdGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG5cdFx0Y29sdW1uQ291bnQ6IHRydWUsXG5cdFx0ZmxleEdyb3c6IHRydWUsXG5cdFx0ZmxleFNocmluazogdHJ1ZSxcblx0XHRmb250V2VpZ2h0OiB0cnVlLFxuXHRcdGdyaWRBcmVhOiB0cnVlLFxuXHRcdGdyaWRDb2x1bW46IHRydWUsXG5cdFx0Z3JpZENvbHVtbkVuZDogdHJ1ZSxcblx0XHRncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG5cdFx0Z3JpZFJvdzogdHJ1ZSxcblx0XHRncmlkUm93RW5kOiB0cnVlLFxuXHRcdGdyaWRSb3dTdGFydDogdHJ1ZSxcblx0XHRsaW5lSGVpZ2h0OiB0cnVlLFxuXHRcdG9wYWNpdHk6IHRydWUsXG5cdFx0b3JkZXI6IHRydWUsXG5cdFx0b3JwaGFuczogdHJ1ZSxcblx0XHRzY2FsZTogdHJ1ZSxcblx0XHR3aWRvd3M6IHRydWUsXG5cdFx0ekluZGV4OiB0cnVlLFxuXHRcdHpvb206IHRydWUsXG5cblx0XHQvLyBTVkctcmVsYXRlZFxuXHRcdGZpbGxPcGFjaXR5OiB0cnVlLFxuXHRcdGZsb29kT3BhY2l0eTogdHJ1ZSxcblx0XHRzdG9wT3BhY2l0eTogdHJ1ZSxcblx0XHRzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuXHRcdHN0cm9rZU9wYWNpdHk6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHt9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKHRyYWMtNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnIHRyYWMtOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICh0cmFjLTcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0Ly8gVGhlIGlzQ3VzdG9tUHJvcCBjaGVjayBjYW4gYmUgcmVtb3ZlZCBpbiBqUXVlcnkgNC4wIHdoZW4gd2Ugb25seSBhdXRvLWFwcGVuZFxuXHRcdFx0Ly8gXCJweFwiIHRvIGEgZmV3IGhhcmRjb2RlZCB2YWx1ZXMuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0XHRzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggX2ksIGRpbWVuc2lvbiApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdFx0XHQvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG5cdFx0XHRcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuXHRcdFx0XHRcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG5cdFx0XHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG5cdFx0XHRcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhID9cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdDA7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggcHJlZml4ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gfHxcblx0XHRcdFx0XHR0d2Vlbi5lbGVtLnN0eWxlWyBmaW5hbFByb3BOYW1lKCB0d2Vlbi5wcm9wICkgXSAhPSBudWxsICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCBpblByb2dyZXNzLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHRcdH1cblxuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IERhdGUubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXG5cdFx0Ly8gdGhlIG92ZXJmbG93WCB2YWx1ZSB0aGVyZS5cblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAodHJhYy0xMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIG1vcmUgdG8gZG8sIHlpZWxkXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG5cdFx0XHRpZiAoICFsZW5ndGggKSB7XG5cdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgYW5pbWF0aW9uIGFuZCByZXBvcnQgaXRzIGNvbmNsdXNpb25cblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0gRGF0ZS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCAodHJhYy0xMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XG5cdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdH1cblx0cmV0dXJuIFtdO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZXMsIGN1ciwgY3VyVmFsdWUsIGNsYXNzTmFtZSwgaSwgZmluYWxWYWx1ZTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc05hbWVzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGN1ciA9IHRoaXMubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkgXTtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhc3NOYW1lICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGFzc05hbWUgKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZXMsIGN1ciwgY3VyVmFsdWUsIGNsYXNzTmFtZSwgaSwgZmluYWxWYWx1ZTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3NOYW1lcy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IHRoaXMubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXNzTmFtZSArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZXMsIGNsYXNzTmFtZSwgaSwgc2VsZixcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCB2YWx1ZUlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKHRyYWMtMTQ2ODYsIHRyYWMtMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICh0cmFjLTI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IW5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0geyBndWlkOiBEYXRlLm5vdygpIH07XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbCwgcGFyc2VyRXJyb3JFbGVtO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdHBhcnNlckVycm9yRWxlbSA9IHhtbCAmJiB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApWyAwIF07XG5cdGlmICggIXhtbCB8fCBwYXJzZXJFcnJvckVsZW0gKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIChcblx0XHRcdHBhcnNlckVycm9yRWxlbSA/XG5cdFx0XHRcdGpRdWVyeS5tYXAoIHBhcnNlckVycm9yRWxlbS5jaGlsZE5vZGVzLCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsLnRleHRDb250ZW50O1xuXHRcdFx0XHR9ICkuam9pbiggXCJcXG5cIiApIDpcblx0XHRcdFx0ZGF0YVxuXHRcdCkgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0fTtcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLCBsYXN0RWxlbWVudCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gbGFzdEVsZW1lbnQgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAodHJhYy05OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAodHJhYy05NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCBPYmplY3QuY3JlYXRlKCBudWxsICkgKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICh0cmFjLTYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdGlmICggYSA9PSBudWxsICkge1xuXHRcdHJldHVybiBcIlwiO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9ICkubWFwKCBmdW5jdGlvbiggX2ksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vIHRyYWMtNzY1MywgdHJhYy04MTI1LCB0cmFjLTgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKHRyYWMtMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5vcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgdHJhYy05ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG5cdFx0XHRcdFx0XHRcdFx0XHQoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAodHJhYy0xMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCB0cmFjLTEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAodHJhYy0xNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vIHRyYWMtOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UuZ3VpZCsrICkgK1xuXHRcdFx0XHRcdHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVc2UgYSBub29wIGNvbnZlcnRlciBmb3IgbWlzc2luZyBzY3JpcHQgYnV0IG5vdCBpZiBqc29ucFxuXHRcdFx0aWYgKCAhaXNTdWNjZXNzICYmXG5cdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBcInNjcmlwdFwiLCBzLmRhdGFUeXBlcyApID4gLTEgJiZcblx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIFwianNvblwiLCBzLmRhdGFUeXBlcyApIDwgMCApIHtcblx0XHRcdFx0cy5jb252ZXJ0ZXJzWyBcInRleHQgc2NyaXB0XCIgXSA9IGZ1bmN0aW9uKCkge307XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIF9pLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0dmFyIGk7XG5cdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdGlmICggaS50b0xvd2VyQ2FzZSgpID09PSBcImNvbnRlbnQtdHlwZVwiICkge1xuXHRcdFx0cy5jb250ZW50VHlwZSA9IHMuaGVhZGVyc1sgaSBdIHx8IFwiXCI7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCwgb3B0aW9ucywgZG9jICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAodHJhYy0xMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXG5cdFx0Ly8gT25seSBldmFsdWF0ZSB0aGUgcmVzcG9uc2UgaWYgaXQgaXMgc3VjY2Vzc2Z1bCAoZ2gtNDEyNilcblx0XHQvLyBkYXRhRmlsdGVyIGlzIG5vdCBpbnZva2VkIGZvciBmYWlsdXJlIHJlc3BvbnNlcywgc28gdXNpbmcgaXQgaW5zdGVhZFxuXHRcdC8vIG9mIHRoZSBkZWZhdWx0IGNvbnZlcnRlciBpcyBrbHVkZ3kgYnV0IGl0IHdvcmtzLlxuXHRcdGNvbnZlcnRlcnM6IHtcblx0XHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oKSB7fVxuXHRcdH0sXG5cdFx0ZGF0YUZpbHRlcjogZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHJlc3BvbnNlLCBvcHRpb25zLCBkb2MgKTtcblx0XHR9XG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gdHJhYy0xNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgdHJhYy04NjA1LCB0cmFjLTE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyB0cmFjLTE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIG9yIGZvcmNlZC1ieS1hdHRycyByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gfHwgcy5zY3JpcHRBdHRycyApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApXG5cdFx0XHRcdFx0LmF0dHIoIHMuc2NyaXB0QXR0cnMgfHwge30gKVxuXHRcdFx0XHRcdC5wcm9wKCB7IGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCwgc3JjOiBzLnVybCB9IClcblx0XHRcdFx0XHQub24oIFwibG9hZCBlcnJvclwiLCBjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UuZ3VpZCsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgcmVjdCwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHQvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0d2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuXHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG5cdFx0fTtcblx0fSxcblxuXHQvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuXHQvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcblx0XHRcdC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiZcblx0XHRcdFx0KCBvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCApICYmXG5cdFx0XHRcdGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsZW0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBqUXVlcnkoIG9mZnNldFBhcmVudCApLm9mZnNldCgpO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3Ncblx0XHRcdHZhciB3aW47XG5cdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggX2ksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHtcblx0XHRwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLFxuXHRcdGNvbnRlbnQ6IHR5cGUsXG5cdFx0XCJcIjogXCJvdXRlclwiICsgbmFtZVxuXHR9LCBmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBfaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH0sXG5cblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzXG5cdFx0XHQub24oIFwibW91c2VlbnRlclwiLCBmbk92ZXIgKVxuXHRcdFx0Lm9uKCBcIm1vdXNlbGVhdmVcIiwgZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goXG5cdCggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cblx0XHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHRcdH07XG5cdH1cbik7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG4vLyBSZXF1aXJlIHRoYXQgdGhlIFwid2hpdGVzcGFjZSBydW5cIiBzdGFydHMgZnJvbSBhIG5vbi13aGl0ZXNwYWNlXG4vLyB0byBhdm9pZCBPKE5eMikgYmVoYXZpb3Igd2hlbiB0aGUgZW5naW5lIHdvdWxkIHRyeSBtYXRjaGluZyBcIlxccyskXCIgYXQgZWFjaCBzcGFjZSBwb3NpdGlvbi5cbnZhciBydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfChbXlxcc1xcdUZFRkZcXHhBMF0pW1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbi8vIGFyZ3VtZW50cy5cbi8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxualF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0Y29udGV4dCA9IGZuO1xuXHRcdGZuID0gdG1wO1xuXHR9XG5cblx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0aWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRyZXR1cm4gcHJveHk7XG59O1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xualF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xualF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xualF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxualF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG59O1xuXG5qUXVlcnkudHJpbSA9IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcIlwiIDpcblx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApO1xufTtcblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAodHJhYy03MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAodHJhYy0xMzU2NilcbmlmICggdHlwZW9mIG5vR2xvYmFsID09PSBcInVuZGVmaW5lZFwiICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iLCJpbXBvcnQgJCBmcm9tJ2pxdWVyeSc7XHJcbmltcG9ydCB0aXBweSBmcm9tIFwiLi9qcy90aXBweS5hbGwubWluLmpzXCI7XHJcblxyXG5cclxuLy8gRHJhd3MgYSBsaW5lIHdpdGhvdXQgdXNpbmcgYSBjYW52YXMuIFVzZXMgYSBsb25nIHRoaW4gPGRpdj4gdGhhdCBpcyByb3RhdGVkLlxyXG4vLyBmcm9tIENyYWlnIFRhYiB2aWEgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQ1NjAzMDIvaHRtbC1saW5lLWRyYXdpbmctd2l0aG91dC1jYW52YXMtanVzdC1qc1xyXG4vLyBpbXByb3ZlZCBieSBEYXZpZGUuXHJcbmZ1bmN0aW9uIGxpbmVkcmF3KHgxLCB5MSwgeDIsIHkyKSB7XHJcbiAgaWYgKHgyIDwgeDEpIHtcclxuICAgIHZhciB0bXA7XHJcbiAgICB0bXAgPSB4MiA7XHJcbiAgICB4MiA9IHgxIDtcclxuICAgIHgxID0gdG1wO1xyXG4gICAgdG1wID0geTIgO1xyXG4gICAgeTIgPSB5MSA7XHJcbiAgICB5MSA9IHRtcDtcclxuICB9XHJcblxyXG4gIHZhciBsaW5lTGVuZ3RoID0gTWF0aC5zcXJ0KE1hdGgucG93KHgyIC0geDEsIDIpICsgTWF0aC5wb3coeTIgLSB5MSwgMikpO1xyXG4gIHZhciBtID0gKHkyIC0geTEpIC8gKHgyIC0geDEpO1xyXG5cclxuICB2YXIgZGVncmVlID0gTWF0aC5hdGFuKG0pICogMTgwIC8gTWF0aC5QSTtcclxuXHJcbiAgLy9sZXQgc3RyID0gXCI8ZGl2IGNsYXNzPSdsaW5lJyBzdHlsZT1cXFwidHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7IHRyYW5zZm9ybTogcm90YXRlKCcgKyBkZWdyZWUgKyAnZGVnKTsgd2lkdGg6ICcgKyBsaW5lTGVuZ3RoICsgJ3B4OyBoZWlnaHQ6IDFweDsgYmFja2dyb3VuZDogYmxhY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAnICsgeTEgKyAncHg7IGxlZnQ6ICcgKyB4MSArICdweDtcXFwiPjwvZGl2PlwiO1xyXG4gIGxldCBzdHIgPSBcIjxkaXYgY2xhc3M9J2xpbmUnIHN0eWxlPSd0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgbGVmdDsgdHJhbnNmb3JtOiByb3RhdGUoXCIgKyBkZWdyZWUgKyBcImRlZyk7IHdpZHRoOiBcIiArIGxpbmVMZW5ndGggKyBcInB4OyBoZWlnaHQ6IDFweDsgYmFja2dyb3VuZDogYmxhY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiBcIiArIHkxICsgXCJweDsgbGVmdDogXCIgKyB4MSArIFwicHg7Jz48L2Rpdj5cIjtcclxuICAvL2NvbnNvbGUubG9nKHN0cik7IFxyXG4gIHJldHVybiAkKHN0cik7XHJcbn1cclxuXHJcbnZhciB0aXBweUFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuZnVuY3Rpb24gYWN0aXZhdGVUaXBweSgpIHtcclxuXHRyZXR1cm47XHJcblx0XHR0aXBweSgnLmV2dCcsIHtcclxuXHRcdGFycm93OiB0cnVlLFxyXG5cdFx0aHRtbDogJyN0aXBweXRlbXAnLFxyXG5cdFx0b25TaG93KHBvcCkge1xyXG5cdFx0XHRpZiAoIWFjdGl2ZVZpZXcpIHJldHVybjtcclxuXHRcdFx0Y29uc3QgY29udGVudCA9IHRoaXMucXVlcnlTZWxlY3RvcignLnRpcHB5LWNvbnRlbnQnKTtcclxuXHRcdFx0bGV0IGV2ZW50SWQgPSBwb3AucmVmZXJlbmNlLmdldEF0dHJpYnV0ZSgnZGF0YS1laWQnKTtcclxuXHRcdFx0aWYgKGV2ZW50SWQgPj0gYWN0aXZlVmlldy5ldmVudHMubGVuZ3RoKSByZXR1cm47XHJcblx0XHRcdGxldCBldnQgPSBhY3RpdmVWaWV3LmV2ZW50c1tldmVudElkXTtcclxuXHRcdFx0bGV0IGV2dFN0ciA9IGV2dC50YWcgKyBcIiBcIjtcclxuXHRcdFx0aWYgKGV2dC52YWx1ZSkge1xyXG5cdFx0XHRcdGV2dFN0ciA9IGV2dC52YWx1ZSArIFwiIFwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGV2dFN0ciArPSBcInQ9XCIgKyAoZXZ0LmFic1N0YXJ0IC0gYWN0aXZlVmlldy5maXJzdFRpbWUpIC8gNDAwMDAwMDAwO1xyXG5cdFx0XHRsZXQgZHVyYXRpb24gPSAwO1xyXG5cdFx0XHRpZiAoZXZ0LmR1cmF0aW9uID4gMC4wKXtcclxuXHRcdFx0XHRkdXJhdGlvbiA9IGV2dC5kdXJhdGlvbjtcclxuXHRcdFx0fSBlbHNlIGlmIChldnQuZW5kRXZlbnQpIHtcclxuXHRcdFx0XHRsZXQgcHggPSBhY3RpdmVWaWV3LnNlYXJjaEZvclByZXZpb3VzRXZlbnQoZXZlbnRJZCwgZXZ0LnRhZyk7XHJcblx0XHRcdFx0ZHVyYXRpb24gPSBldnQuYWJzU3RhcnQgLSBhY3RpdmVWaWV3LmV2ZW50c1tweF0uYWJzU3RhcnQ7XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IGR1ciA9IGR1cmF0aW9uIC8gNDAwMDAwMDAwO1xyXG5cdFx0XHRpZiAoZHVyID4gMC4wKSBldnRTdHIgKz0gXCIsIFxcdTAzOTR0PVwiICsgZHVyO1xyXG5cdFx0XHRldnRTdHIgKz0gXCI8YnI+XCIgKyBldnQuYm9keTtcclxuXHRcdFx0Y29udGVudC5pbm5lckhUTUwgPSBldnRTdHI7XHJcblx0XHR9LFxyXG5cdH0pO1xyXG59XHJcblxyXG5cclxuY2xhc3MgalBsb3Qge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHZpZXdlcikge1xyXG4gIFx0dGhpcy52aWV3ZXIgPSB2aWV3ZXI7XHJcbiAgXHR0aGlzLnNjYWxlRmFjdG9yICA9IHZpZXdlci50aW1lU2NhbGU7XHJcbiAgfVxyXG5cclxuICByZW5kZXIoKSB7XHJcbiAgXHRsZXQgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2U7XHJcbiAgXHRsZXQgcnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgXHRsZXQgdmlldyA9IHRoaXMudmlld2VyO1xyXG5cclxuICAgIGxldCBmaXJzdHRpbWUgPSB2aWV3Lm1pbkFic1RpbWU7XHJcbiAgICBsZXQgbGFzdFggPSAodmlldy5tYXhBYnNUaW1lIC0gdmlldy5taW5BYnNUaW1lKSAvIHZpZXcudGltZVNjYWxlO1xyXG4gICAgbGV0IHRpbWVsaW5lID0gJChcIjxkaXYvPlwiKTtcclxuICAgIGxldCBsYXN0WE1hcCA9IG5ldyBNYXAoKTtcclxuICAgIGxldCBsYXN0WU1hcCA9IG5ldyBNYXAoKTtcclxuICAgIGxldCBsYXN0RXZlbnRGb3JUYWcgPSBuZXcgTWFwKCk7XHJcbiAgICB0aW1lbGluZS5hZGRDbGFzcygndGltZWxpbmUnKTtcclxuICAgIGxldCBtYXhXaWR0aCA9ICgodmlldy5tYXhBYnNUaW1lIC0gdmlldy5taW5BYnNUaW1lKSAvIHZpZXcudGltZVNjYWxlKTtcclxuXHRcdHRpbWVsaW5lLmNzcyhcIndpZHRoXCIsIG1heFdpZHRoICsgXCJweFwiKTtcclxuXHRcdHRpbWVsaW5lLmNzcyhcImhlaWdodFwiLCAodmlldy5tYXhZICsgdmlldy5sYW5lSGVpZ2h0KSArIFwicHhcIik7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpZXcuZXZlbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGxldCBldnQgPSB2aWV3LmV2ZW50c1tpXTtcclxuICAgICAgbGV0IHJlbFQgPSBldnQuYWJzU3RhcnQgLSBmaXJzdHRpbWU7XHJcbiAgICAgIGxldCB0YWcgPSBldnQudGFnO1xyXG4gICAgICBsZXQgaXRlbSA9ICQoJzxkaXYvPicpO1xyXG4gICAgICBsZXQgeSA9IHZpZXcudHJhY2tNYXAuZ2V0KGV2dC50YWcpO1xyXG4gICAgICBpZiAoZXZ0LnZhbHVlICE9IHVuZGVmaW5lZClcclxuICAgICAge1xyXG4gICAgICAgIGxldCBtaW5WID0gdmlldy5taW5SYW5nZS5nZXQodGFnKTtcclxuICAgICAgICBsZXQgbWF4ViA9IHZpZXcubWF4UmFuZ2UuZ2V0KHRhZyk7XHJcbiAgICAgICAgbGV0IHJhbmdlID0gKG1heFYgLSBtaW5WKTtcclxuICAgICAgICBpZiAocmFuZ2UgPT09IDApIHJhbmdlID0gMTtcclxuICAgICAgICB5ICs9IHZpZXcucGxvdEhlaWdodCAtICgoKGV2dC52YWx1ZSAtIG1pblYpICogdmlldy5wbG90SGVpZ2h0KSAvIHJhbmdlKTtcclxuICAgICAgICBsZXQgeCA9IHJlbFQgLyB2aWV3LnRpbWVTY2FsZTtcclxuICAgICAgICBpZiAodmlldy5mbGlwcGVkKSB7XHJcbiAgICAgICAgXHR4ID0gbGFzdFggLSB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFzdFhNYXAuaGFzKHRhZykpIHtcclxuICAgICAgICBcdCBsZXQgeDAgPSBsYXN0WE1hcC5nZXQodGFnKTtcclxuICAgICAgICBcdCBsZXQgeTAgPSBsYXN0WU1hcC5nZXQodGFnKTtcclxuICAgICAgICAgICBpdGVtID0gbGluZWRyYXcoeDAsIHkwLCB4LCB5KTtcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgaXRlbS5hZGRDbGFzcygndmFsdWVwbG90Jyk7XHJcbiAgICAgICAgbGFzdFhNYXAuc2V0KHRhZywgeCk7XHJcbiAgICAgICAgbGFzdFlNYXAuc2V0KHRhZywgeSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaXRlbS5hZGRDbGFzcygnZXZlbnRJdGVtJyk7XHJcbiAgICAgICAgbGV0IHQxID0gZXZ0LmFic1N0YXJ0IC0gZmlyc3R0aW1lO1xyXG4gICAgICAgIGxldCB0MjtcclxuICAgICAgICBpZiAoZXZ0LmR1cmF0aW9uID4gMCkge1xyXG4gICBcdFx0XHRcdHQxID0gZXZ0LmFic1N0YXJ0IC0gZmlyc3R0aW1lO1xyXG4gICBcdFx0XHRcdHQyID0gdDEgKyBldnQuZHVyYXRpb247XHJcbiAgICAgICAgfSBlbHNlIGlmIChldnQuZW5kRXZlbnQpIHtcclxuICAgICAgICAvLyBUaGlzIGlzIGFuIFwiZW5kaW5nIGV2ZW50XCIsIHNvIGRyYXcgdGhlIGJhciBmcm9tIHRoZSBwcmV2aW91cyBldmVudCB0byBoZXJlLlxyXG4gICAgICAgIFx0bGV0IHByZXZYID0gdmlldy5zZWFyY2hGb3JQcmV2aW91c0V2ZW50KHZpZXcuZXZlbnRzLCBpLCBldnQudGFnKTtcclxuICAgICAgICBcdGlmIChwcmV2WCA8IDApIGNvbnRpbnVlO1xyXG4gICAgICAgICAgdDIgPSB2aWV3LmV2ZW50c1twcmV2WF0uYWJzU3RhcnQgLSBmaXJzdHRpbWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICBcdHQyID0gdDE7XHJcbiAgICAgICAgfVxyXG5cclxuXHRcdFx0XHRsZXQgd2lkdGggPSAyO1xyXG5cdFx0XHRcdGlmICh0MSAhPSB0Mikge1xyXG4gICAgICAgIFx0d2lkdGggPSBNYXRoLmFicyh0MiAtIHQxKSAvIHZpZXcudGltZVNjYWxlO1xyXG4gIFx0XHRcdH1cclxuICAgICAgICBpZiAod2lkdGggPCAxKSB3aWR0aCA9IDE7XHJcbiAgIFxyXG4gICAgICAgIGxldCB4ID0gdDEgLyAgdmlldy50aW1lU2NhbGU7XHJcbiAgICAgICAgaWYgKHZpZXcuZmxpcHBlZCkge1xyXG4gICAgICAgIFx0eCA9IChsYXN0WCAtIHgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgXHR4IC09IHdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpdGVtLmNzcyhcIndpZHRoXCIsIHdpZHRoICsgXCJweFwiKTtcclxuICAgICAgICBpdGVtLmNzcyhcImxlZnRcIiwgeCArIFwicHhcIik7XHJcbiAgICAgICAgaXRlbS5jc3MoXCJ0b3BcIiwgeSArIFwicHhcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGl0ZW0uY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBldnQuY29sb3IpO1xyXG4gICAgICBpdGVtLmF0dHIoJ2RhdGEtZWlkJywgaSk7XHJcbiAgICAgIGl0ZW0uYWRkQ2xhc3MoJ2V2dCcpO1xyXG4gICAgICB0aW1lbGluZS5hcHBlbmQoaXRlbSk7XHJcbiAgICAgIGxhc3RFdmVudEZvclRhZy5zZXQodGFnLCBldnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYWRkVGFnTGFiZWxzVG8odGltZWxpbmUpO1xyXG4gICAgJChcIiNwbG90XCIpLmVtcHR5KCk7XHJcbiAgICAkKFwiI3Bsb3RcIikuYXBwZW5kKHRpbWVsaW5lKTtcclxuICAgIC8qXHJcbiAgICBsZXQgcGxvdCA9ICQoXCIjcGxvdFwiKTtcclxuICAgIHBsb3QuY3NzKFwid2lkdGhcIiwgbWF4V2lkdGggKyBcInB4XCIpO1xyXG5cdFx0cGxvdC5jc3MoXCJoZWlnaHRcIiwgKHRoaXMubWF4WSArIHRoaXMubGFuZUhlaWdodCkgKyBcInB4XCIpO2NzcyhcIndpZHRoXCIsICk7XHJcblx0XHQqL1xyXG5cdFx0Ly9pZiAoIXN5c0V4UnVubmluZykgYWN0aXZhdGVUaXBweSgpO1xyXG5cdFx0Ly9cdGVsc2UgdGlwcHlBY3RpdmUgPSBmYWxzZTtcclxuICAgIGxldCByZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICBjb25zb2xlLmxvZyhcIlRpbWUgdG8gcmVuZGVyOiBcIiArIChyZW5kIC0gcnN0YXJ0KSk7XHJcbiAgfVxyXG5cclxuICBhZGRUYWdMYWJlbHNUbyh0aW1lbGluZSkge1xyXG5cclxuXHQgIGxldCBrZXlEaXYgPSAkKFwiPGRpdiBjbGFzcz0nb3ZlcmxheScgc3R5bGU9J3RvcDogMHB4O2xlZnQ6MHB4Jz48L2RpdlwiKTtcclxuXHQgIGxldCB2aWV3ID0gdGhpcy52aWV3ZXI7XHJcblx0ICBmb3IgKGxldCBpID0gMDsgaSA8IHZpZXcudHJhY2tPcmRlci5sZW5ndGg7ICsraSkge1xyXG5cdCAgXHRsZXQgdGFnID0gdmlldy50cmFja09yZGVyW2ldO1xyXG5cdCAgXHRsZXQgeSA9IHZpZXcudHJhY2tNYXAuZ2V0KHRhZyk7XHJcblx0ICBcdGxldCBsYWJsaW5lID0gJChcIjxkaXYgY2xhc3M9J2xpbmVsYWJlbCcvPlwiKTtcclxuXHQgIFx0bGFibGluZS5jc3MoXCJ0b3BcIiwgeSArIFwicHhcIik7XHJcblx0ICBcdGxhYmxpbmUudGV4dCh0YWcpO1xyXG5cdCAgXHRrZXlEaXYuYXBwZW5kKGxhYmxpbmUpO1xyXG5cdCAgfVxyXG5cdFx0dGltZWxpbmUuYXBwZW5kKGtleURpdik7XHJcbiAgfVxyXG5cclxufTtcclxuXHJcblxyXG5leHBvcnQge2pQbG90fTsiLCJmdW5jdGlvbiBwb2ludFdpdGhpbihweCwgcHksIHJsZnQsIHJ0b3AsIHJyZ3QsIHJidG0pIHtcclxuICAgIHJldHVybiBweCA+PSBybGZ0ICYmIHB4IDw9IHJyZ3QgJiYgcHkgPj0gcnRvcCAmJiBweSA8PSByYnRtO1xyXG59XHJcblxyXG5cdGNvbnN0IE1BWF9PQkpFQ1RTID0gMTA7XHJcblx0Y29uc3QgTUFYX0xFVkVMUyAgPSA0O1xyXG5cclxuXHRleHBvcnQgZGVmYXVsdCBjbGFzcyBRdWFkdHJlZVxyXG5cdHtcclxuXHRcdGNvbnN0cnVjdG9yKHgsIHksIHcsIGgsIGwpIHtcclxuXHRcdGxldCB0ID0gdGhpcztcclxuXHJcblx0XHR0LnggPSB4O1xyXG5cdFx0dC55ID0geTtcclxuXHRcdHQudyA9IHc7XHJcblx0XHR0LmggPSBoO1xyXG5cdFx0dC5sID0gbCB8fCAwO1xyXG5cdFx0dC5vID0gW107XHJcblx0XHR0LnEgPSBudWxsO1xyXG5cdCB9XHJcblxyXG5cclxuXHRcdHNwbGl0KCkge1xyXG5cdFx0XHRsZXQgdCA9IHRoaXMsXHJcblx0XHRcdFx0eCA9IHQueCxcclxuXHRcdFx0XHR5ID0gdC55LFxyXG5cdFx0XHRcdHcgPSB0LncgLyAyLFxyXG5cdFx0XHRcdGggPSB0LmggLyAyLFxyXG5cdFx0XHRcdGwgPSB0LmwgKyAxO1xyXG5cclxuXHRcdFx0dC5xID0gW1xyXG5cdFx0XHRcdC8vIHRvcCByaWdodFxyXG5cdFx0XHRcdG5ldyBRdWFkdHJlZSh4ICsgdywgeSwgICAgIHcsIGgsIGwpLFxyXG5cdFx0XHRcdC8vIHRvcCBsZWZ0XHJcblx0XHRcdFx0bmV3IFF1YWR0cmVlKHgsICAgICB5LCAgICAgdywgaCwgbCksXHJcblx0XHRcdFx0Ly8gYm90dG9tIGxlZnRcclxuXHRcdFx0XHRuZXcgUXVhZHRyZWUoeCwgICAgIHkgKyBoLCB3LCBoLCBsKSxcclxuXHRcdFx0XHQvLyBib3R0b20gcmlnaHRcclxuXHRcdFx0XHRuZXcgUXVhZHRyZWUoeCArIHcsIHkgKyBoLCB3LCBoLCBsKSxcclxuXHRcdFx0XTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gaW52b2tlcyBjYWxsYmFjayB3aXRoIGluZGV4IG9mIGVhY2ggb3ZlcmxhcHBpbmcgcXVhZFxyXG5cdFx0cXVhZHMoeCwgeSwgdywgaCwgY2IpIHtcclxuXHRcdFx0bGV0IHQgICAgICAgICAgICA9IHRoaXMsXHJcblx0XHRcdFx0cSAgICAgICAgICAgID0gdC5xLFxyXG5cdFx0XHRcdGh6TWlkICAgICAgICA9IHQueCArIHQudyAvIDIsXHJcblx0XHRcdFx0dnRNaWQgICAgICAgID0gdC55ICsgdC5oIC8gMixcclxuXHRcdFx0XHRzdGFydElzTm9ydGggPSB5ICAgICA8IHZ0TWlkLFxyXG5cdFx0XHRcdHN0YXJ0SXNXZXN0ICA9IHggICAgIDwgaHpNaWQsXHJcblx0XHRcdFx0ZW5kSXNFYXN0ICAgID0geCArIHcgPiBoek1pZCxcclxuXHRcdFx0XHRlbmRJc1NvdXRoICAgPSB5ICsgaCA+IHZ0TWlkO1xyXG5cclxuXHRcdFx0Ly8gdG9wLXJpZ2h0IHF1YWRcclxuXHRcdFx0c3RhcnRJc05vcnRoICYmIGVuZElzRWFzdCAmJiBjYihxWzBdKTtcclxuXHRcdFx0Ly8gdG9wLWxlZnQgcXVhZFxyXG5cdFx0XHRzdGFydElzV2VzdCAmJiBzdGFydElzTm9ydGggJiYgY2IocVsxXSk7XHJcblx0XHRcdC8vIGJvdHRvbS1sZWZ0IHF1YWRcclxuXHRcdFx0c3RhcnRJc1dlc3QgJiYgZW5kSXNTb3V0aCAmJiBjYihxWzJdKTtcclxuXHRcdFx0Ly8gYm90dG9tLXJpZ2h0IHF1YWRcclxuXHRcdFx0ZW5kSXNFYXN0ICYmIGVuZElzU291dGggJiYgY2IocVszXSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGFkZChvKSB7XHJcblx0XHRcdGxldCB0ID0gdGhpcztcclxuXHJcblx0XHRcdGlmICh0LnEgIT0gbnVsbCkge1xyXG5cdFx0XHRcdHQucXVhZHMoby54LCBvLnksIG8udywgby5oLCBxID0+IHtcclxuXHRcdFx0XHRcdHEuYWRkKG8pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGxldCBvcyA9IHQubztcclxuXHJcblx0XHRcdFx0b3MucHVzaChvKTtcclxuXHJcblx0XHRcdFx0aWYgKG9zLmxlbmd0aCA+IE1BWF9PQkpFQ1RTICYmIHQubCA8IE1BWF9MRVZFTFMpIHtcclxuXHRcdFx0XHRcdHQuc3BsaXQoKTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG9zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdGxldCBvaSA9IG9zW2ldO1xyXG5cclxuXHRcdFx0XHRcdFx0dC5xdWFkcyhvaS54LCBvaS55LCBvaS53LCBvaS5oLCBxID0+IHtcclxuXHRcdFx0XHRcdFx0XHRxLmFkZChvaSk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHQuby5sZW5ndGggPSAwO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRnZXQoeCwgeSwgdywgaCwgY2IpIHtcclxuXHRcdFx0bGV0IHQgPSB0aGlzO1xyXG5cdFx0XHRsZXQgb3MgPSB0Lm87XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG9zLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdGNiKG9zW2ldKTtcclxuXHJcblx0XHRcdGlmICh0LnEgIT0gbnVsbCkge1xyXG5cdFx0XHRcdHQucXVhZHMoeCwgeSwgdywgaCwgcSA9PiB7XHJcblx0XHRcdFx0XHRxLmdldCh4LCB5LCB3LCBoLCBjYik7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0Y2xlYXIoKSB7XHJcblx0XHRcdHRoaXMuby5sZW5ndGggPSAwO1xyXG5cdFx0XHR0aGlzLnEgPSBudWxsO1xyXG5cdFx0fTtcclxuXHR9O1xyXG4iLCIoZnVuY3Rpb24odCxlKXsnb2JqZWN0Jz09dHlwZW9mIGV4cG9ydHMmJid1bmRlZmluZWQnIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTonZnVuY3Rpb24nPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShlKTp0LnRpcHB5PWUoKX0pKHRoaXMsZnVuY3Rpb24oKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gdCh0KXtyZXR1cm4nW29iamVjdCBPYmplY3RdJz09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX1mdW5jdGlvbiBhKHQpe3JldHVybltdLnNsaWNlLmNhbGwodCl9ZnVuY3Rpb24gbyhlKXtpZihlIGluc3RhbmNlb2YgRWxlbWVudHx8dChlKSlyZXR1cm5bZV07aWYoZSBpbnN0YW5jZW9mIE5vZGVMaXN0KXJldHVybiBhKGUpO2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGU7dHJ5e3JldHVybiBhKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZSkpfWNhdGNoKHQpe3JldHVybltdfX1mdW5jdGlvbiByKHQpe2Zvcih2YXIgZT1bITEsJ3dlYmtpdCddLGE9dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0LnNsaWNlKDEpLG89MDtvPGUubGVuZ3RoO28rKyl7dmFyIGk9ZVtvXSxyPWk/JycraSthOnQ7aWYoJ3VuZGVmaW5lZCchPXR5cGVvZiBkb2N1bWVudC5ib2R5LnN0eWxlW3JdKXJldHVybiByfXJldHVybiBudWxsfWZ1bmN0aW9uIHAodCxlLGEpe3ZhciBpPWEuYXJyb3csbz1hLmFycm93VHlwZSxwPWEuYXJyb3dUcmFuc2Zvcm0sbj1hLmFuaW1hdGVGaWxsLHM9YS5pbmVydGlhLGw9YS5hbmltYXRpb24sZD1hLnNpemUsYz1hLnRoZW1lLG09YS5odG1sLGY9YS56SW5kZXgsaD1hLmludGVyYWN0aXZlLGI9YS5tYXhXaWR0aCx1PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO3Uuc2V0QXR0cmlidXRlKCdjbGFzcycsJ3RpcHB5LXBvcHBlcicpLHUuc2V0QXR0cmlidXRlKCdyb2xlJywndG9vbHRpcCcpLHUuc2V0QXR0cmlidXRlKCdpZCcsJ3RpcHB5LScrdCksdS5zdHlsZS56SW5kZXg9Zix1LnN0eWxlLm1heFdpZHRoPWI7dmFyIHk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7aWYoeS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywndGlwcHktdG9vbHRpcCcpLHkuc2V0QXR0cmlidXRlKCdkYXRhLXNpemUnLGQpLHkuc2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGlvbicsbCkseS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnLCdoaWRkZW4nKSxjLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihlKXt5LmNsYXNzTGlzdC5hZGQoZSsnLXRoZW1lJyl9KSxpKXt2YXIgZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtnLnN0eWxlW3IoJ3RyYW5zZm9ybScpXT1wLCdyb3VuZCc9PT1vPyhnLmNsYXNzTGlzdC5hZGQoJ3RpcHB5LXJvdW5kYXJyb3cnKSxnLmlubmVySFRNTD0nPHN2ZyB2aWV3Qm94PVwiMCAwIDI0IDhcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS1taXRlcmxpbWl0PVwiMS40MTRcIj48cGF0aCBkPVwiTTEgOHM0LjU3Ny0uMDE5IDcuMjUzLTQuMjE4YzIuMzU3LTMuNjk4IDUuMTc1LTMuNzIxIDcuNTA4IDBDMTguNDA0IDcuOTk3IDIzIDggMjMgOEgxelwiLz48L3N2Zz4nKTpnLmNsYXNzTGlzdC5hZGQoJ3RpcHB5LWFycm93JykseS5hcHBlbmRDaGlsZChnKX1pZihuKXt5LnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRlZmlsbCcsJycpO3ZhciB3PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO3cuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywnaGlkZGVuJyksdy5jbGFzc0xpc3QuYWRkKCd0aXBweS1iYWNrZHJvcCcpLHkuYXBwZW5kQ2hpbGQodyl9cyYmeS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5lcnRpYScsJycpLGgmJnkuc2V0QXR0cmlidXRlKCdkYXRhLWludGVyYWN0aXZlJywnJyk7dmFyIHg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7aWYoeC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywndGlwcHktY29udGVudCcpLG0pe3ZhciB2O20gaW5zdGFuY2VvZiBFbGVtZW50Pyh4LmFwcGVuZENoaWxkKG0pLHY9JyMnK20uaWR8fCd0aXBweS1odG1sLXRlbXBsYXRlJyk6KHguaW5uZXJIVE1MPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IobSkuaW5uZXJIVE1MLHY9bSksdS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaHRtbCcsJycpLGgmJnUuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsJy0xJykseS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGVtcGxhdGUtaWQnLHYpfWVsc2UgeC5pbm5lckhUTUw9ZTtyZXR1cm4geS5hcHBlbmRDaGlsZCh4KSx1LmFwcGVuZENoaWxkKHkpLHV9ZnVuY3Rpb24gbih0LGUsYSxpKXt2YXIgbz1hLmhhbmRsZVRyaWdnZXIscj1hLmhhbmRsZU1vdXNlTGVhdmUscD1hLmhhbmRsZUJsdXIsbj1hLmhhbmRsZURlbGVnYXRlU2hvdyxzPWEuaGFuZGxlRGVsZWdhdGVIaWRlLGw9W107aWYoJ21hbnVhbCc9PT10KXJldHVybiBsO3ZhciBkPWZ1bmN0aW9uKHQsYSl7ZS5hZGRFdmVudExpc3RlbmVyKHQsYSksbC5wdXNoKHtldmVudDp0LGhhbmRsZXI6YX0pfTtyZXR1cm4gaS50YXJnZXQ/KEF0LnN1cHBvcnRzVG91Y2gmJmkudG91Y2hIb2xkJiYoZCgndG91Y2hzdGFydCcsbiksZCgndG91Y2hlbmQnLHMpKSwnbW91c2VlbnRlcic9PT10JiYoZCgnbW91c2VvdmVyJyxuKSxkKCdtb3VzZW91dCcscykpLCdmb2N1cyc9PT10JiYoZCgnZm9jdXNpbicsbiksZCgnZm9jdXNvdXQnLHMpKSwnY2xpY2snPT09dCYmZCgnY2xpY2snLG4pKTooZCh0LG8pLEF0LnN1cHBvcnRzVG91Y2gmJmkudG91Y2hIb2xkJiYoZCgndG91Y2hzdGFydCcsbyksZCgndG91Y2hlbmQnLHIpKSwnbW91c2VlbnRlcic9PT10JiZkKCdtb3VzZWxlYXZlJyxyKSwnZm9jdXMnPT09dCYmZCgnYmx1cicscCkpLGx9ZnVuY3Rpb24gcyh0LGUpe3ZhciBhPVl0LnJlZHVjZShmdW5jdGlvbihhLGkpe3ZhciBvPXQuZ2V0QXR0cmlidXRlKCdkYXRhLXRpcHB5LScraS50b0xvd2VyQ2FzZSgpKXx8ZVtpXTtyZXR1cm4nZmFsc2UnPT09byYmKG89ITEpLCd0cnVlJz09PW8mJihvPSEwKSxpc0Zpbml0ZShvKSYmIWlzTmFOKHBhcnNlRmxvYXQobykpJiYobz1wYXJzZUZsb2F0KG8pKSwndGFyZ2V0JyE9PWkmJidzdHJpbmcnPT10eXBlb2YgbyYmJ1snPT09by50cmltKCkuY2hhckF0KDApJiYobz1KU09OLnBhcnNlKG8pKSxhW2ldPW8sYX0se30pO3JldHVybiBJdCh7fSxlLGEpfWZ1bmN0aW9uIGwodCxlKXtyZXR1cm4gZS5hcnJvdyYmKGUuYW5pbWF0ZUZpbGw9ITEpLGUuYXBwZW5kVG8mJidmdW5jdGlvbic9PXR5cGVvZiBlLmFwcGVuZFRvJiYoZS5hcHBlbmRUbz1lLmFwcGVuZFRvKCkpLCdmdW5jdGlvbic9PXR5cGVvZiBlLmh0bWwmJihlLmh0bWw9ZS5odG1sKHQpKSxlfWZ1bmN0aW9uIGQodCl7cmV0dXJue3Rvb2x0aXA6dC5xdWVyeVNlbGVjdG9yKEN0LlRPT0xUSVApLGJhY2tkcm9wOnQucXVlcnlTZWxlY3RvcihDdC5CQUNLRFJPUCksY29udGVudDp0LnF1ZXJ5U2VsZWN0b3IoQ3QuQ09OVEVOVCl9fWZ1bmN0aW9uIGModCl7dmFyIGU9dC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7ZSYmdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnLGUpLHQucmVtb3ZlQXR0cmlidXRlKCd0aXRsZScpfWZ1bmN0aW9uIG0odCl7cmV0dXJuIHQmJidbb2JqZWN0IEZ1bmN0aW9uXSc9PT17fS50b1N0cmluZy5jYWxsKHQpfWZ1bmN0aW9uIGYodCxlKXtpZigxIT09dC5ub2RlVHlwZSlyZXR1cm5bXTt2YXIgYT1nZXRDb21wdXRlZFN0eWxlKHQsbnVsbCk7cmV0dXJuIGU/YVtlXTphfWZ1bmN0aW9uIGgodCl7cmV0dXJuJ0hUTUwnPT09dC5ub2RlTmFtZT90OnQucGFyZW50Tm9kZXx8dC5ob3N0fWZ1bmN0aW9uIGIodCl7aWYoIXQpcmV0dXJuIGRvY3VtZW50LmJvZHk7c3dpdGNoKHQubm9kZU5hbWUpe2Nhc2UnSFRNTCc6Y2FzZSdCT0RZJzpyZXR1cm4gdC5vd25lckRvY3VtZW50LmJvZHk7Y2FzZScjZG9jdW1lbnQnOnJldHVybiB0LmJvZHk7fXZhciBlPWYodCksYT1lLm92ZXJmbG93LGk9ZS5vdmVyZmxvd1gsbz1lLm92ZXJmbG93WTtyZXR1cm4gLyhhdXRvfHNjcm9sbCkvLnRlc3QoYStvK2kpP3Q6YihoKHQpKX1mdW5jdGlvbiB1KHQpe3ZhciBlPXQmJnQub2Zmc2V0UGFyZW50LGE9ZSYmZS5ub2RlTmFtZTtyZXR1cm4gYSYmJ0JPRFknIT09YSYmJ0hUTUwnIT09YT8tMSE9PVsnVEQnLCdUQUJMRSddLmluZGV4T2YoZS5ub2RlTmFtZSkmJidzdGF0aWMnPT09ZihlLCdwb3NpdGlvbicpP3UoZSk6ZTp0P3Qub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50fWZ1bmN0aW9uIHkodCl7dmFyIGU9dC5ub2RlTmFtZTtyZXR1cm4nQk9EWSchPT1lJiYoJ0hUTUwnPT09ZXx8dSh0LmZpcnN0RWxlbWVudENoaWxkKT09PXQpfWZ1bmN0aW9uIGcodCl7cmV0dXJuIG51bGw9PT10LnBhcmVudE5vZGU/dDpnKHQucGFyZW50Tm9kZSl9ZnVuY3Rpb24gdyh0LGUpe2lmKCF0fHwhdC5ub2RlVHlwZXx8IWV8fCFlLm5vZGVUeXBlKXJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7dmFyIGE9dC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlKSZOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyxpPWE/dDplLG89YT9lOnQscj1kb2N1bWVudC5jcmVhdGVSYW5nZSgpO3Iuc2V0U3RhcnQoaSwwKSxyLnNldEVuZChvLDApO3ZhciBwPXIuY29tbW9uQW5jZXN0b3JDb250YWluZXI7aWYodCE9PXAmJmUhPT1wfHxpLmNvbnRhaW5zKG8pKXJldHVybiB5KHApP3A6dShwKTt2YXIgbj1nKHQpO3JldHVybiBuLmhvc3Q/dyhuLmhvc3QsZSk6dyh0LGcoZSkuaG9zdCl9ZnVuY3Rpb24geCh0KXt2YXIgZT0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06J3RvcCcsYT0ndG9wJz09PWU/J3Njcm9sbFRvcCc6J3Njcm9sbExlZnQnLGk9dC5ub2RlTmFtZTtpZignQk9EWSc9PT1pfHwnSFRNTCc9PT1pKXt2YXIgbz10Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHI9dC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnR8fG87cmV0dXJuIHJbYV19cmV0dXJuIHRbYV19ZnVuY3Rpb24gdih0LGUpe3ZhciBhPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl0saT14KGUsJ3RvcCcpLG89eChlLCdsZWZ0Jykscj1hPy0xOjE7cmV0dXJuIHQudG9wKz1pKnIsdC5ib3R0b20rPWkqcix0LmxlZnQrPW8qcix0LnJpZ2h0Kz1vKnIsdH1mdW5jdGlvbiBrKHQsZSl7dmFyIGE9J3gnPT09ZT8nTGVmdCc6J1RvcCcsaT0nTGVmdCc9PWE/J1JpZ2h0JzonQm90dG9tJztyZXR1cm4gcGFyc2VGbG9hdCh0Wydib3JkZXInK2ErJ1dpZHRoJ10sMTApK3BhcnNlRmxvYXQodFsnYm9yZGVyJytpKydXaWR0aCddLDEwKX1mdW5jdGlvbiBFKHQsZSxhLGkpe3JldHVybiBMdChlWydvZmZzZXQnK3RdLGVbJ3Njcm9sbCcrdF0sYVsnY2xpZW50Jyt0XSxhWydvZmZzZXQnK3RdLGFbJ3Njcm9sbCcrdF0sQnQoKT9hWydvZmZzZXQnK3RdK2lbJ21hcmdpbicrKCdIZWlnaHQnPT09dD8nVG9wJzonTGVmdCcpXStpWydtYXJnaW4nKygnSGVpZ2h0Jz09PXQ/J0JvdHRvbSc6J1JpZ2h0JyldOjApfWZ1bmN0aW9uIEwoKXt2YXIgdD1kb2N1bWVudC5ib2R5LGU9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGE9QnQoKSYmZ2V0Q29tcHV0ZWRTdHlsZShlKTtyZXR1cm57aGVpZ2h0OkUoJ0hlaWdodCcsdCxlLGEpLHdpZHRoOkUoJ1dpZHRoJyx0LGUsYSl9fWZ1bmN0aW9uIE8odCl7cmV0dXJuIHF0KHt9LHQse3JpZ2h0OnQubGVmdCt0LndpZHRoLGJvdHRvbTp0LnRvcCt0LmhlaWdodH0pfWZ1bmN0aW9uIEEodCl7dmFyIGU9e307aWYoQnQoKSl0cnl7ZT10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3ZhciBhPXgodCwndG9wJyksaT14KHQsJ2xlZnQnKTtlLnRvcCs9YSxlLmxlZnQrPWksZS5ib3R0b20rPWEsZS5yaWdodCs9aX1jYXRjaCh0KXt9ZWxzZSBlPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dmFyIG89e2xlZnQ6ZS5sZWZ0LHRvcDplLnRvcCx3aWR0aDplLnJpZ2h0LWUubGVmdCxoZWlnaHQ6ZS5ib3R0b20tZS50b3B9LHI9J0hUTUwnPT09dC5ub2RlTmFtZT9MKCk6e30scD1yLndpZHRofHx0LmNsaWVudFdpZHRofHxvLnJpZ2h0LW8ubGVmdCxuPXIuaGVpZ2h0fHx0LmNsaWVudEhlaWdodHx8by5ib3R0b20tby50b3Ascz10Lm9mZnNldFdpZHRoLXAsbD10Lm9mZnNldEhlaWdodC1uO2lmKHN8fGwpe3ZhciBkPWYodCk7cy09ayhkLCd4JyksbC09ayhkLCd5Jyksby53aWR0aC09cyxvLmhlaWdodC09bH1yZXR1cm4gTyhvKX1mdW5jdGlvbiBDKHQsZSl7dmFyIGE9QnQoKSxpPSdIVE1MJz09PWUubm9kZU5hbWUsbz1BKHQpLHI9QShlKSxwPWIodCksbj1mKGUpLHM9cGFyc2VGbG9hdChuLmJvcmRlclRvcFdpZHRoLDEwKSxsPXBhcnNlRmxvYXQobi5ib3JkZXJMZWZ0V2lkdGgsMTApLGQ9Tyh7dG9wOm8udG9wLXIudG9wLXMsbGVmdDpvLmxlZnQtci5sZWZ0LWwsd2lkdGg6by53aWR0aCxoZWlnaHQ6by5oZWlnaHR9KTtpZihkLm1hcmdpblRvcD0wLGQubWFyZ2luTGVmdD0wLCFhJiZpKXt2YXIgYz1wYXJzZUZsb2F0KG4ubWFyZ2luVG9wLDEwKSxtPXBhcnNlRmxvYXQobi5tYXJnaW5MZWZ0LDEwKTtkLnRvcC09cy1jLGQuYm90dG9tLT1zLWMsZC5sZWZ0LT1sLW0sZC5yaWdodC09bC1tLGQubWFyZ2luVG9wPWMsZC5tYXJnaW5MZWZ0PW19cmV0dXJuKGE/ZS5jb250YWlucyhwKTplPT09cCYmJ0JPRFknIT09cC5ub2RlTmFtZSkmJihkPXYoZCxlKSksZH1mdW5jdGlvbiBTKHQpe3ZhciBlPXQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsYT1DKHQsZSksaT1MdChlLmNsaWVudFdpZHRoLHdpbmRvdy5pbm5lcldpZHRofHwwKSxvPUx0KGUuY2xpZW50SGVpZ2h0LHdpbmRvdy5pbm5lckhlaWdodHx8MCkscj14KGUpLHA9eChlLCdsZWZ0Jyksbj17dG9wOnItYS50b3ArYS5tYXJnaW5Ub3AsbGVmdDpwLWEubGVmdCthLm1hcmdpbkxlZnQsd2lkdGg6aSxoZWlnaHQ6b307cmV0dXJuIE8obil9ZnVuY3Rpb24gWSh0KXt2YXIgZT10Lm5vZGVOYW1lO3JldHVybidCT0RZJz09PWV8fCdIVE1MJz09PWU/ITE6J2ZpeGVkJz09PWYodCwncG9zaXRpb24nKXx8WShoKHQpKX1mdW5jdGlvbiBYKHQsZSxhLGkpe3ZhciBvPXt0b3A6MCxsZWZ0OjB9LHI9dyh0LGUpO2lmKCd2aWV3cG9ydCc9PT1pKW89UyhyKTtlbHNle3ZhciBwOydzY3JvbGxQYXJlbnQnPT09aT8ocD1iKGgoZSkpLCdCT0RZJz09PXAubm9kZU5hbWUmJihwPXQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKTond2luZG93Jz09PWk/cD10Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OnA9aTt2YXIgbj1DKHAscik7aWYoJ0hUTUwnPT09cC5ub2RlTmFtZSYmIVkocikpe3ZhciBzPUwoKSxsPXMuaGVpZ2h0LGQ9cy53aWR0aDtvLnRvcCs9bi50b3Atbi5tYXJnaW5Ub3Asby5ib3R0b209bCtuLnRvcCxvLmxlZnQrPW4ubGVmdC1uLm1hcmdpbkxlZnQsby5yaWdodD1kK24ubGVmdH1lbHNlIG89bn1yZXR1cm4gby5sZWZ0Kz1hLG8udG9wKz1hLG8ucmlnaHQtPWEsby5ib3R0b20tPWEsb31mdW5jdGlvbiBfKHQpe3ZhciBlPXQud2lkdGgsYT10LmhlaWdodDtyZXR1cm4gZSphfWZ1bmN0aW9uIEkodCxlLGEsaSxvKXt2YXIgcj01PGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1s1XT9hcmd1bWVudHNbNV06MDtpZigtMT09PXQuaW5kZXhPZignYXV0bycpKXJldHVybiB0O3ZhciBwPVgoYSxpLHIsbyksbj17dG9wOnt3aWR0aDpwLndpZHRoLGhlaWdodDplLnRvcC1wLnRvcH0scmlnaHQ6e3dpZHRoOnAucmlnaHQtZS5yaWdodCxoZWlnaHQ6cC5oZWlnaHR9LGJvdHRvbTp7d2lkdGg6cC53aWR0aCxoZWlnaHQ6cC5ib3R0b20tZS5ib3R0b219LGxlZnQ6e3dpZHRoOmUubGVmdC1wLmxlZnQsaGVpZ2h0OnAuaGVpZ2h0fX0scz1PYmplY3Qua2V5cyhuKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHF0KHtrZXk6dH0sblt0XSx7YXJlYTpfKG5bdF0pfSl9KS5zb3J0KGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuYXJlYS10LmFyZWF9KSxsPXMuZmlsdGVyKGZ1bmN0aW9uKHQpe3ZhciBlPXQud2lkdGgsaT10LmhlaWdodDtyZXR1cm4gZT49YS5jbGllbnRXaWR0aCYmaT49YS5jbGllbnRIZWlnaHR9KSxkPTA8bC5sZW5ndGg/bFswXS5rZXk6c1swXS5rZXksYz10LnNwbGl0KCctJylbMV07cmV0dXJuIGQrKGM/Jy0nK2M6JycpfWZ1bmN0aW9uIFAodCxlLGEpe3ZhciBpPXcoZSxhKTtyZXR1cm4gQyhhLGkpfWZ1bmN0aW9uIEQodCl7dmFyIGU9Z2V0Q29tcHV0ZWRTdHlsZSh0KSxhPXBhcnNlRmxvYXQoZS5tYXJnaW5Ub3ApK3BhcnNlRmxvYXQoZS5tYXJnaW5Cb3R0b20pLGk9cGFyc2VGbG9hdChlLm1hcmdpbkxlZnQpK3BhcnNlRmxvYXQoZS5tYXJnaW5SaWdodCksbz17d2lkdGg6dC5vZmZzZXRXaWR0aCtpLGhlaWdodDp0Lm9mZnNldEhlaWdodCthfTtyZXR1cm4gb31mdW5jdGlvbiBOKHQpe3ZhciBlPXtsZWZ0OidyaWdodCcscmlnaHQ6J2xlZnQnLGJvdHRvbTondG9wJyx0b3A6J2JvdHRvbSd9O3JldHVybiB0LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfSl9ZnVuY3Rpb24gSCh0LGUsYSl7YT1hLnNwbGl0KCctJylbMF07dmFyIGk9RCh0KSxvPXt3aWR0aDppLndpZHRoLGhlaWdodDppLmhlaWdodH0scj0tMSE9PVsncmlnaHQnLCdsZWZ0J10uaW5kZXhPZihhKSxwPXI/J3RvcCc6J2xlZnQnLG49cj8nbGVmdCc6J3RvcCcscz1yPydoZWlnaHQnOid3aWR0aCcsbD1yPyd3aWR0aCc6J2hlaWdodCc7cmV0dXJuIG9bcF09ZVtwXStlW3NdLzItaVtzXS8yLG9bbl09YT09PW4/ZVtuXS1pW2xdOmVbTihuKV0sb31mdW5jdGlvbiBSKHQsZSl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5maW5kP3QuZmluZChlKTp0LmZpbHRlcihlKVswXX1mdW5jdGlvbiBNKHQsZSxhKXtpZihBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KXJldHVybiB0LmZpbmRJbmRleChmdW5jdGlvbih0KXtyZXR1cm4gdFtlXT09PWF9KTt2YXIgaT1SKHQsZnVuY3Rpb24odCl7cmV0dXJuIHRbZV09PT1hfSk7cmV0dXJuIHQuaW5kZXhPZihpKX1mdW5jdGlvbiBCKHQsZSxhKXt2YXIgaT12b2lkIDA9PT1hP3Q6dC5zbGljZSgwLE0odCwnbmFtZScsYSkpO3JldHVybiBpLmZvckVhY2goZnVuY3Rpb24odCl7dFsnZnVuY3Rpb24nXSYmY29uc29sZS53YXJuKCdgbW9kaWZpZXIuZnVuY3Rpb25gIGlzIGRlcHJlY2F0ZWQsIHVzZSBgbW9kaWZpZXIuZm5gIScpO3ZhciBhPXRbJ2Z1bmN0aW9uJ118fHQuZm47dC5lbmFibGVkJiZtKGEpJiYoZS5vZmZzZXRzLnBvcHBlcj1PKGUub2Zmc2V0cy5wb3BwZXIpLGUub2Zmc2V0cy5yZWZlcmVuY2U9TyhlLm9mZnNldHMucmVmZXJlbmNlKSxlPWEoZSx0KSl9KSxlfWZ1bmN0aW9uIFcoKXtpZighdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCl7dmFyIHQ9e2luc3RhbmNlOnRoaXMsc3R5bGVzOnt9LGFycm93U3R5bGVzOnt9LGF0dHJpYnV0ZXM6e30sZmxpcHBlZDohMSxvZmZzZXRzOnt9fTt0Lm9mZnNldHMucmVmZXJlbmNlPVAodGhpcy5zdGF0ZSx0aGlzLnBvcHBlcix0aGlzLnJlZmVyZW5jZSksdC5wbGFjZW1lbnQ9SSh0aGlzLm9wdGlvbnMucGxhY2VtZW50LHQub2Zmc2V0cy5yZWZlcmVuY2UsdGhpcy5wb3BwZXIsdGhpcy5yZWZlcmVuY2UsdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKSx0Lm9yaWdpbmFsUGxhY2VtZW50PXQucGxhY2VtZW50LHQub2Zmc2V0cy5wb3BwZXI9SCh0aGlzLnBvcHBlcix0Lm9mZnNldHMucmVmZXJlbmNlLHQucGxhY2VtZW50KSx0Lm9mZnNldHMucG9wcGVyLnBvc2l0aW9uPSdhYnNvbHV0ZScsdD1CKHRoaXMubW9kaWZpZXJzLHQpLHRoaXMuc3RhdGUuaXNDcmVhdGVkP3RoaXMub3B0aW9ucy5vblVwZGF0ZSh0KToodGhpcy5zdGF0ZS5pc0NyZWF0ZWQ9ITAsdGhpcy5vcHRpb25zLm9uQ3JlYXRlKHQpKX19ZnVuY3Rpb24geih0LGUpe3JldHVybiB0LnNvbWUoZnVuY3Rpb24odCl7dmFyIGE9dC5uYW1lLGk9dC5lbmFibGVkO3JldHVybiBpJiZhPT09ZX0pfWZ1bmN0aW9uIFUodCl7Zm9yKHZhciBlPVshMSwnbXMnLCdXZWJraXQnLCdNb3onLCdPJ10sYT10LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSksbz0wO288ZS5sZW5ndGgtMTtvKyspe3ZhciBpPWVbb10scj1pPycnK2krYTp0O2lmKCd1bmRlZmluZWQnIT10eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVtyXSlyZXR1cm4gcn1yZXR1cm4gbnVsbH1mdW5jdGlvbiBxKCl7cmV0dXJuIHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQ9ITAseih0aGlzLm1vZGlmaWVycywnYXBwbHlTdHlsZScpJiYodGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpLHRoaXMucG9wcGVyLnN0eWxlLmxlZnQ9JycsdGhpcy5wb3BwZXIuc3R5bGUucG9zaXRpb249JycsdGhpcy5wb3BwZXIuc3R5bGUudG9wPScnLHRoaXMucG9wcGVyLnN0eWxlW1UoJ3RyYW5zZm9ybScpXT0nJyksdGhpcy5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSx0aGlzLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95JiZ0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKSx0aGlzfWZ1bmN0aW9uIEYodCl7dmFyIGU9dC5vd25lckRvY3VtZW50O3JldHVybiBlP2UuZGVmYXVsdFZpZXc6d2luZG93fWZ1bmN0aW9uIGoodCxlLGEsaSl7dmFyIG89J0JPRFknPT09dC5ub2RlTmFtZSxyPW8/dC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3OnQ7ci5hZGRFdmVudExpc3RlbmVyKGUsYSx7cGFzc2l2ZTohMH0pLG98fGooYihyLnBhcmVudE5vZGUpLGUsYSxpKSxpLnB1c2gocil9ZnVuY3Rpb24gSyh0LGUsYSxpKXthLnVwZGF0ZUJvdW5kPWksRih0KS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLGEudXBkYXRlQm91bmQse3Bhc3NpdmU6ITB9KTt2YXIgbz1iKHQpO3JldHVybiBqKG8sJ3Njcm9sbCcsYS51cGRhdGVCb3VuZCxhLnNjcm9sbFBhcmVudHMpLGEuc2Nyb2xsRWxlbWVudD1vLGEuZXZlbnRzRW5hYmxlZD0hMCxhfWZ1bmN0aW9uIFYoKXt0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWR8fCh0aGlzLnN0YXRlPUsodGhpcy5yZWZlcmVuY2UsdGhpcy5vcHRpb25zLHRoaXMuc3RhdGUsdGhpcy5zY2hlZHVsZVVwZGF0ZSkpfWZ1bmN0aW9uIEcodCxlKXtyZXR1cm4gRih0KS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLGUudXBkYXRlQm91bmQpLGUuc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJyxlLnVwZGF0ZUJvdW5kKX0pLGUudXBkYXRlQm91bmQ9bnVsbCxlLnNjcm9sbFBhcmVudHM9W10sZS5zY3JvbGxFbGVtZW50PW51bGwsZS5ldmVudHNFbmFibGVkPSExLGV9ZnVuY3Rpb24gUSgpe3RoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCYmKGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2NoZWR1bGVVcGRhdGUpLHRoaXMuc3RhdGU9Ryh0aGlzLnJlZmVyZW5jZSx0aGlzLnN0YXRlKSl9ZnVuY3Rpb24gSih0KXtyZXR1cm4nJyE9PXQmJiFpc05hTihwYXJzZUZsb2F0KHQpKSYmaXNGaW5pdGUodCl9ZnVuY3Rpb24gWih0LGUpe09iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGk9Jyc7LTEhPT1bJ3dpZHRoJywnaGVpZ2h0JywndG9wJywncmlnaHQnLCdib3R0b20nLCdsZWZ0J10uaW5kZXhPZihhKSYmSihlW2FdKSYmKGk9J3B4JyksdC5zdHlsZVthXT1lW2FdK2l9KX1mdW5jdGlvbiAkKHQsZSl7T2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgaT1lW2FdOyExPT09aT90LnJlbW92ZUF0dHJpYnV0ZShhKTp0LnNldEF0dHJpYnV0ZShhLGVbYV0pfSl9ZnVuY3Rpb24gdHQodCxlLGEpe3ZhciBpPVIodCxmdW5jdGlvbih0KXt2YXIgYT10Lm5hbWU7cmV0dXJuIGE9PT1lfSksbz0hIWkmJnQuc29tZShmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lPT09YSYmdC5lbmFibGVkJiZ0Lm9yZGVyPGkub3JkZXJ9KTtpZighbyl7dmFyIHI9J2AnK2UrJ2AnO2NvbnNvbGUud2FybignYCcrYSsnYCcrJyBtb2RpZmllciBpcyByZXF1aXJlZCBieSAnK3IrJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcrcisnIScpfXJldHVybiBvfWZ1bmN0aW9uIGV0KHQpe3JldHVybidlbmQnPT09dD8nc3RhcnQnOidzdGFydCc9PT10PydlbmQnOnR9ZnVuY3Rpb24gYXQodCl7dmFyIGU9MTxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXSxhPWp0LmluZGV4T2YodCksaT1qdC5zbGljZShhKzEpLmNvbmNhdChqdC5zbGljZSgwLGEpKTtyZXR1cm4gZT9pLnJldmVyc2UoKTppfWZ1bmN0aW9uIGl0KHQsZSxhLGkpe3ZhciBvPXQubWF0Y2goLygoPzpcXC18XFwrKT9cXGQqXFwuP1xcZCopKC4qKS8pLHI9K29bMV0scD1vWzJdO2lmKCFyKXJldHVybiB0O2lmKDA9PT1wLmluZGV4T2YoJyUnKSl7dmFyIG47c3dpdGNoKHApe2Nhc2UnJXAnOm49YTticmVhaztjYXNlJyUnOmNhc2UnJXInOmRlZmF1bHQ6bj1pO312YXIgcz1PKG4pO3JldHVybiBzW2VdLzEwMCpyfWlmKCd2aCc9PT1wfHwndncnPT09cCl7dmFyIGw7cmV0dXJuIGw9J3ZoJz09PXA/THQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCx3aW5kb3cuaW5uZXJIZWlnaHR8fDApOkx0KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCx3aW5kb3cuaW5uZXJXaWR0aHx8MCksbC8xMDAqcn1yZXR1cm4gcn1mdW5jdGlvbiBvdCh0LGUsYSxpKXt2YXIgbz1bMCwwXSxyPS0xIT09WydyaWdodCcsJ2xlZnQnXS5pbmRleE9mKGkpLHA9dC5zcGxpdCgvKFxcK3xcXC0pLykubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRyaW0oKX0pLG49cC5pbmRleE9mKFIocCxmdW5jdGlvbih0KXtyZXR1cm4tMSE9PXQuc2VhcmNoKC8sfFxccy8pfSkpO3Bbbl0mJi0xPT09cFtuXS5pbmRleE9mKCcsJykmJmNvbnNvbGUud2FybignT2Zmc2V0cyBzZXBhcmF0ZWQgYnkgd2hpdGUgc3BhY2UocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhIGNvbW1hICgsKSBpbnN0ZWFkLicpO3ZhciBzPS9cXHMqLFxccyp8XFxzKy8sbD0tMT09PW4/W3BdOltwLnNsaWNlKDAsbikuY29uY2F0KFtwW25dLnNwbGl0KHMpWzBdXSksW3Bbbl0uc3BsaXQocylbMV0scC5zbGljZShuKzEpXV07cmV0dXJuIGw9bC5tYXAoZnVuY3Rpb24odCxpKXt2YXIgbz0oMT09PWk/IXI6cik/J2hlaWdodCc6J3dpZHRoJyxwPSExO3JldHVybiB0LnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybicnPT09dFt0Lmxlbmd0aC0xXSYmLTEhPT1bJysnLCctJ10uaW5kZXhPZihlKT8odFt0Lmxlbmd0aC0xXT1lLHA9ITAsdCk6cD8odFt0Lmxlbmd0aC0xXSs9ZSxwPSExLHQpOnQuY29uY2F0KGUpfSxbXSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBpdCh0LG8sZSxhKX0pfSksbC5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7dC5mb3JFYWNoKGZ1bmN0aW9uKGEsaSl7SihhKSYmKG9bZV0rPWEqKCctJz09PXRbaS0xXT8tMToxKSl9KX0pLG99ZnVuY3Rpb24gcnQodCl7cmV0dXJuIHQuZ2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcpLnJlcGxhY2UoLy0uKy8sJycpfWZ1bmN0aW9uIHB0KHQsZSxhKXtpZighZS5nZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JykpcmV0dXJuITA7dmFyIGk9dC5jbGllbnRYLG89dC5jbGllbnRZLHI9YS5pbnRlcmFjdGl2ZUJvcmRlcixwPWEuZGlzdGFuY2Usbj1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHM9cnQoZSksbD1yK3AsZD17dG9wOm4udG9wLW8+cixib3R0b206by1uLmJvdHRvbT5yLGxlZnQ6bi5sZWZ0LWk+cixyaWdodDppLW4ucmlnaHQ+cn07cmV0dXJuJ3RvcCc9PT1zP2QudG9wPW4udG9wLW8+bDonYm90dG9tJz09PXM/ZC5ib3R0b209by1uLmJvdHRvbT5sOidsZWZ0Jz09PXM/ZC5sZWZ0PW4ubGVmdC1pPmw6J3JpZ2h0Jz09PXM/ZC5yaWdodD1pLW4ucmlnaHQ+bDp2b2lkIDAsZC50b3B8fGQuYm90dG9tfHxkLmxlZnR8fGQucmlnaHR9ZnVuY3Rpb24gbnQodCxlLGEsaSl7aWYoIWUubGVuZ3RoKXJldHVybicnO3ZhciBvPXtzY2FsZTpmdW5jdGlvbigpe3JldHVybiAxPT09ZS5sZW5ndGg/JycrZVswXTphP2VbMF0rJywgJytlWzFdOmVbMV0rJywgJytlWzBdfSgpLHRyYW5zbGF0ZTpmdW5jdGlvbigpe3JldHVybiAxPT09ZS5sZW5ndGg/aT8tZVswXSsncHgnOmVbMF0rJ3B4JzphP2k/ZVswXSsncHgsICcrLWVbMV0rJ3B4JzplWzBdKydweCwgJytlWzFdKydweCc6aT8tZVsxXSsncHgsICcrZVswXSsncHgnOmVbMV0rJ3B4LCAnK2VbMF0rJ3B4J30oKX07cmV0dXJuIG9bdF19ZnVuY3Rpb24gc3QodCxlKXtpZighdClyZXR1cm4nJztyZXR1cm4gZT90OntYOidZJyxZOidYJ31bdF19ZnVuY3Rpb24gbHQodCxlLGEpe3ZhciBpPXJ0KHQpLG89J3RvcCc9PT1pfHwnYm90dG9tJz09PWkscD0ncmlnaHQnPT09aXx8J2JvdHRvbSc9PT1pLG49ZnVuY3Rpb24odCl7dmFyIGU9YS5tYXRjaCh0KTtyZXR1cm4gZT9lWzFdOicnfSxzPWZ1bmN0aW9uKHQpe3ZhciBlPWEubWF0Y2godCk7cmV0dXJuIGU/ZVsxXS5zcGxpdCgnLCcpLm1hcChwYXJzZUZsb2F0KTpbXX0sbD17dHJhbnNsYXRlOi90cmFuc2xhdGVYP1k/XFwoKFteKV0rKVxcKS8sc2NhbGU6L3NjYWxlWD9ZP1xcKChbXildKylcXCkvfSxkPXt0cmFuc2xhdGU6e2F4aXM6bigvdHJhbnNsYXRlKFtYWV0pLyksbnVtYmVyczpzKGwudHJhbnNsYXRlKX0sc2NhbGU6e2F4aXM6bigvc2NhbGUoW1hZXSkvKSxudW1iZXJzOnMobC5zY2FsZSl9fSxjPWEucmVwbGFjZShsLnRyYW5zbGF0ZSwndHJhbnNsYXRlJytzdChkLnRyYW5zbGF0ZS5heGlzLG8pKycoJytudCgndHJhbnNsYXRlJyxkLnRyYW5zbGF0ZS5udW1iZXJzLG8scCkrJyknKS5yZXBsYWNlKGwuc2NhbGUsJ3NjYWxlJytzdChkLnNjYWxlLmF4aXMsbykrJygnK250KCdzY2FsZScsZC5zY2FsZS5udW1iZXJzLG8scCkrJyknKTtlLnN0eWxlW3IoJ3RyYW5zZm9ybScpXT1jfWZ1bmN0aW9uIGR0KHQpe3JldHVybi0odC1TdC5kaXN0YW5jZSkrJ3B4J31mdW5jdGlvbiBjdCh0KXtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KHQsMSl9KX1mdW5jdGlvbiBtdCh0LGEpe3ZhciBpPUVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3R8fGZ1bmN0aW9uKHQpe2Zvcih2YXIgYT10aGlzO2E7KXtpZihlLmNhbGwoYSx0KSlyZXR1cm4gYTthPWEucGFyZW50RWxlbWVudH19O3JldHVybiBpLmNhbGwodCxhKX1mdW5jdGlvbiBmdCh0LGUpe3JldHVybiBBcnJheS5pc0FycmF5KHQpP3RbZV06dH1mdW5jdGlvbiBodCh0LGUpe3QuZm9yRWFjaChmdW5jdGlvbih0KXt0JiZ0LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsZSl9KX1mdW5jdGlvbiBidCh0LGUpe3QuZm9yRWFjaChmdW5jdGlvbih0KXt0JiYodC5zdHlsZVtyKCd0cmFuc2l0aW9uRHVyYXRpb24nKV09ZSsnbXMnKX0pfWZ1bmN0aW9uIHV0KHQpe3ZvaWQgdC5vZmZzZXRIZWlnaHR9ZnVuY3Rpb24geXQodCl7dmFyIGU9d2luZG93LnNjcm9sbFh8fHdpbmRvdy5wYWdlWE9mZnNldCxhPXdpbmRvdy5zY3JvbGxZfHx3aW5kb3cucGFnZVlPZmZzZXQ7dC5mb2N1cygpLHNjcm9sbChlLGEpfWZ1bmN0aW9uIGd0KHQsZSl7cmV0dXJuIHQucmVkdWNlKGZ1bmN0aW9uKHQsYSl7dmFyIGk9ZWUsbz1sKGEsZS5wZXJmb3JtYW5jZT9lOnMoYSxlKSkscj1hLmdldEF0dHJpYnV0ZSgndGl0bGUnKTtpZighciYmIW8udGFyZ2V0JiYhby5odG1sJiYhby5keW5hbWljVGl0bGUpcmV0dXJuIHQ7YS5zZXRBdHRyaWJ1dGUoby50YXJnZXQ/J2RhdGEtdGlwcHktZGVsZWdhdGUnOidkYXRhLXRpcHB5JywnJyksYyhhKTt2YXIgbT1wKGkscixvKSxmPW5ldyBUKHtpZDppLHJlZmVyZW5jZTphLHBvcHBlcjptLG9wdGlvbnM6byx0aXRsZTpyLHBvcHBlckluc3RhbmNlOm51bGx9KTtvLmNyZWF0ZVBvcHBlckluc3RhbmNlT25Jbml0JiYoZi5wb3BwZXJJbnN0YW5jZT0kdC5jYWxsKGYpLGYucG9wcGVySW5zdGFuY2UuZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCkpO3ZhciBoPVp0LmNhbGwoZik7cmV0dXJuIGYubGlzdGVuZXJzPW8udHJpZ2dlci50cmltKCkuc3BsaXQoJyAnKS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jb25jYXQobihlLGEsaCxvKSl9LFtdKSxvLmR5bmFtaWNUaXRsZSYmdGUuY2FsbChmLHt0YXJnZXQ6YSxjYWxsYmFjazpmdW5jdGlvbigpe3ZhciB0PWQobSksZT10LmNvbnRlbnQsaT1hLmdldEF0dHJpYnV0ZSgndGl0bGUnKTtpJiYoZS5pbm5lckhUTUw9Zi50aXRsZT1pLGMoYSkpfSxvcHRpb25zOnthdHRyaWJ1dGVzOiEwfX0pLGEuX3RpcHB5PWYsbS5fdGlwcHk9ZixtLl9yZWZlcmVuY2U9YSx0LnB1c2goZiksZWUrKyx0fSxbXSl9ZnVuY3Rpb24gd3QodCl7dmFyIGU9YShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKEN0LlBPUFBFUikpO2UuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgYT1lLl90aXBweSxpPWEub3B0aW9uczsoITA9PT1pLmhpZGVPbkNsaWNrfHwtMTxpLnRyaWdnZXIuaW5kZXhPZignZm9jdXMnKSkmJighdHx8ZSE9PXQucG9wcGVyKSYmYS5oaWRlKCl9KX1mdW5jdGlvbiB4dCgpe3ZhciB0PWZ1bmN0aW9uKCl7QXQudXNpbmdUb3VjaHx8KEF0LnVzaW5nVG91Y2g9ITAsQXQuaU9TJiZkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ3RpcHB5LXRvdWNoJyksQXQuZHluYW1pY0lucHV0RGV0ZWN0aW9uJiZ3aW5kb3cucGVyZm9ybWFuY2UmJmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsYSksQXQub25Vc2VySW5wdXRDaGFuZ2UoJ3RvdWNoJykpfSxhPWZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9cGVyZm9ybWFuY2Uubm93KCk7MjA+ZS10JiYoQXQudXNpbmdUb3VjaD0hMSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLGEpLCFBdC5pT1MmJmRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgndGlwcHktdG91Y2gnKSxBdC5vblVzZXJJbnB1dENoYW5nZSgnbW91c2UnKSksdD1lfX0oKTtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24odCl7aWYoISh0LnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpKXJldHVybiB3dCgpO3ZhciBlPW10KHQudGFyZ2V0LEN0LlJFRkVSRU5DRSksYT1tdCh0LnRhcmdldCxDdC5QT1BQRVIpO2lmKCEoYSYmYS5fcmVmZXJlbmNlLl90aXBweS5vcHRpb25zLmludGVyYWN0aXZlKSl7aWYoZSl7dmFyIGk9ZS5fdGlwcHkub3B0aW9ucztpZighaS5tdWx0aXBsZSYmQXQudXNpbmdUb3VjaHx8IWkubXVsdGlwbGUmJi0xPGkudHJpZ2dlci5pbmRleE9mKCdjbGljaycpKXJldHVybiB3dChlLl90aXBweSk7aWYoITAhPT1pLmhpZGVPbkNsaWNrfHwtMTxpLnRyaWdnZXIuaW5kZXhPZignY2xpY2snKSlyZXR1cm59d3QoKX19KSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jyx0KSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsZnVuY3Rpb24oKXt2YXIgdD1kb2N1bWVudCxhPXQuYWN0aXZlRWxlbWVudDthJiZhLmJsdXImJmUuY2FsbChhLEN0LlJFRkVSRU5DRSkmJmEuYmx1cigpfSksIUF0LnN1cHBvcnRzVG91Y2gmJihuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHN8fG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzKSYmZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLHQpfWZ1bmN0aW9uIHZ0KGUsYSl7cmV0dXJuIEF0LnN1cHBvcnRlZCYmIUF0Ll9ldmVudExpc3RlbmVyc0JvdW5kJiYoeHQoKSxBdC5fZXZlbnRMaXN0ZW5lcnNCb3VuZD0hMCksdChlKSYmKGUucmVmT2JqPSEwLGUuYXR0cmlidXRlcz1lLmF0dHJpYnV0ZXN8fHt9LGUuc2V0QXR0cmlidXRlPWZ1bmN0aW9uKHQsYSl7ZS5hdHRyaWJ1dGVzW3RdPWF9LGUuZ2V0QXR0cmlidXRlPWZ1bmN0aW9uKHQpe3JldHVybiBlLmF0dHJpYnV0ZXNbdF19LGUucmVtb3ZlQXR0cmlidXRlPWZ1bmN0aW9uKHQpe2RlbGV0ZSBlLmF0dHJpYnV0ZXNbdF19LGUuYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbigpe30sZS5yZW1vdmVFdmVudExpc3RlbmVyPWZ1bmN0aW9uKCl7fSxlLmNsYXNzTGlzdD17Y2xhc3NOYW1lczp7fSxhZGQ6ZnVuY3Rpb24odCl7cmV0dXJuIGUuY2xhc3NMaXN0LmNsYXNzTmFtZXNbdF09ITB9LHJlbW92ZTpmdW5jdGlvbih0KXtyZXR1cm4gZGVsZXRlIGUuY2xhc3NMaXN0LmNsYXNzTmFtZXNbdF0sITB9LGNvbnRhaW5zOmZ1bmN0aW9uKHQpe3JldHVybiEhZS5jbGFzc0xpc3QuY2xhc3NOYW1lc1t0XX19KSxhPUl0KHt9LFN0LGEpLHtzZWxlY3RvcjplLG9wdGlvbnM6YSx0b29sdGlwczpBdC5zdXBwb3J0ZWQ/Z3QobyhlKSxhKTpbXSxkZXN0cm95QWxsOmZ1bmN0aW9uKCl7dGhpcy50b29sdGlwcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRlc3Ryb3koKX0pLHRoaXMudG9vbHRpcHM9W119fX12YXIga3Q9TWF0aC5yb3VuZCxFdD1NYXRoLm1pbixUdD1NYXRoLmZsb29yLEx0PU1hdGgubWF4LE90PSd1bmRlZmluZWQnIT10eXBlb2Ygd2luZG93LEF0PXt9O090JiYoQXQuc3VwcG9ydGVkPSdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnaW4gd2luZG93LEF0LnN1cHBvcnRzVG91Y2g9J29udG91Y2hzdGFydCdpbiB3aW5kb3csQXQudXNpbmdUb3VjaD0hMSxBdC5keW5hbWljSW5wdXREZXRlY3Rpb249ITAsQXQuaU9TPS9pUGhvbmV8aVBhZHxpUG9kLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkmJiF3aW5kb3cuTVNTdHJlYW0sQXQub25Vc2VySW5wdXRDaGFuZ2U9ZnVuY3Rpb24oKXt9LEF0Ll9ldmVudExpc3RlbmVyc0JvdW5kPSExKTtmb3IodmFyIEN0PXtQT1BQRVI6Jy50aXBweS1wb3BwZXInLFRPT0xUSVA6Jy50aXBweS10b29sdGlwJyxDT05URU5UOicudGlwcHktY29udGVudCcsQkFDS0RST1A6Jy50aXBweS1iYWNrZHJvcCcsQVJST1c6Jy50aXBweS1hcnJvdycsUk9VTkRfQVJST1c6Jy50aXBweS1yb3VuZGFycm93JyxSRUZFUkVOQ0U6J1tkYXRhLXRpcHB5XSd9LFN0PXtwbGFjZW1lbnQ6J3RvcCcsdHJpZ2dlcjonbW91c2VlbnRlciBmb2N1cycsYW5pbWF0aW9uOidzaGlmdC1hd2F5JyxodG1sOiExLGFuaW1hdGVGaWxsOiEwLGFycm93OiExLGRlbGF5OjAsZHVyYXRpb246WzM1MCwzMDBdLGludGVyYWN0aXZlOiExLGludGVyYWN0aXZlQm9yZGVyOjIsdGhlbWU6J2RhcmsnLHNpemU6J3JlZ3VsYXInLGRpc3RhbmNlOjEwLG9mZnNldDowLGhpZGVPbkNsaWNrOiEwLG11bHRpcGxlOiExLGZvbGxvd0N1cnNvcjohMSxpbmVydGlhOiExLHVwZGF0ZUR1cmF0aW9uOjM1MCxzdGlja3k6ITEsYXBwZW5kVG86ZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuYm9keX0sekluZGV4Ojk5OTksdG91Y2hIb2xkOiExLHBlcmZvcm1hbmNlOiExLGR5bmFtaWNUaXRsZTohMSxmbGlwOiEwLGZsaXBCZWhhdmlvcjonZmxpcCcsYXJyb3dUeXBlOidzaGFycCcsYXJyb3dUcmFuc2Zvcm06JycsbWF4V2lkdGg6JycsdGFyZ2V0Om51bGwscG9wcGVyT3B0aW9uczp7fSxjcmVhdGVQb3BwZXJJbnN0YW5jZU9uSW5pdDohMSxvblNob3c6ZnVuY3Rpb24oKXt9LG9uU2hvd246ZnVuY3Rpb24oKXt9LG9uSGlkZTpmdW5jdGlvbigpe30sb25IaWRkZW46ZnVuY3Rpb24oKXt9fSxZdD1BdC5zdXBwb3J0ZWQmJk9iamVjdC5rZXlzKFN0KSxYdD1mdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpfSxfdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGEsbz0wO288ZS5sZW5ndGg7bysrKWE9ZVtvXSxhLmVudW1lcmFibGU9YS5lbnVtZXJhYmxlfHwhMSxhLmNvbmZpZ3VyYWJsZT0hMCwoJ3ZhbHVlJ2luIGEpJiYoYS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsYS5rZXksYSl9cmV0dXJuIGZ1bmN0aW9uKGUsYSxpKXtyZXR1cm4gYSYmdChlLnByb3RvdHlwZSxhKSxpJiZ0KGUsaSksZX19KCksSXQ9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24odCl7Zm9yKHZhciBlLGE9MTthPGFyZ3VtZW50cy5sZW5ndGg7YSsrKWZvcih2YXIgaSBpbiBlPWFyZ3VtZW50c1thXSxlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLGkpJiYodFtpXT1lW2ldKTtyZXR1cm4gdH0sUHQ9J3VuZGVmaW5lZCchPXR5cGVvZiB3aW5kb3cmJid1bmRlZmluZWQnIT10eXBlb2YgZG9jdW1lbnQsRHQ9WydFZGdlJywnVHJpZGVudCcsJ0ZpcmVmb3gnXSxOdD0wLEh0PTA7SHQ8RHQubGVuZ3RoO0h0Kz0xKWlmKFB0JiYwPD1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoRHRbSHRdKSl7TnQ9MTticmVha312YXIgaSxSdD1QdCYmd2luZG93LlByb21pc2UsTXQ9UnQ/ZnVuY3Rpb24odCl7dmFyIGU9ITE7cmV0dXJuIGZ1bmN0aW9uKCl7ZXx8KGU9ITAsd2luZG93LlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKXtlPSExLHQoKX0pKX19OmZ1bmN0aW9uKHQpe3ZhciBlPSExO3JldHVybiBmdW5jdGlvbigpe2V8fChlPSEwLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlPSExLHQoKX0sTnQpKX19LEJ0PWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09aSYmKGk9LTEhPT1uYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCdNU0lFIDEwJykpLGl9LFd0PWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyl9LHp0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgYSxvPTA7bzxlLmxlbmd0aDtvKyspYT1lW29dLGEuZW51bWVyYWJsZT1hLmVudW1lcmFibGV8fCExLGEuY29uZmlndXJhYmxlPSEwLCd2YWx1ZSdpbiBhJiYoYS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsYS5rZXksYSl9cmV0dXJuIGZ1bmN0aW9uKGUsYSxpKXtyZXR1cm4gYSYmdChlLnByb3RvdHlwZSxhKSxpJiZ0KGUsaSksZX19KCksVXQ9ZnVuY3Rpb24odCxlLGEpe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6YSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09YSx0fSxxdD1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIGUsYT0xO2E8YXJndW1lbnRzLmxlbmd0aDthKyspZm9yKHZhciBpIGluIGU9YXJndW1lbnRzW2FdLGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsaSkmJih0W2ldPWVbaV0pO3JldHVybiB0fSxGdD1bJ2F1dG8tc3RhcnQnLCdhdXRvJywnYXV0by1lbmQnLCd0b3Atc3RhcnQnLCd0b3AnLCd0b3AtZW5kJywncmlnaHQtc3RhcnQnLCdyaWdodCcsJ3JpZ2h0LWVuZCcsJ2JvdHRvbS1lbmQnLCdib3R0b20nLCdib3R0b20tc3RhcnQnLCdsZWZ0LWVuZCcsJ2xlZnQnLCdsZWZ0LXN0YXJ0J10sanQ9RnQuc2xpY2UoMyksS3Q9e0ZMSVA6J2ZsaXAnLENMT0NLV0lTRTonY2xvY2t3aXNlJyxDT1VOVEVSQ0xPQ0tXSVNFOidjb3VudGVyY2xvY2t3aXNlJ30sVnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsYSl7dmFyIGk9dGhpcyxvPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7fTtXdCh0aGlzLHQpLHRoaXMuc2NoZWR1bGVVcGRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGkudXBkYXRlKX0sdGhpcy51cGRhdGU9TXQodGhpcy51cGRhdGUuYmluZCh0aGlzKSksdGhpcy5vcHRpb25zPXF0KHt9LHQuRGVmYXVsdHMsbyksdGhpcy5zdGF0ZT17aXNEZXN0cm95ZWQ6ITEsaXNDcmVhdGVkOiExLHNjcm9sbFBhcmVudHM6W119LHRoaXMucmVmZXJlbmNlPWUmJmUuanF1ZXJ5P2VbMF06ZSx0aGlzLnBvcHBlcj1hJiZhLmpxdWVyeT9hWzBdOmEsdGhpcy5vcHRpb25zLm1vZGlmaWVycz17fSxPYmplY3Qua2V5cyhxdCh7fSx0LkRlZmF1bHRzLm1vZGlmaWVycyxvLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24oZSl7aS5vcHRpb25zLm1vZGlmaWVyc1tlXT1xdCh7fSx0LkRlZmF1bHRzLm1vZGlmaWVyc1tlXXx8e30sby5tb2RpZmllcnM/by5tb2RpZmllcnNbZV06e30pfSksdGhpcy5tb2RpZmllcnM9T2JqZWN0LmtleXModGhpcy5vcHRpb25zLm1vZGlmaWVycykubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBxdCh7bmFtZTp0fSxpLm9wdGlvbnMubW9kaWZpZXJzW3RdKX0pLnNvcnQoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5vcmRlci1lLm9yZGVyfSksdGhpcy5tb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbih0KXt0LmVuYWJsZWQmJm0odC5vbkxvYWQpJiZ0Lm9uTG9hZChpLnJlZmVyZW5jZSxpLnBvcHBlcixpLm9wdGlvbnMsdCxpLnN0YXRlKX0pLHRoaXMudXBkYXRlKCk7dmFyIHI9dGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7ciYmdGhpcy5lbmFibGVFdmVudExpc3RlbmVycygpLHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZD1yfXJldHVybiB6dCh0LFt7a2V5Oid1cGRhdGUnLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIFcuY2FsbCh0aGlzKX19LHtrZXk6J2Rlc3Ryb3knLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHEuY2FsbCh0aGlzKX19LHtrZXk6J2VuYWJsZUV2ZW50TGlzdGVuZXJzJyx2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBWLmNhbGwodGhpcyl9fSx7a2V5OidkaXNhYmxlRXZlbnRMaXN0ZW5lcnMnLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIFEuY2FsbCh0aGlzKX19XSksdH0oKTtWdC5VdGlscz0oJ3VuZGVmaW5lZCc9PXR5cGVvZiB3aW5kb3c/Z2xvYmFsOndpbmRvdykuUG9wcGVyVXRpbHMsVnQucGxhY2VtZW50cz1GdCxWdC5EZWZhdWx0cz17cGxhY2VtZW50Oidib3R0b20nLGV2ZW50c0VuYWJsZWQ6ITAscmVtb3ZlT25EZXN0cm95OiExLG9uQ3JlYXRlOmZ1bmN0aW9uKCl7fSxvblVwZGF0ZTpmdW5jdGlvbigpe30sbW9kaWZpZXJzOntzaGlmdDp7b3JkZXI6MTAwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24odCl7dmFyIGU9dC5wbGFjZW1lbnQsYT1lLnNwbGl0KCctJylbMF0saT1lLnNwbGl0KCctJylbMV07aWYoaSl7dmFyIG89dC5vZmZzZXRzLHI9by5yZWZlcmVuY2UscD1vLnBvcHBlcixuPS0xIT09Wydib3R0b20nLCd0b3AnXS5pbmRleE9mKGEpLHM9bj8nbGVmdCc6J3RvcCcsbD1uPyd3aWR0aCc6J2hlaWdodCcsZD17c3RhcnQ6VXQoe30scyxyW3NdKSxlbmQ6VXQoe30scyxyW3NdK3JbbF0tcFtsXSl9O3Qub2Zmc2V0cy5wb3BwZXI9cXQoe30scCxkW2ldKX1yZXR1cm4gdH19LG9mZnNldDp7b3JkZXI6MjAwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24odCxlKXt2YXIgYSxpPWUub2Zmc2V0LG89dC5wbGFjZW1lbnQscj10Lm9mZnNldHMscD1yLnBvcHBlcixuPXIucmVmZXJlbmNlLHM9by5zcGxpdCgnLScpWzBdO3JldHVybiBhPUooK2kpP1sraSwwXTpvdChpLHAsbixzKSwnbGVmdCc9PT1zPyhwLnRvcCs9YVswXSxwLmxlZnQtPWFbMV0pOidyaWdodCc9PT1zPyhwLnRvcCs9YVswXSxwLmxlZnQrPWFbMV0pOid0b3AnPT09cz8ocC5sZWZ0Kz1hWzBdLHAudG9wLT1hWzFdKTonYm90dG9tJz09PXMmJihwLmxlZnQrPWFbMF0scC50b3ArPWFbMV0pLHQucG9wcGVyPXAsdH0sb2Zmc2V0OjB9LHByZXZlbnRPdmVyZmxvdzp7b3JkZXI6MzAwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24odCxlKXt2YXIgYT1lLmJvdW5kYXJpZXNFbGVtZW50fHx1KHQuaW5zdGFuY2UucG9wcGVyKTt0Lmluc3RhbmNlLnJlZmVyZW5jZT09PWEmJihhPXUoYSkpO3ZhciBpPVgodC5pbnN0YW5jZS5wb3BwZXIsdC5pbnN0YW5jZS5yZWZlcmVuY2UsZS5wYWRkaW5nLGEpO2UuYm91bmRhcmllcz1pO3ZhciBvPWUucHJpb3JpdHkscj10Lm9mZnNldHMucG9wcGVyLHA9e3ByaW1hcnk6ZnVuY3Rpb24odCl7dmFyIGE9clt0XTtyZXR1cm4gclt0XTxpW3RdJiYhZS5lc2NhcGVXaXRoUmVmZXJlbmNlJiYoYT1MdChyW3RdLGlbdF0pKSxVdCh7fSx0LGEpfSxzZWNvbmRhcnk6ZnVuY3Rpb24odCl7dmFyIGE9J3JpZ2h0Jz09PXQ/J2xlZnQnOid0b3AnLG89clthXTtyZXR1cm4gclt0XT5pW3RdJiYhZS5lc2NhcGVXaXRoUmVmZXJlbmNlJiYobz1FdChyW2FdLGlbdF0tKCdyaWdodCc9PT10P3Iud2lkdGg6ci5oZWlnaHQpKSksVXQoe30sYSxvKX19O3JldHVybiBvLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIGU9LTE9PT1bJ2xlZnQnLCd0b3AnXS5pbmRleE9mKHQpPydzZWNvbmRhcnknOidwcmltYXJ5JztyPXF0KHt9LHIscFtlXSh0KSl9KSx0Lm9mZnNldHMucG9wcGVyPXIsdH0scHJpb3JpdHk6WydsZWZ0JywncmlnaHQnLCd0b3AnLCdib3R0b20nXSxwYWRkaW5nOjUsYm91bmRhcmllc0VsZW1lbnQ6J3Njcm9sbFBhcmVudCd9LGtlZXBUb2dldGhlcjp7b3JkZXI6NDAwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24odCl7dmFyIGU9dC5vZmZzZXRzLGE9ZS5wb3BwZXIsaT1lLnJlZmVyZW5jZSxvPXQucGxhY2VtZW50LnNwbGl0KCctJylbMF0scj1UdCxwPS0xIT09Wyd0b3AnLCdib3R0b20nXS5pbmRleE9mKG8pLG49cD8ncmlnaHQnOidib3R0b20nLHM9cD8nbGVmdCc6J3RvcCcsbD1wPyd3aWR0aCc6J2hlaWdodCc7cmV0dXJuIGFbbl08cihpW3NdKSYmKHQub2Zmc2V0cy5wb3BwZXJbc109cihpW3NdKS1hW2xdKSxhW3NdPnIoaVtuXSkmJih0Lm9mZnNldHMucG9wcGVyW3NdPXIoaVtuXSkpLHR9fSxhcnJvdzp7b3JkZXI6NTAwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24odCxlKXt2YXIgYTtpZighdHQodC5pbnN0YW5jZS5tb2RpZmllcnMsJ2Fycm93Jywna2VlcFRvZ2V0aGVyJykpcmV0dXJuIHQ7dmFyIGk9ZS5lbGVtZW50O2lmKCdzdHJpbmcnPT10eXBlb2YgaSl7aWYoaT10Lmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGkpLCFpKXJldHVybiB0O31lbHNlIGlmKCF0Lmluc3RhbmNlLnBvcHBlci5jb250YWlucyhpKSlyZXR1cm4gY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyksdDt2YXIgbz10LnBsYWNlbWVudC5zcGxpdCgnLScpWzBdLHI9dC5vZmZzZXRzLHA9ci5wb3BwZXIsbj1yLnJlZmVyZW5jZSxzPS0xIT09WydsZWZ0JywncmlnaHQnXS5pbmRleE9mKG8pLGw9cz8naGVpZ2h0Jzond2lkdGgnLGQ9cz8nVG9wJzonTGVmdCcsYz1kLnRvTG93ZXJDYXNlKCksbT1zPydsZWZ0JzondG9wJyxoPXM/J2JvdHRvbSc6J3JpZ2h0JyxiPUQoaSlbbF07bltoXS1iPHBbY10mJih0Lm9mZnNldHMucG9wcGVyW2NdLT1wW2NdLShuW2hdLWIpKSxuW2NdK2I+cFtoXSYmKHQub2Zmc2V0cy5wb3BwZXJbY10rPW5bY10rYi1wW2hdKSx0Lm9mZnNldHMucG9wcGVyPU8odC5vZmZzZXRzLnBvcHBlcik7dmFyIHU9bltjXStuW2xdLzItYi8yLHk9Zih0Lmluc3RhbmNlLnBvcHBlciksZz1wYXJzZUZsb2F0KHlbJ21hcmdpbicrZF0sMTApLHc9cGFyc2VGbG9hdCh5Wydib3JkZXInK2QrJ1dpZHRoJ10sMTApLHg9dS10Lm9mZnNldHMucG9wcGVyW2NdLWctdztyZXR1cm4geD1MdChFdChwW2xdLWIseCksMCksdC5hcnJvd0VsZW1lbnQ9aSx0Lm9mZnNldHMuYXJyb3c9KGE9e30sVXQoYSxjLGt0KHgpKSxVdChhLG0sJycpLGEpLHR9LGVsZW1lbnQ6J1t4LWFycm93XSd9LGZsaXA6e29yZGVyOjYwMCxlbmFibGVkOiEwLGZuOmZ1bmN0aW9uKHQsZSl7aWYoeih0Lmluc3RhbmNlLm1vZGlmaWVycywnaW5uZXInKSlyZXR1cm4gdDtpZih0LmZsaXBwZWQmJnQucGxhY2VtZW50PT09dC5vcmlnaW5hbFBsYWNlbWVudClyZXR1cm4gdDt2YXIgYT1YKHQuaW5zdGFuY2UucG9wcGVyLHQuaW5zdGFuY2UucmVmZXJlbmNlLGUucGFkZGluZyxlLmJvdW5kYXJpZXNFbGVtZW50KSxpPXQucGxhY2VtZW50LnNwbGl0KCctJylbMF0sbz1OKGkpLHI9dC5wbGFjZW1lbnQuc3BsaXQoJy0nKVsxXXx8JycscD1bXTtzd2l0Y2goZS5iZWhhdmlvcil7Y2FzZSBLdC5GTElQOnA9W2ksb107YnJlYWs7Y2FzZSBLdC5DTE9DS1dJU0U6cD1hdChpKTticmVhaztjYXNlIEt0LkNPVU5URVJDTE9DS1dJU0U6cD1hdChpLCEwKTticmVhaztkZWZhdWx0OnA9ZS5iZWhhdmlvcjt9cmV0dXJuIHAuZm9yRWFjaChmdW5jdGlvbihuLHMpe2lmKGkhPT1ufHxwLmxlbmd0aD09PXMrMSlyZXR1cm4gdDtpPXQucGxhY2VtZW50LnNwbGl0KCctJylbMF0sbz1OKGkpO3ZhciBsPXQub2Zmc2V0cy5wb3BwZXIsZD10Lm9mZnNldHMucmVmZXJlbmNlLGM9VHQsbT0nbGVmdCc9PT1pJiZjKGwucmlnaHQpPmMoZC5sZWZ0KXx8J3JpZ2h0Jz09PWkmJmMobC5sZWZ0KTxjKGQucmlnaHQpfHwndG9wJz09PWkmJmMobC5ib3R0b20pPmMoZC50b3ApfHwnYm90dG9tJz09PWkmJmMobC50b3ApPGMoZC5ib3R0b20pLGY9YyhsLmxlZnQpPGMoYS5sZWZ0KSxoPWMobC5yaWdodCk+YyhhLnJpZ2h0KSxiPWMobC50b3ApPGMoYS50b3ApLHU9YyhsLmJvdHRvbSk+YyhhLmJvdHRvbSkseT0nbGVmdCc9PT1pJiZmfHwncmlnaHQnPT09aSYmaHx8J3RvcCc9PT1pJiZifHwnYm90dG9tJz09PWkmJnUsZz0tMSE9PVsndG9wJywnYm90dG9tJ10uaW5kZXhPZihpKSx3PSEhZS5mbGlwVmFyaWF0aW9ucyYmKGcmJidzdGFydCc9PT1yJiZmfHxnJiYnZW5kJz09PXImJmh8fCFnJiYnc3RhcnQnPT09ciYmYnx8IWcmJidlbmQnPT09ciYmdSk7KG18fHl8fHcpJiYodC5mbGlwcGVkPSEwLChtfHx5KSYmKGk9cFtzKzFdKSx3JiYocj1ldChyKSksdC5wbGFjZW1lbnQ9aSsocj8nLScrcjonJyksdC5vZmZzZXRzLnBvcHBlcj1xdCh7fSx0Lm9mZnNldHMucG9wcGVyLEgodC5pbnN0YW5jZS5wb3BwZXIsdC5vZmZzZXRzLnJlZmVyZW5jZSx0LnBsYWNlbWVudCkpLHQ9Qih0Lmluc3RhbmNlLm1vZGlmaWVycyx0LCdmbGlwJykpfSksdH0sYmVoYXZpb3I6J2ZsaXAnLHBhZGRpbmc6NSxib3VuZGFyaWVzRWxlbWVudDondmlld3BvcnQnfSxpbm5lcjp7b3JkZXI6NzAwLGVuYWJsZWQ6ITEsZm46ZnVuY3Rpb24odCl7dmFyIGU9dC5wbGFjZW1lbnQsYT1lLnNwbGl0KCctJylbMF0saT10Lm9mZnNldHMsbz1pLnBvcHBlcixyPWkucmVmZXJlbmNlLHA9LTEhPT1bJ2xlZnQnLCdyaWdodCddLmluZGV4T2YoYSksbj0tMT09PVsndG9wJywnbGVmdCddLmluZGV4T2YoYSk7cmV0dXJuIG9bcD8nbGVmdCc6J3RvcCddPXJbYV0tKG4/b1twPyd3aWR0aCc6J2hlaWdodCddOjApLHQucGxhY2VtZW50PU4oZSksdC5vZmZzZXRzLnBvcHBlcj1PKG8pLHR9fSxoaWRlOntvcmRlcjo4MDAsZW5hYmxlZDohMCxmbjpmdW5jdGlvbih0KXtpZighdHQodC5pbnN0YW5jZS5tb2RpZmllcnMsJ2hpZGUnLCdwcmV2ZW50T3ZlcmZsb3cnKSlyZXR1cm4gdDt2YXIgZT10Lm9mZnNldHMucmVmZXJlbmNlLGE9Uih0Lmluc3RhbmNlLm1vZGlmaWVycyxmdW5jdGlvbih0KXtyZXR1cm4ncHJldmVudE92ZXJmbG93Jz09PXQubmFtZX0pLmJvdW5kYXJpZXM7aWYoZS5ib3R0b208YS50b3B8fGUubGVmdD5hLnJpZ2h0fHxlLnRvcD5hLmJvdHRvbXx8ZS5yaWdodDxhLmxlZnQpe2lmKCEwPT09dC5oaWRlKXJldHVybiB0O3QuaGlkZT0hMCx0LmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXT0nJ31lbHNle2lmKCExPT09dC5oaWRlKXJldHVybiB0O3QuaGlkZT0hMSx0LmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXT0hMX1yZXR1cm4gdH19LGNvbXB1dGVTdHlsZTp7b3JkZXI6ODUwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24odCxlKXt2YXIgYT1lLngsaT1lLnksbz10Lm9mZnNldHMucG9wcGVyLHI9Uih0Lmluc3RhbmNlLm1vZGlmaWVycyxmdW5jdGlvbih0KXtyZXR1cm4nYXBwbHlTdHlsZSc9PT10Lm5hbWV9KS5ncHVBY2NlbGVyYXRpb247dm9pZCAwIT09ciYmY29uc29sZS53YXJuKCdXQVJOSU5HOiBgZ3B1QWNjZWxlcmF0aW9uYCBvcHRpb24gbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXIgYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgUG9wcGVyLmpzIScpO3ZhciBwLG4scz12b2lkIDA9PT1yP2UuZ3B1QWNjZWxlcmF0aW9uOnIsbD11KHQuaW5zdGFuY2UucG9wcGVyKSxkPUEobCksYz17cG9zaXRpb246by5wb3NpdGlvbn0sbT17bGVmdDpUdChvLmxlZnQpLHRvcDpUdChvLnRvcCksYm90dG9tOlR0KG8uYm90dG9tKSxyaWdodDpUdChvLnJpZ2h0KX0sZj0nYm90dG9tJz09PWE/J3RvcCc6J2JvdHRvbScsaD0ncmlnaHQnPT09aT8nbGVmdCc6J3JpZ2h0JyxiPVUoJ3RyYW5zZm9ybScpO2lmKG49J2JvdHRvbSc9PWY/LWQuaGVpZ2h0K20uYm90dG9tOm0udG9wLHA9J3JpZ2h0Jz09aD8tZC53aWR0aCttLnJpZ2h0Om0ubGVmdCxzJiZiKWNbYl09J3RyYW5zbGF0ZTNkKCcrcCsncHgsICcrbisncHgsIDApJyxjW2ZdPTAsY1toXT0wLGMud2lsbENoYW5nZT0ndHJhbnNmb3JtJztlbHNle3ZhciB5PSdib3R0b20nPT1mPy0xOjEsZz0ncmlnaHQnPT1oPy0xOjE7Y1tmXT1uKnksY1toXT1wKmcsYy53aWxsQ2hhbmdlPWYrJywgJytofXZhciB3PXtcIngtcGxhY2VtZW50XCI6dC5wbGFjZW1lbnR9O3JldHVybiB0LmF0dHJpYnV0ZXM9cXQoe30sdyx0LmF0dHJpYnV0ZXMpLHQuc3R5bGVzPXF0KHt9LGMsdC5zdHlsZXMpLHQuYXJyb3dTdHlsZXM9cXQoe30sdC5vZmZzZXRzLmFycm93LHQuYXJyb3dTdHlsZXMpLHR9LGdwdUFjY2VsZXJhdGlvbjohMCx4Oidib3R0b20nLHk6J3JpZ2h0J30sYXBwbHlTdHlsZTp7b3JkZXI6OTAwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24odCl7cmV0dXJuIFoodC5pbnN0YW5jZS5wb3BwZXIsdC5zdHlsZXMpLCQodC5pbnN0YW5jZS5wb3BwZXIsdC5hdHRyaWJ1dGVzKSx0LmFycm93RWxlbWVudCYmT2JqZWN0LmtleXModC5hcnJvd1N0eWxlcykubGVuZ3RoJiZaKHQuYXJyb3dFbGVtZW50LHQuYXJyb3dTdHlsZXMpLHR9LG9uTG9hZDpmdW5jdGlvbih0LGUsYSxpLG8pe3ZhciByPVAobyxlLHQpLHA9SShhLnBsYWNlbWVudCxyLGUsdCxhLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LGEubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7cmV0dXJuIGUuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcscCksWihlLHtwb3NpdGlvbjonYWJzb2x1dGUnfSksYX0sZ3B1QWNjZWxlcmF0aW9uOnZvaWQgMH19fTt2YXIgR3Q9e307aWYoT3Qpe3ZhciBRdD1FbGVtZW50LnByb3RvdHlwZTtHdD1RdC5tYXRjaGVzfHxRdC5tYXRjaGVzU2VsZWN0b3J8fFF0LndlYmtpdE1hdGNoZXNTZWxlY3Rvcnx8UXQubW96TWF0Y2hlc1NlbGVjdG9yfHxRdC5tc01hdGNoZXNTZWxlY3Rvcnx8ZnVuY3Rpb24odCl7Zm9yKHZhciBlPSh0aGlzLmRvY3VtZW50fHx0aGlzLm93bmVyRG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwodCksYT1lLmxlbmd0aDswPD0tLWEmJmUuaXRlbShhKSE9PXRoaXM7KTtyZXR1cm4tMTxhfX12YXIgZT1HdCxKdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIGU9bXQodC50YXJnZXQsdGhpcy5vcHRpb25zLnRhcmdldCk7aWYoZSYmIWUuX3RpcHB5KXt2YXIgYT1lLmdldEF0dHJpYnV0ZSgndGl0bGUnKXx8dGhpcy50aXRsZTthJiYoZS5zZXRBdHRyaWJ1dGUoJ3RpdGxlJyxhKSx2dChlLEl0KHt9LHRoaXMub3B0aW9ucyx7dGFyZ2V0Om51bGx9KSksZS5fdGlwcHkuc2hvdygpKX19ZnVuY3Rpb24gZShlKXt2YXIgYT10aGlzO2lmKG4uY2FsbCh0aGlzKSwhdGhpcy5zdGF0ZS52aXNpYmxlKXtpZih0aGlzLm9wdGlvbnMudGFyZ2V0KXJldHVybiB2b2lkIHQuY2FsbCh0aGlzLGUpO2lmKHRoaXMuXyhmKS5pc1ByZXBhcmluZ1RvU2hvdz0hMCx0aGlzLm9wdGlvbnMud2FpdClyZXR1cm4gdm9pZCB0aGlzLm9wdGlvbnMud2FpdC5jYWxsKHRoaXMucG9wcGVyLHRoaXMuc2hvdy5iaW5kKHRoaXMpLGUpO3RoaXMub3B0aW9ucy5mb2xsb3dDdXJzb3ImJiFBdC51c2luZ1RvdWNoJiYoIXRoaXMuXyhmKS5mb2xsb3dDdXJzb3JMaXN0ZW5lciYmcy5jYWxsKHRoaXMpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsdGhpcy5fKGYpLmZvbGxvd0N1cnNvckxpc3RlbmVyKSk7dmFyIGk9QXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuZGVsYXkpP3RoaXMub3B0aW9ucy5kZWxheVswXTp0aGlzLm9wdGlvbnMuZGVsYXk7aT90aGlzLl8oZikuc2hvd1RpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe2Euc2hvdygpfSxpKTp0aGlzLnNob3coKX19ZnVuY3Rpb24gaSgpe3ZhciB0PXRoaXM7aWYobi5jYWxsKHRoaXMpLCEhdGhpcy5zdGF0ZS52aXNpYmxlKXt0aGlzLl8oZikuaXNQcmVwYXJpbmdUb1Nob3c9ITE7dmFyIGU9QXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuZGVsYXkpP3RoaXMub3B0aW9ucy5kZWxheVsxXTp0aGlzLm9wdGlvbnMuZGVsYXk7ZT90aGlzLl8oZikuaGlkZVRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe3Quc3RhdGUudmlzaWJsZSYmdC5oaWRlKCl9LGUpOnRoaXMuaGlkZSgpfX1mdW5jdGlvbiBvKCl7dmFyIHQ9dGhpcyxlPXRoaXMucG9wcGVyLGE9dGhpcy5yZWZlcmVuY2UsaT10aGlzLm9wdGlvbnMsbz1kKGUpLHA9by50b29sdGlwLG49aS5wb3BwZXJPcHRpb25zLHM9J3JvdW5kJz09PWkuYXJyb3dUeXBlP0N0LlJPVU5EX0FSUk9XOkN0LkFSUk9XLGw9cC5xdWVyeVNlbGVjdG9yKHMpLG09SXQoe3BsYWNlbWVudDppLnBsYWNlbWVudH0sbnx8e30se21vZGlmaWVyczpJdCh7fSxuP24ubW9kaWZpZXJzOnt9LHthcnJvdzpJdCh7ZWxlbWVudDpzfSxuJiZuLm1vZGlmaWVycz9uLm1vZGlmaWVycy5hcnJvdzp7fSksZmxpcDpJdCh7ZW5hYmxlZDppLmZsaXAscGFkZGluZzppLmRpc3RhbmNlKzUsYmVoYXZpb3I6aS5mbGlwQmVoYXZpb3J9LG4mJm4ubW9kaWZpZXJzP24ubW9kaWZpZXJzLmZsaXA6e30pLG9mZnNldDpJdCh7b2Zmc2V0Omkub2Zmc2V0fSxuJiZuLm1vZGlmaWVycz9uLm1vZGlmaWVycy5vZmZzZXQ6e30pfSksb25DcmVhdGU6ZnVuY3Rpb24oKXtwLnN0eWxlW3J0KGUpXT1kdChpLmRpc3RhbmNlKSxsJiZpLmFycm93VHJhbnNmb3JtJiZsdChlLGwsaS5hcnJvd1RyYW5zZm9ybSl9LG9uVXBkYXRlOmZ1bmN0aW9uKCl7dmFyIHQ9cC5zdHlsZTt0LnRvcD0nJyx0LmJvdHRvbT0nJyx0LmxlZnQ9JycsdC5yaWdodD0nJyx0W3J0KGUpXT1kdChpLmRpc3RhbmNlKSxsJiZpLmFycm93VHJhbnNmb3JtJiZsdChlLGwsaS5hcnJvd1RyYW5zZm9ybSl9fSk7cmV0dXJuIGMuY2FsbCh0aGlzLHt0YXJnZXQ6ZSxjYWxsYmFjazpmdW5jdGlvbigpe3ZhciBhPWUuc3R5bGU7YVtyKCd0cmFuc2l0aW9uRHVyYXRpb24nKV09bnVsbDt2YXIgbz10LnBvcHBlckluc3RhbmNlLm9wdGlvbnMub25VcGRhdGU7dC5wb3BwZXJJbnN0YW5jZS5vcHRpb25zLm9uVXBkYXRlPWZ1bmN0aW9uKCl7dXQodC5wb3BwZXIpLGFbcigndHJhbnNpdGlvbkR1cmF0aW9uJyldPWkudXBkYXRlRHVyYXRpb24rJ21zJyx0LnBvcHBlckluc3RhbmNlLm9wdGlvbnMub25VcGRhdGU9b30sdC5wb3BwZXJJbnN0YW5jZS51cGRhdGUoKX0sb3B0aW9uczp7Y2hpbGRMaXN0OiEwLHN1YnRyZWU6ITAsY2hhcmFjdGVyRGF0YTohMH19KSxuZXcgVnQoYSxlLG0pfWZ1bmN0aW9uIHAodCl7dmFyIGU9dGhpczt0aGlzLnBvcHBlckluc3RhbmNlPyh0aGlzLnBvcHBlci5zdHlsZVtyKCd0cmFuc2Zvcm0nKV09bnVsbCx0aGlzLnBvcHBlckluc3RhbmNlLnNjaGVkdWxlVXBkYXRlKCksKCF0aGlzLm9wdGlvbnMuZm9sbG93Q3Vyc29yfHxBdC51c2luZ1RvdWNoKSYmdGhpcy5wb3BwZXJJbnN0YW5jZS5lbmFibGVFdmVudExpc3RlbmVycygpKTp0aGlzLnBvcHBlckluc3RhbmNlPW8uY2FsbCh0aGlzKTt2YXIgYT10aGlzLnBvcHBlckluc3RhbmNlLm9wdGlvbnMub25DcmVhdGUsaT10aGlzLnBvcHBlckluc3RhbmNlLm9wdGlvbnMub25VcGRhdGU7dGhpcy5wb3BwZXJJbnN0YW5jZS5vcHRpb25zLm9uQ3JlYXRlPXRoaXMucG9wcGVySW5zdGFuY2Uub3B0aW9ucy5vblVwZGF0ZT1mdW5jdGlvbigpe3V0KGUucG9wcGVyKSx0KCksZS5wb3BwZXJJbnN0YW5jZS5vcHRpb25zLm9uVXBkYXRlPWksZS5wb3BwZXJJbnN0YW5jZS5vcHRpb25zLm9uQ3JlYXRlPWF9LHRoaXMub3B0aW9ucy5hcHBlbmRUby5jb250YWlucyh0aGlzLnBvcHBlcil8fHRoaXMub3B0aW9ucy5hcHBlbmRUby5hcHBlbmRDaGlsZCh0aGlzLnBvcHBlcil9ZnVuY3Rpb24gbigpe3ZhciB0PXRoaXMuXyhmKSxlPXQuc2hvd1RpbWVvdXQsYT10LmhpZGVUaW1lb3V0O2NsZWFyVGltZW91dChlKSxjbGVhclRpbWVvdXQoYSl9ZnVuY3Rpb24gcygpe3ZhciB0PXRoaXM7dGhpcy5fKGYpLmZvbGxvd0N1cnNvckxpc3RlbmVyPWZ1bmN0aW9uKGUpe2lmKCEodC5fKGYpLmxhc3RUcmlnZ2VyRXZlbnQmJidmb2N1cyc9PT10Ll8oZikubGFzdFRyaWdnZXJFdmVudC50eXBlKSl7dC5fKGYpLmxhc3RNb3VzZU1vdmVFdmVudD1lO3ZhciBhPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aHx8ZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCxpPWt0KHQucG9wcGVyLm9mZnNldFdpZHRoLzIpLG89a3QodC5wb3BwZXIub2Zmc2V0SGVpZ2h0LzIpLHA9dC5vcHRpb25zLm9mZnNldCxuPWUucGFnZVgscz1lLnBhZ2VZLGw9NSxkPXQub3B0aW9ucy5wbGFjZW1lbnQucmVwbGFjZSgvLS4rLywnJyk7dC5wb3BwZXIuZ2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcpJiYoZD1ydCh0LnBvcHBlcikpO3ZhciBjLG07J3RvcCc9PT1kPyhjPW4taStwLG09cy0yKm8pOidib3R0b20nPT09ZD8oYz1uLWkrcCxtPXMrMTApOidsZWZ0Jz09PWQ/KGM9bi0yKmksbT1zLW8rcCk6J3JpZ2h0Jz09PWQ/KGM9bis1LG09cy1vK3ApOnZvaWQgMDsoJ3RvcCc9PT1kfHwnYm90dG9tJz09PWQpJiYobitsK2krcD5hJiYoYz1hLWwtMippKSwwPm4tbC1pK3AmJihjPWwpKSx0LnBvcHBlci5zdHlsZVtyKCd0cmFuc2Zvcm0nKV09J3RyYW5zbGF0ZTNkKCcrYysncHgsICcrbSsncHgsIDApJ319fWZ1bmN0aW9uIGwoKXt2YXIgdD10aGlzLGU9ZnVuY3Rpb24oKXt0LnBvcHBlci5zdHlsZVtyKCd0cmFuc2l0aW9uRHVyYXRpb24nKV09dC5vcHRpb25zLnVwZGF0ZUR1cmF0aW9uKydtcyd9LGE9ZnVuY3Rpb24oKXt0LnBvcHBlci5zdHlsZVtyKCd0cmFuc2l0aW9uRHVyYXRpb24nKV09Jyd9O2N0KGZ1bmN0aW9uIGkoKXt0LnBvcHBlckluc3RhbmNlJiZ0LnBvcHBlckluc3RhbmNlLnNjaGVkdWxlVXBkYXRlKCksZSgpLHQuc3RhdGUudmlzaWJsZT9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaSk6YSgpfSl9ZnVuY3Rpb24gYyh0KXt2YXIgZT10LnRhcmdldCxhPXQuY2FsbGJhY2ssaT10Lm9wdGlvbnM7aWYod2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIpe3ZhciBvPW5ldyBNdXRhdGlvbk9ic2VydmVyKGEpO28ub2JzZXJ2ZShlLGkpLHRoaXMuXyhmKS5tdXRhdGlvbk9ic2VydmVycy5wdXNoKG8pfX1mdW5jdGlvbiBtKHQsYSl7aWYoIXQpcmV0dXJuIGEoKTt2YXIgZT1kKHRoaXMucG9wcGVyKSxpPWUudG9vbHRpcCxvPWZ1bmN0aW9uKHQsZSl7ZSYmaVt0KydFdmVudExpc3RlbmVyJ10oJ29udHJhbnNpdGlvbmVuZCdpbiB3aW5kb3c/J3RyYW5zaXRpb25lbmQnOid3ZWJraXRUcmFuc2l0aW9uRW5kJyxlKX0scj1mdW5jdGlvbiB0KHIpe3IudGFyZ2V0PT09aSYmKG8oJ3JlbW92ZScsdCksYSgpKX07bygncmVtb3ZlJyx0aGlzLl8oZikudHJhbnNpdGlvbmVuZExpc3RlbmVyKSxvKCdhZGQnLHIpLHRoaXMuXyhmKS50cmFuc2l0aW9uZW5kTGlzdGVuZXI9cn12YXIgZj17fSxoPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZT09PWYmJnR9fSxiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXtmb3IodmFyIGEgaW4gWHQodGhpcyx0KSxlKXRoaXNbYV09ZVthXTt0aGlzLnN0YXRlPXtkZXN0cm95ZWQ6ITEsdmlzaWJsZTohMSxlbmFibGVkOiEwfSx0aGlzLl89aCh7bXV0YXRpb25PYnNlcnZlcnM6W119KX1yZXR1cm4gX3QodCxbe2tleTonZW5hYmxlJyx2YWx1ZTpmdW5jdGlvbigpe3RoaXMuc3RhdGUuZW5hYmxlZD0hMH19LHtrZXk6J2Rpc2FibGUnLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5zdGF0ZS5lbmFibGVkPSExfX0se2tleTonc2hvdycsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZighdGhpcy5zdGF0ZS5kZXN0cm95ZWQmJnRoaXMuc3RhdGUuZW5hYmxlZCl7dmFyIGE9dGhpcy5wb3BwZXIsaT10aGlzLnJlZmVyZW5jZSxvPXRoaXMub3B0aW9ucyxuPWQoYSkscz1uLnRvb2x0aXAsYz1uLmJhY2tkcm9wLGg9bi5jb250ZW50O3JldHVybiBvLmR5bmFtaWNUaXRsZSYmIWkuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJyk/dm9pZCAwOmkucmVmT2JqfHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoaSk/dm9pZChvLm9uU2hvdy5jYWxsKGEsdGhpcyksdD1mdCh2b2lkIDA9PT10P28uZHVyYXRpb246dCwwKSxidChbYSxzLGNdLDApLGEuc3R5bGUudmlzaWJpbGl0eT0ndmlzaWJsZScsdGhpcy5zdGF0ZS52aXNpYmxlPSEwLHAuY2FsbCh0aGlzLGZ1bmN0aW9uKCl7aWYoZS5zdGF0ZS52aXNpYmxlKXtpZigoIW8uZm9sbG93Q3Vyc29yfHxBdC51c2luZ1RvdWNoKSYmKGUucG9wcGVySW5zdGFuY2Uuc2NoZWR1bGVVcGRhdGUoKSxidChbYV0sby51cGRhdGVEdXJhdGlvbikpLG8uZm9sbG93Q3Vyc29yJiYhQXQudXNpbmdUb3VjaCl7ZS5wb3BwZXJJbnN0YW5jZS5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKTt2YXIgcD1BcnJheS5pc0FycmF5KG8uZGVsYXkpP28uZGVsYXlbMF06by5kZWxheTtlLl8oZikubGFzdFRyaWdnZXJFdmVudCYmZS5fKGYpLmZvbGxvd0N1cnNvckxpc3RlbmVyKHAmJmUuXyhmKS5sYXN0TW91c2VNb3ZlRXZlbnQ/ZS5fKGYpLmxhc3RNb3VzZU1vdmVFdmVudDplLl8oZikubGFzdFRyaWdnZXJFdmVudCl9YnQoW3MsYyxjP2g6bnVsbF0sdCksYyYmZ2V0Q29tcHV0ZWRTdHlsZShjKVtyKCd0cmFuc2Zvcm0nKV0sby5pbnRlcmFjdGl2ZSYmaS5jbGFzc0xpc3QuYWRkKCd0aXBweS1hY3RpdmUnKSxvLnN0aWNreSYmbC5jYWxsKGUpLGh0KFtzLGNdLCd2aXNpYmxlJyksbS5jYWxsKGUsdCxmdW5jdGlvbigpe28udXBkYXRlRHVyYXRpb258fHMuY2xhc3NMaXN0LmFkZCgndGlwcHktbm90cmFuc2l0aW9uJyksby5pbnRlcmFjdGl2ZSYmeXQoYSksaS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCd0aXBweS0nK2UuaWQpLG8ub25TaG93bi5jYWxsKGEsZSl9KX19KSk6dm9pZCB0aGlzLmRlc3Ryb3koKX19fSx7a2V5OidoaWRlJyx2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKCF0aGlzLnN0YXRlLmRlc3Ryb3llZCYmdGhpcy5zdGF0ZS5lbmFibGVkKXt2YXIgYT10aGlzLnBvcHBlcixpPXRoaXMucmVmZXJlbmNlLG89dGhpcy5vcHRpb25zLHI9ZChhKSxwPXIudG9vbHRpcCxuPXIuYmFja2Ryb3Ascz1yLmNvbnRlbnQ7by5vbkhpZGUuY2FsbChhLHRoaXMpLHQ9ZnQodm9pZCAwPT09dD9vLmR1cmF0aW9uOnQsMSksby51cGRhdGVEdXJhdGlvbnx8cC5jbGFzc0xpc3QucmVtb3ZlKCd0aXBweS1ub3RyYW5zaXRpb24nKSxvLmludGVyYWN0aXZlJiZpLmNsYXNzTGlzdC5yZW1vdmUoJ3RpcHB5LWFjdGl2ZScpLGEuc3R5bGUudmlzaWJpbGl0eT0naGlkZGVuJyx0aGlzLnN0YXRlLnZpc2libGU9ITEsYnQoW3AsbixuP3M6bnVsbF0sdCksaHQoW3Asbl0sJ2hpZGRlbicpLG8uaW50ZXJhY3RpdmUmJi0xPG8udHJpZ2dlci5pbmRleE9mKCdjbGljaycpJiZ5dChpKSxjdChmdW5jdGlvbigpe20uY2FsbChlLHQsZnVuY3Rpb24oKXtlLnN0YXRlLnZpc2libGV8fCFvLmFwcGVuZFRvLmNvbnRhaW5zKGEpfHwoIWUuXyhmKS5pc1ByZXBhcmluZ1RvU2hvdyYmKGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsZS5fKGYpLmZvbGxvd0N1cnNvckxpc3RlbmVyKSxlLl8oZikubGFzdE1vdXNlTW92ZUV2ZW50PW51bGwpLGkucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JyksZS5wb3BwZXJJbnN0YW5jZS5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSxvLmFwcGVuZFRvLnJlbW92ZUNoaWxkKGEpLG8ub25IaWRkZW4uY2FsbChhLGUpKX0pfSl9fX0se2tleTonZGVzdHJveScsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9MDxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOiEwO2lmKCF0aGlzLnN0YXRlLmRlc3Ryb3llZCl7dGhpcy5zdGF0ZS52aXNpYmxlJiZ0aGlzLmhpZGUoMCksdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbihlKXt0LnJlZmVyZW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKGUuZXZlbnQsZS5oYW5kbGVyKX0pLHRoaXMucmVmZXJlbmNlLnNldEF0dHJpYnV0ZSgndGl0bGUnLHRoaXMucmVmZXJlbmNlLmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpKSxkZWxldGUgdGhpcy5yZWZlcmVuY2UuX3RpcHB5O1snZGF0YS1vcmlnaW5hbC10aXRsZScsJ2RhdGEtdGlwcHknLCdkYXRhLXRpcHB5LWRlbGVnYXRlJ10uZm9yRWFjaChmdW5jdGlvbihlKXt0LnJlZmVyZW5jZS5yZW1vdmVBdHRyaWJ1dGUoZSl9KSx0aGlzLm9wdGlvbnMudGFyZ2V0JiZlJiZhKHRoaXMucmVmZXJlbmNlLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLnRhcmdldCkpLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHQuX3RpcHB5JiZ0Ll90aXBweS5kZXN0cm95KCl9KSx0aGlzLnBvcHBlckluc3RhbmNlJiZ0aGlzLnBvcHBlckluc3RhbmNlLmRlc3Ryb3koKSx0aGlzLl8oZikubXV0YXRpb25PYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbih0KXt0LmRpc2Nvbm5lY3QoKX0pLHRoaXMuc3RhdGUuZGVzdHJveWVkPSEwfX19XSksdH0oKTtyZXR1cm57VGlwcHk6YixfZ2V0RXZlbnRMaXN0ZW5lcnM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybntoYW5kbGVUcmlnZ2VyOmZ1bmN0aW9uKGEpe2lmKHQuc3RhdGUuZW5hYmxlZCl7dmFyIG89QXQuc3VwcG9ydHNUb3VjaCYmQXQudXNpbmdUb3VjaCYmLTE8Wydtb3VzZWVudGVyJywnbW91c2VvdmVyJywnZm9jdXMnXS5pbmRleE9mKGEudHlwZSk7byYmdC5vcHRpb25zLnRvdWNoSG9sZHx8KHQuXyhmKS5sYXN0VHJpZ2dlckV2ZW50PWEsJ2NsaWNrJz09PWEudHlwZSYmJ3BlcnNpc3RlbnQnIT09dC5vcHRpb25zLmhpZGVPbkNsaWNrJiZ0LnN0YXRlLnZpc2libGU/aS5jYWxsKHQpOmUuY2FsbCh0LGEpLG8mJkF0LmlPUyYmdC5yZWZlcmVuY2UuY2xpY2smJnQucmVmZXJlbmNlLmNsaWNrKCkpfX0saGFuZGxlTW91c2VMZWF2ZTpmdW5jdGlvbihlKXtpZighKC0xPFsnbW91c2VsZWF2ZScsJ21vdXNlb3V0J10uaW5kZXhPZihlLnR5cGUpJiZBdC5zdXBwb3J0c1RvdWNoJiZBdC51c2luZ1RvdWNoJiZ0Lm9wdGlvbnMudG91Y2hIb2xkKSl7aWYodC5vcHRpb25zLmludGVyYWN0aXZlKXt2YXIgYT1pLmJpbmQodCksbz1mdW5jdGlvbiBlKG8pe3ZhciByPW10KG8udGFyZ2V0LEN0LlJFRkVSRU5DRSkscD1tdChvLnRhcmdldCxDdC5QT1BQRVIpPT09dC5wb3BwZXIsbj1yPT09dC5yZWZlcmVuY2U7cHx8bnx8cHQobyx0LnBvcHBlcix0Lm9wdGlvbnMpJiYoZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJyxhKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLGUpLGkuY2FsbCh0KSl9O3JldHVybiBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLGEpLHZvaWQgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyxvKX1pLmNhbGwodCl9fSxoYW5kbGVCbHVyOmZ1bmN0aW9uKGUpeyFlLnJlbGF0ZWRUYXJnZXR8fEF0LnVzaW5nVG91Y2h8fG10KGUucmVsYXRlZFRhcmdldCxDdC5QT1BQRVIpfHxpLmNhbGwodCl9LGhhbmRsZURlbGVnYXRlU2hvdzpmdW5jdGlvbihhKXttdChhLnRhcmdldCx0Lm9wdGlvbnMudGFyZ2V0KSYmZS5jYWxsKHQsYSl9LGhhbmRsZURlbGVnYXRlSGlkZTpmdW5jdGlvbihlKXttdChlLnRhcmdldCx0Lm9wdGlvbnMudGFyZ2V0KSYmaS5jYWxsKHQpfX19LF9hZGRNdXRhdGlvbk9ic2VydmVyOmMsX2NyZWF0ZVBvcHBlckluc3RhbmNlOm8sX29uVHJhbnNpdGlvbkVuZDptfX0oKSxUPUp0LlRpcHB5LFp0PUp0Ll9nZXRFdmVudExpc3RlbmVycywkdD1KdC5fY3JlYXRlUG9wcGVySW5zdGFuY2UsdGU9SnQuX2FkZE11dGF0aW9uT2JzZXJ2ZXIsZWU9MTtyZXR1cm4gdnQuYnJvd3Nlcj1BdCx2dC5kZWZhdWx0cz1TdCxmdW5jdGlvbigpe3ZhciB0PTA8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTonJztpZihPdCYmQXQuc3VwcG9ydGVkKXt2YXIgZT1kb2N1bWVudC5oZWFkfHxkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkJyksYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO2EudHlwZT0ndGV4dC9jc3MnLGUuaW5zZXJ0QmVmb3JlKGEsZS5maXJzdENoaWxkKSxhLnN0eWxlU2hlZXQ/YS5zdHlsZVNoZWV0LmNzc1RleHQ9dDphLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHQpKX19KCcudGlwcHktdG91Y2h7Y3Vyc29yOnBvaW50ZXIhaW1wb3J0YW50fS50aXBweS1ub3RyYW5zaXRpb257LXdlYmtpdC10cmFuc2l0aW9uOm5vbmUhaW1wb3J0YW50O3RyYW5zaXRpb246bm9uZSFpbXBvcnRhbnR9LnRpcHB5LXBvcHBlcnttYXgtd2lkdGg6MzUwcHg7LXdlYmtpdC1wZXJzcGVjdGl2ZTo3MDBweDtwZXJzcGVjdGl2ZTo3MDBweDt6LWluZGV4Ojk5OTk7b3V0bGluZTowOy13ZWJraXQtdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC4xNjUsLjg0LC40NCwxKTt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjE2NSwuODQsLjQ0LDEpO3BvaW50ZXItZXZlbnRzOm5vbmV9LnRpcHB5LXBvcHBlcltkYXRhLWh0bWxde21heC13aWR0aDo5NiU7bWF4LXdpZHRoOmNhbGMoMTAwJSAtIDIwcHgpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXRvcF0gLnRpcHB5LWJhY2tkcm9we2JvcmRlci1yYWRpdXM6NDAlIDQwJSAwIDB9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49dG9wXSAudGlwcHktcm91bmRhcnJvd3tib3R0b206LThweDttYXJnaW46MCA2cHg7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjUwJSAwO3RyYW5zZm9ybS1vcmlnaW46NTAlIDB9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49dG9wXSAudGlwcHktcm91bmRhcnJvdyBzdmd7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj10b3BdIC50aXBweS1hcnJvd3tib3JkZXItdG9wOjdweCBzb2xpZCAjMzMzO2JvcmRlci1yaWdodDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQ6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvdHRvbTotN3B4O21hcmdpbjowIDdweDstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46NTAlIDA7dHJhbnNmb3JtLW9yaWdpbjo1MCUgMH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj10b3BdIC50aXBweS1iYWNrZHJvcHstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46MCAxMDAlO3RyYW5zZm9ybS1vcmlnaW46MCAxMDAlfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXRvcF0gLnRpcHB5LWJhY2tkcm9wW2RhdGEtc3RhdGU9dmlzaWJsZV17LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoNS41KSB0cmFuc2xhdGUoLTUwJSwyNSUpO3RyYW5zZm9ybTpzY2FsZSg1LjUpIHRyYW5zbGF0ZSgtNTAlLDI1JSk7b3BhY2l0eToxfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXRvcF0gLnRpcHB5LWJhY2tkcm9wW2RhdGEtc3RhdGU9aGlkZGVuXXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSgxKSB0cmFuc2xhdGUoLTUwJSwyNSUpO3RyYW5zZm9ybTpzY2FsZSgxKSB0cmFuc2xhdGUoLTUwJSwyNSUpO29wYWNpdHk6MH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj10b3BdIFtkYXRhLWFuaW1hdGlvbj1zaGlmdC10b3dhcmRdW2RhdGEtc3RhdGU9dmlzaWJsZV17b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTEwcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMHB4KX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj10b3BdIFtkYXRhLWFuaW1hdGlvbj1zaGlmdC10b3dhcmRdW2RhdGEtc3RhdGU9aGlkZGVuXXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtMjBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTIwcHgpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXRvcF0gW2RhdGEtYW5pbWF0aW9uPXBlcnNwZWN0aXZlXXstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46Ym90dG9tO3RyYW5zZm9ybS1vcmlnaW46Ym90dG9tfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXRvcF0gW2RhdGEtYW5pbWF0aW9uPXBlcnNwZWN0aXZlXVtkYXRhLXN0YXRlPXZpc2libGVde29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMHB4KSByb3RhdGVYKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMHB4KSByb3RhdGVYKDApfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXRvcF0gW2RhdGEtYW5pbWF0aW9uPXBlcnNwZWN0aXZlXVtkYXRhLXN0YXRlPWhpZGRlbl17b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCkgcm90YXRlWCg5MGRlZyk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCkgcm90YXRlWCg5MGRlZyl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49dG9wXSBbZGF0YS1hbmltYXRpb249ZmFkZV1bZGF0YS1zdGF0ZT12aXNpYmxlXXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtMTBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTEwcHgpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXRvcF0gW2RhdGEtYW5pbWF0aW9uPWZhZGVdW2RhdGEtc3RhdGU9aGlkZGVuXXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtMTBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTEwcHgpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXRvcF0gW2RhdGEtYW5pbWF0aW9uPXNoaWZ0LWF3YXldW2RhdGEtc3RhdGU9dmlzaWJsZV17b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTEwcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMHB4KX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj10b3BdIFtkYXRhLWFuaW1hdGlvbj1zaGlmdC1hd2F5XVtkYXRhLXN0YXRlPWhpZGRlbl17b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49dG9wXSBbZGF0YS1hbmltYXRpb249c2NhbGVdW2RhdGEtc3RhdGU9dmlzaWJsZV17b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTEwcHgpIHNjYWxlKDEpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMHB4KSBzY2FsZSgxKX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj10b3BdIFtkYXRhLWFuaW1hdGlvbj1zY2FsZV1bZGF0YS1zdGF0ZT1oaWRkZW5de29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDApIHNjYWxlKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApIHNjYWxlKDApfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gLnRpcHB5LWJhY2tkcm9we2JvcmRlci1yYWRpdXM6MCAwIDMwJSAzMCV9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49Ym90dG9tXSAudGlwcHktcm91bmRhcnJvd3t0b3A6LThweDttYXJnaW46MCA2cHg7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjUwJSAxMDAlO3RyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCV9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49Ym90dG9tXSAudGlwcHktcm91bmRhcnJvdyBzdmd7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwKTt0cmFuc2Zvcm06cm90YXRlKDApfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gLnRpcHB5LWFycm93e2JvcmRlci1ib3R0b206N3B4IHNvbGlkICMzMzM7Ym9yZGVyLXJpZ2h0OjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItbGVmdDo3cHggc29saWQgdHJhbnNwYXJlbnQ7dG9wOi03cHg7bWFyZ2luOjAgN3B4Oy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjo1MCUgMTAwJTt0cmFuc2Zvcm0tb3JpZ2luOjUwJSAxMDAlfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gLnRpcHB5LWJhY2tkcm9wey13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjowIC0xMDAlO3RyYW5zZm9ybS1vcmlnaW46MCAtMTAwJX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1ib3R0b21dIC50aXBweS1iYWNrZHJvcFtkYXRhLXN0YXRlPXZpc2libGVdey13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDUuNSkgdHJhbnNsYXRlKC01MCUsLTEyNSUpO3RyYW5zZm9ybTpzY2FsZSg1LjUpIHRyYW5zbGF0ZSgtNTAlLC0xMjUlKTtvcGFjaXR5OjF9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49Ym90dG9tXSAudGlwcHktYmFja2Ryb3BbZGF0YS1zdGF0ZT1oaWRkZW5dey13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDEpIHRyYW5zbGF0ZSgtNTAlLC0xMjUlKTt0cmFuc2Zvcm06c2NhbGUoMSkgdHJhbnNsYXRlKC01MCUsLTEyNSUpO29wYWNpdHk6MH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1ib3R0b21dIFtkYXRhLWFuaW1hdGlvbj1zaGlmdC10b3dhcmRdW2RhdGEtc3RhdGU9dmlzaWJsZV17b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTBweCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49Ym90dG9tXSBbZGF0YS1hbmltYXRpb249c2hpZnQtdG93YXJkXVtkYXRhLXN0YXRlPWhpZGRlbl17b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMjBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMjBweCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49Ym90dG9tXSBbZGF0YS1hbmltYXRpb249cGVyc3BlY3RpdmVdey13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjp0b3A7dHJhbnNmb3JtLW9yaWdpbjp0b3B9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49Ym90dG9tXSBbZGF0YS1hbmltYXRpb249cGVyc3BlY3RpdmVdW2RhdGEtc3RhdGU9dmlzaWJsZV17b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTBweCkgcm90YXRlWCgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgxMHB4KSByb3RhdGVYKDApfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gW2RhdGEtYW5pbWF0aW9uPXBlcnNwZWN0aXZlXVtkYXRhLXN0YXRlPWhpZGRlbl17b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCkgcm90YXRlWCgtOTBkZWcpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApIHJvdGF0ZVgoLTkwZGVnKX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1ib3R0b21dIFtkYXRhLWFuaW1hdGlvbj1mYWRlXVtkYXRhLXN0YXRlPXZpc2libGVde29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDEwcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDEwcHgpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gW2RhdGEtYW5pbWF0aW9uPWZhZGVdW2RhdGEtc3RhdGU9aGlkZGVuXXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgxMHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgxMHB4KX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1ib3R0b21dIFtkYXRhLWFuaW1hdGlvbj1zaGlmdC1hd2F5XVtkYXRhLXN0YXRlPXZpc2libGVde29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDEwcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDEwcHgpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gW2RhdGEtYW5pbWF0aW9uPXNoaWZ0LWF3YXldW2RhdGEtc3RhdGU9aGlkZGVuXXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1ib3R0b21dIFtkYXRhLWFuaW1hdGlvbj1zY2FsZV1bZGF0YS1zdGF0ZT12aXNpYmxlXXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgxMHB4KSBzY2FsZSgxKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgxMHB4KSBzY2FsZSgxKX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1ib3R0b21dIFtkYXRhLWFuaW1hdGlvbj1zY2FsZV1bZGF0YS1zdGF0ZT1oaWRkZW5de29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDApIHNjYWxlKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApIHNjYWxlKDApfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWxlZnRdIC50aXBweS1iYWNrZHJvcHtib3JkZXItcmFkaXVzOjMwJSAwIDAgMzAlfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWxlZnRdIC50aXBweS1yb3VuZGFycm93e3JpZ2h0Oi0xNnB4O21hcmdpbjo0cHggMDstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46MzMuMzMzMzMzMzMlIDUwJTt0cmFuc2Zvcm0tb3JpZ2luOjMzLjMzMzMzMzMzJSA1MCV9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49bGVmdF0gLnRpcHB5LXJvdW5kYXJyb3cgc3Zne3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoOTBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoOTBkZWcpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWxlZnRdIC50aXBweS1hcnJvd3tib3JkZXItbGVmdDo3cHggc29saWQgIzMzMztib3JkZXItdG9wOjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjdweCBzb2xpZCB0cmFuc3BhcmVudDtyaWdodDotN3B4O21hcmdpbjo0cHggMDstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46MCA1MCU7dHJhbnNmb3JtLW9yaWdpbjowIDUwJX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1sZWZ0XSAudGlwcHktYmFja2Ryb3B7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjEwMCUgMDt0cmFuc2Zvcm0tb3JpZ2luOjEwMCUgMH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1sZWZ0XSAudGlwcHktYmFja2Ryb3BbZGF0YS1zdGF0ZT12aXNpYmxlXXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSg1LjUpIHRyYW5zbGF0ZSgzMyUsLTUwJSk7dHJhbnNmb3JtOnNjYWxlKDUuNSkgdHJhbnNsYXRlKDMzJSwtNTAlKTtvcGFjaXR5OjF9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49bGVmdF0gLnRpcHB5LWJhY2tkcm9wW2RhdGEtc3RhdGU9aGlkZGVuXXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSgxLjUpIHRyYW5zbGF0ZSgzMyUsLTUwJSk7dHJhbnNmb3JtOnNjYWxlKDEuNSkgdHJhbnNsYXRlKDMzJSwtNTAlKTtvcGFjaXR5OjB9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49bGVmdF0gW2RhdGEtYW5pbWF0aW9uPXNoaWZ0LXRvd2FyZF1bZGF0YS1zdGF0ZT12aXNpYmxlXXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwcHgpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWxlZnRdIFtkYXRhLWFuaW1hdGlvbj1zaGlmdC10b3dhcmRdW2RhdGEtc3RhdGU9aGlkZGVuXXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtMjBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTIwcHgpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWxlZnRdIFtkYXRhLWFuaW1hdGlvbj1wZXJzcGVjdGl2ZV17LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOnJpZ2h0O3RyYW5zZm9ybS1vcmlnaW46cmlnaHR9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49bGVmdF0gW2RhdGEtYW5pbWF0aW9uPXBlcnNwZWN0aXZlXVtkYXRhLXN0YXRlPXZpc2libGVde29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMHB4KSByb3RhdGVZKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMHB4KSByb3RhdGVZKDApfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWxlZnRdIFtkYXRhLWFuaW1hdGlvbj1wZXJzcGVjdGl2ZV1bZGF0YS1zdGF0ZT1oaWRkZW5de29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDApIHJvdGF0ZVkoLTkwZGVnKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgwKSByb3RhdGVZKC05MGRlZyl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49bGVmdF0gW2RhdGEtYW5pbWF0aW9uPWZhZGVdW2RhdGEtc3RhdGU9dmlzaWJsZV17b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMHB4KX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1sZWZ0XSBbZGF0YS1hbmltYXRpb249ZmFkZV1bZGF0YS1zdGF0ZT1oaWRkZW5de29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTBweCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49bGVmdF0gW2RhdGEtYW5pbWF0aW9uPXNoaWZ0LWF3YXldW2RhdGEtc3RhdGU9dmlzaWJsZV17b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMHB4KX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1sZWZ0XSBbZGF0YS1hbmltYXRpb249c2hpZnQtYXdheV1bZGF0YS1zdGF0ZT1oaWRkZW5de29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDApfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWxlZnRdIFtkYXRhLWFuaW1hdGlvbj1zY2FsZV1bZGF0YS1zdGF0ZT12aXNpYmxlXXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTBweCkgc2NhbGUoMSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwcHgpIHNjYWxlKDEpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWxlZnRdIFtkYXRhLWFuaW1hdGlvbj1zY2FsZV1bZGF0YS1zdGF0ZT1oaWRkZW5de29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDApIHNjYWxlKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDApIHNjYWxlKDApfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXJpZ2h0XSAudGlwcHktYmFja2Ryb3B7Ym9yZGVyLXJhZGl1czowIDMwJSAzMCUgMH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1yaWdodF0gLnRpcHB5LXJvdW5kYXJyb3d7bGVmdDotMTZweDttYXJnaW46NHB4IDA7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjY2LjY2NjY2NjY2JSA1MCU7dHJhbnNmb3JtLW9yaWdpbjo2Ni42NjY2NjY2NiUgNTAlfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXJpZ2h0XSAudGlwcHktcm91bmRhcnJvdyBzdmd7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgtOTBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoLTkwZGVnKX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1yaWdodF0gLnRpcHB5LWFycm93e2JvcmRlci1yaWdodDo3cHggc29saWQgIzMzMztib3JkZXItdG9wOjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjdweCBzb2xpZCB0cmFuc3BhcmVudDtsZWZ0Oi03cHg7bWFyZ2luOjRweCAwOy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjoxMDAlIDUwJTt0cmFuc2Zvcm0tb3JpZ2luOjEwMCUgNTAlfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXJpZ2h0XSAudGlwcHktYmFja2Ryb3B7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOi0xMDAlIDA7dHJhbnNmb3JtLW9yaWdpbjotMTAwJSAwfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXJpZ2h0XSAudGlwcHktYmFja2Ryb3BbZGF0YS1zdGF0ZT12aXNpYmxlXXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSg1LjUpIHRyYW5zbGF0ZSgtMTMzJSwtNTAlKTt0cmFuc2Zvcm06c2NhbGUoNS41KSB0cmFuc2xhdGUoLTEzMyUsLTUwJSk7b3BhY2l0eToxfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXJpZ2h0XSAudGlwcHktYmFja2Ryb3BbZGF0YS1zdGF0ZT1oaWRkZW5dey13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDEuNSkgdHJhbnNsYXRlKC0xMzMlLC01MCUpO3RyYW5zZm9ybTpzY2FsZSgxLjUpIHRyYW5zbGF0ZSgtMTMzJSwtNTAlKTtvcGFjaXR5OjB9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIFtkYXRhLWFuaW1hdGlvbj1zaGlmdC10b3dhcmRdW2RhdGEtc3RhdGU9dmlzaWJsZV17b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTBweCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIFtkYXRhLWFuaW1hdGlvbj1zaGlmdC10b3dhcmRdW2RhdGEtc3RhdGU9aGlkZGVuXXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgyMHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgyMHB4KX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1yaWdodF0gW2RhdGEtYW5pbWF0aW9uPXBlcnNwZWN0aXZlXXstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46bGVmdDt0cmFuc2Zvcm0tb3JpZ2luOmxlZnR9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIFtkYXRhLWFuaW1hdGlvbj1wZXJzcGVjdGl2ZV1bZGF0YS1zdGF0ZT12aXNpYmxlXXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgxMHB4KSByb3RhdGVZKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDEwcHgpIHJvdGF0ZVkoMCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIFtkYXRhLWFuaW1hdGlvbj1wZXJzcGVjdGl2ZV1bZGF0YS1zdGF0ZT1oaWRkZW5de29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDApIHJvdGF0ZVkoOTBkZWcpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDApIHJvdGF0ZVkoOTBkZWcpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXJpZ2h0XSBbZGF0YS1hbmltYXRpb249ZmFkZV1bZGF0YS1zdGF0ZT12aXNpYmxlXXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgxMHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgxMHB4KX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1yaWdodF0gW2RhdGEtYW5pbWF0aW9uPWZhZGVdW2RhdGEtc3RhdGU9aGlkZGVuXXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgxMHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgxMHB4KX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1yaWdodF0gW2RhdGEtYW5pbWF0aW9uPXNoaWZ0LWF3YXldW2RhdGEtc3RhdGU9dmlzaWJsZV17b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTBweCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIFtkYXRhLWFuaW1hdGlvbj1zaGlmdC1hd2F5XVtkYXRhLXN0YXRlPWhpZGRlbl17b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIFtkYXRhLWFuaW1hdGlvbj1zY2FsZV1bZGF0YS1zdGF0ZT12aXNpYmxlXXtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgxMHB4KSBzY2FsZSgxKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgxMHB4KSBzY2FsZSgxKX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1yaWdodF0gW2RhdGEtYW5pbWF0aW9uPXNjYWxlXVtkYXRhLXN0YXRlPWhpZGRlbl17b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCkgc2NhbGUoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCkgc2NhbGUoMCl9LnRpcHB5LXRvb2x0aXB7cG9zaXRpb246cmVsYXRpdmU7Y29sb3I6I2ZmZjtib3JkZXItcmFkaXVzOjRweDtmb250LXNpemU6LjlyZW07cGFkZGluZzouM3JlbSAuNnJlbTt0ZXh0LWFsaWduOmNlbnRlcjt3aWxsLWNoYW5nZTp0cmFuc2Zvcm07LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7YmFja2dyb3VuZC1jb2xvcjojMzMzfS50aXBweS10b29sdGlwW2RhdGEtc2l6ZT1zbWFsbF17cGFkZGluZzouMnJlbSAuNHJlbTtmb250LXNpemU6Ljc1cmVtfS50aXBweS10b29sdGlwW2RhdGEtc2l6ZT1sYXJnZV17cGFkZGluZzouNHJlbSAuOHJlbTtmb250LXNpemU6MXJlbX0udGlwcHktdG9vbHRpcFtkYXRhLWFuaW1hdGVmaWxsXXtvdmVyZmxvdzpoaWRkZW47YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH0udGlwcHktdG9vbHRpcFtkYXRhLWFuaW1hdGVmaWxsXSAudGlwcHktY29udGVudHstd2Via2l0LXRyYW5zaXRpb246LXdlYmtpdC1jbGlwLXBhdGggY3ViaWMtYmV6aWVyKC40NiwuMSwuNTIsLjk4KTt0cmFuc2l0aW9uOi13ZWJraXQtY2xpcC1wYXRoIGN1YmljLWJlemllciguNDYsLjEsLjUyLC45OCk7dHJhbnNpdGlvbjpjbGlwLXBhdGggY3ViaWMtYmV6aWVyKC40NiwuMSwuNTIsLjk4KTt0cmFuc2l0aW9uOmNsaXAtcGF0aCBjdWJpYy1iZXppZXIoLjQ2LC4xLC41MiwuOTgpLC13ZWJraXQtY2xpcC1wYXRoIGN1YmljLWJlemllciguNDYsLjEsLjUyLC45OCl9LnRpcHB5LXRvb2x0aXBbZGF0YS1pbnRlcmFjdGl2ZV17cG9pbnRlci1ldmVudHM6YXV0b30udGlwcHktdG9vbHRpcFtkYXRhLWluZXJ0aWFdW2RhdGEtc3RhdGU9dmlzaWJsZV17LXdlYmtpdC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjUzLDIsLjM2LC44NSk7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC41MywyLC4zNiwuODUpfS50aXBweS10b29sdGlwW2RhdGEtaW5lcnRpYV1bZGF0YS1zdGF0ZT1oaWRkZW5dey13ZWJraXQtdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZTt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlfS50aXBweS1hcnJvdywudGlwcHktcm91bmRhcnJvd3twb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDowO2hlaWdodDowfS50aXBweS1yb3VuZGFycm93e3dpZHRoOjI0cHg7aGVpZ2h0OjhweDtmaWxsOiMzMzM7cG9pbnRlci1ldmVudHM6bm9uZX0udGlwcHktcm91bmRhcnJvdyBwYXRoe3BvaW50ZXItZXZlbnRzOmF1dG99LnRpcHB5LWJhY2tkcm9we3Bvc2l0aW9uOmFic29sdXRlO3dpbGwtY2hhbmdlOnRyYW5zZm9ybTtiYWNrZ3JvdW5kLWNvbG9yOiMzMzM7Ym9yZGVyLXJhZGl1czo1MCU7d2lkdGg6MjYlO2xlZnQ6NTAlO3RvcDo1MCU7ei1pbmRleDotMTstd2Via2l0LXRyYW5zaXRpb246YWxsIGN1YmljLWJlemllciguNDYsLjEsLjUyLC45OCk7dHJhbnNpdGlvbjphbGwgY3ViaWMtYmV6aWVyKC40NiwuMSwuNTIsLjk4KTstd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVuO2JhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVufS50aXBweS1iYWNrZHJvcDphZnRlcntjb250ZW50OlwiXCI7ZmxvYXQ6bGVmdDtwYWRkaW5nLXRvcDoxMDAlfWJvZHk6bm90KC50aXBweS10b3VjaCkgLnRpcHB5LXRvb2x0aXBbZGF0YS1hbmltYXRlZmlsbF1bZGF0YS1zdGF0ZT12aXNpYmxlXSAudGlwcHktY29udGVudHstd2Via2l0LWNsaXAtcGF0aDplbGxpcHNlKDEwMCUgMTAwJSBhdCA1MCUgNTAlKTtjbGlwLXBhdGg6ZWxsaXBzZSgxMDAlIDEwMCUgYXQgNTAlIDUwJSl9Ym9keTpub3QoLnRpcHB5LXRvdWNoKSAudGlwcHktdG9vbHRpcFtkYXRhLWFuaW1hdGVmaWxsXVtkYXRhLXN0YXRlPWhpZGRlbl0gLnRpcHB5LWNvbnRlbnR7LXdlYmtpdC1jbGlwLXBhdGg6ZWxsaXBzZSg1JSA1MCUgYXQgNTAlIDUwJSk7Y2xpcC1wYXRoOmVsbGlwc2UoNSUgNTAlIGF0IDUwJSA1MCUpfWJvZHk6bm90KC50aXBweS10b3VjaCkgLnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudD1yaWdodF0gLnRpcHB5LXRvb2x0aXBbZGF0YS1hbmltYXRlZmlsbF1bZGF0YS1zdGF0ZT12aXNpYmxlXSAudGlwcHktY29udGVudHstd2Via2l0LWNsaXAtcGF0aDplbGxpcHNlKDEzNSUgMTAwJSBhdCAwIDUwJSk7Y2xpcC1wYXRoOmVsbGlwc2UoMTM1JSAxMDAlIGF0IDAgNTAlKX1ib2R5Om5vdCgudGlwcHktdG91Y2gpIC50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnQ9cmlnaHRdIC50aXBweS10b29sdGlwW2RhdGEtYW5pbWF0ZWZpbGxdW2RhdGEtc3RhdGU9aGlkZGVuXSAudGlwcHktY29udGVudHstd2Via2l0LWNsaXAtcGF0aDplbGxpcHNlKDI1JSAxMDAlIGF0IDAgNTAlKTtjbGlwLXBhdGg6ZWxsaXBzZSgyNSUgMTAwJSBhdCAwIDUwJSl9Ym9keTpub3QoLnRpcHB5LXRvdWNoKSAudGlwcHktcG9wcGVyW3gtcGxhY2VtZW50PWxlZnRdIC50aXBweS10b29sdGlwW2RhdGEtYW5pbWF0ZWZpbGxdW2RhdGEtc3RhdGU9dmlzaWJsZV0gLnRpcHB5LWNvbnRlbnR7LXdlYmtpdC1jbGlwLXBhdGg6ZWxsaXBzZSgxMzUlIDEwMCUgYXQgMTAwJSA1MCUpO2NsaXAtcGF0aDplbGxpcHNlKDEzNSUgMTAwJSBhdCAxMDAlIDUwJSl9Ym9keTpub3QoLnRpcHB5LXRvdWNoKSAudGlwcHktcG9wcGVyW3gtcGxhY2VtZW50PWxlZnRdIC50aXBweS10b29sdGlwW2RhdGEtYW5pbWF0ZWZpbGxdW2RhdGEtc3RhdGU9aGlkZGVuXSAudGlwcHktY29udGVudHstd2Via2l0LWNsaXAtcGF0aDplbGxpcHNlKDI1JSAxMDAlIGF0IDEwMCUgNTAlKTtjbGlwLXBhdGg6ZWxsaXBzZSgyNSUgMTAwJSBhdCAxMDAlIDUwJSl9QG1lZGlhIChtYXgtd2lkdGg6MzYwcHgpey50aXBweS1wb3BwZXJ7bWF4LXdpZHRoOjk2JTttYXgtd2lkdGg6Y2FsYygxMDAlIC0gMjBweCl9fScpLHZ0fSk7XHJcbiIsIi8qKlxyXG4qIENvcHlyaWdodCAoYykgMjAyMywgTGVvbiBTb3Jva2luXHJcbiogQWxsIHJpZ2h0cyByZXNlcnZlZC4gKE1JVCBMaWNlbnNlZClcclxuKlxyXG4qIHVQbG90LmpzICjOvFBsb3QpXHJcbiogQSBzbWFsbCwgZmFzdCBjaGFydCBmb3IgdGltZSBzZXJpZXMsIGxpbmVzLCBhcmVhcywgb2hsYyAmIGJhcnNcclxuKiBodHRwczovL2dpdGh1Yi5jb20vbGVlb25peWEvdVBsb3QgKHYxLjYuMjUpXHJcbiovXHJcblxyXG5jb25zdCBGRUFUX1RJTUUgICAgICAgICAgPSB0cnVlO1xyXG5cclxuY29uc3QgcHJlID0gXCJ1LVwiO1xyXG5cclxuY29uc3QgVVBMT1QgICAgICAgICAgPSAgICAgICBcInVwbG90XCI7XHJcbmNvbnN0IE9SSV9IWiAgICAgICAgID0gcHJlICsgXCJoelwiO1xyXG5jb25zdCBPUklfVlQgICAgICAgICA9IHByZSArIFwidnRcIjtcclxuY29uc3QgVElUTEUgICAgICAgICAgPSBwcmUgKyBcInRpdGxlXCI7XHJcbmNvbnN0IFdSQVAgICAgICAgICAgID0gcHJlICsgXCJ3cmFwXCI7XHJcbmNvbnN0IFVOREVSICAgICAgICAgID0gcHJlICsgXCJ1bmRlclwiO1xyXG5jb25zdCBPVkVSICAgICAgICAgICA9IHByZSArIFwib3ZlclwiO1xyXG5jb25zdCBBWElTICAgICAgICAgICA9IHByZSArIFwiYXhpc1wiO1xyXG5jb25zdCBPRkYgICAgICAgICAgICA9IHByZSArIFwib2ZmXCI7XHJcbmNvbnN0IFNFTEVDVCAgICAgICAgID0gcHJlICsgXCJzZWxlY3RcIjtcclxuY29uc3QgQ1VSU09SX1ggICAgICAgPSBwcmUgKyBcImN1cnNvci14XCI7XHJcbmNvbnN0IENVUlNPUl9ZICAgICAgID0gcHJlICsgXCJjdXJzb3IteVwiO1xyXG5jb25zdCBDVVJTT1JfUFQgICAgICA9IHByZSArIFwiY3Vyc29yLXB0XCI7XHJcbmNvbnN0IExFR0VORCAgICAgICAgID0gcHJlICsgXCJsZWdlbmRcIjtcclxuY29uc3QgTEVHRU5EX0xJVkUgICAgPSBwcmUgKyBcImxpdmVcIjtcclxuY29uc3QgTEVHRU5EX0lOTElORSAgPSBwcmUgKyBcImlubGluZVwiO1xyXG5jb25zdCBMRUdFTkRfU0VSSUVTICA9IHByZSArIFwic2VyaWVzXCI7XHJcbmNvbnN0IExFR0VORF9NQVJLRVIgID0gcHJlICsgXCJtYXJrZXJcIjtcclxuY29uc3QgTEVHRU5EX0xBQkVMICAgPSBwcmUgKyBcImxhYmVsXCI7XHJcbmNvbnN0IExFR0VORF9WQUxVRSAgID0gcHJlICsgXCJ2YWx1ZVwiO1xyXG5cclxuY29uc3QgV0lEVEggICAgICAgPSBcIndpZHRoXCI7XHJcbmNvbnN0IEhFSUdIVCAgICAgID0gXCJoZWlnaHRcIjtcclxuY29uc3QgVE9QICAgICAgICAgPSBcInRvcFwiO1xyXG5jb25zdCBCT1RUT00gICAgICA9IFwiYm90dG9tXCI7XHJcbmNvbnN0IExFRlQgICAgICAgID0gXCJsZWZ0XCI7XHJcbmNvbnN0IFJJR0hUICAgICAgID0gXCJyaWdodFwiO1xyXG5jb25zdCBoZXhCbGFjayAgICA9IFwiIzAwMFwiO1xyXG5jb25zdCB0cmFuc3BhcmVudCA9IGhleEJsYWNrICsgXCIwXCI7XHJcblxyXG5jb25zdCBtb3VzZW1vdmUgICA9IFwibW91c2Vtb3ZlXCI7XHJcbmNvbnN0IG1vdXNlZG93biAgID0gXCJtb3VzZWRvd25cIjtcclxuY29uc3QgbW91c2V1cCAgICAgPSBcIm1vdXNldXBcIjtcclxuY29uc3QgbW91c2VlbnRlciAgPSBcIm1vdXNlZW50ZXJcIjtcclxuY29uc3QgbW91c2VsZWF2ZSAgPSBcIm1vdXNlbGVhdmVcIjtcclxuY29uc3QgZGJsY2xpY2sgICAgPSBcImRibGNsaWNrXCI7XHJcbmNvbnN0IHJlc2l6ZSAgICAgID0gXCJyZXNpemVcIjtcclxuY29uc3Qgc2Nyb2xsICAgICAgPSBcInNjcm9sbFwiO1xyXG5cclxuY29uc3QgY2hhbmdlICAgICAgPSBcImNoYW5nZVwiO1xyXG5jb25zdCBkcHB4Y2hhbmdlICA9IFwiZHBweGNoYW5nZVwiO1xyXG5cclxuY29uc3QgTEVHRU5EX0RJU1AgPSBcIi0tXCI7XHJcblxyXG5jb25zdCBkb21FbnYgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnO1xyXG5cclxuY29uc3QgZG9jID0gZG9tRW52ID8gZG9jdW1lbnQgIDogbnVsbDtcclxuY29uc3Qgd2luID0gZG9tRW52ID8gd2luZG93ICAgIDogbnVsbDtcclxuY29uc3QgbmF2ID0gZG9tRW52ID8gbmF2aWdhdG9yIDogbnVsbDtcclxuXHJcbmxldCBweFJhdGlvO1xyXG5cclxuLy9leHBvcnQgY29uc3QgY2FuSG92ZXIgPSBkb21FbnYgJiYgIXdpbi5tYXRjaE1lZGlhKCcoaG92ZXI6IG5vbmUpJykubWF0Y2hlcztcclxuXHJcbmxldCBxdWVyeTtcclxuXHJcbmZ1bmN0aW9uIHNldFB4UmF0aW8oKSB7XHJcblx0bGV0IF9weFJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbztcclxuXHJcblx0Ly8gZHVyaW5nIHByaW50IHByZXZpZXcsIENocm9tZSBmaXJlcyBvZmYgdGhlc2UgZHBweCBxdWVyaWVzIGV2ZW4gd2l0aG91dCBjaGFuZ2VzXHJcblx0aWYgKHB4UmF0aW8gIT0gX3B4UmF0aW8pIHtcclxuXHRcdHB4UmF0aW8gPSBfcHhSYXRpbztcclxuXHJcblx0XHRxdWVyeSAmJiBvZmYoY2hhbmdlLCBxdWVyeSwgc2V0UHhSYXRpbyk7XHJcblx0XHRxdWVyeSA9IG1hdGNoTWVkaWEoYChtaW4tcmVzb2x1dGlvbjogJHtweFJhdGlvIC0gMC4wMDF9ZHBweCkgYW5kIChtYXgtcmVzb2x1dGlvbjogJHtweFJhdGlvICsgMC4wMDF9ZHBweClgKTtcclxuXHRcdG9uKGNoYW5nZSwgcXVlcnksIHNldFB4UmF0aW8pO1xyXG5cclxuXHRcdHdpbi5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChkcHB4Y2hhbmdlKSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgYykge1xyXG5cdGlmIChjICE9IG51bGwpIHtcclxuXHRcdGxldCBjbCA9IGVsLmNsYXNzTGlzdDtcclxuXHRcdCFjbC5jb250YWlucyhjKSAmJiBjbC5hZGQoYyk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1DbGFzcyhlbCwgYykge1xyXG5cdGxldCBjbCA9IGVsLmNsYXNzTGlzdDtcclxuXHRjbC5jb250YWlucyhjKSAmJiBjbC5yZW1vdmUoYyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFN0eWxlUHgoZWwsIG5hbWUsIHZhbHVlKSB7XHJcblx0ZWwuc3R5bGVbbmFtZV0gPSB2YWx1ZSArIFwicHhcIjtcclxufVxyXG5cclxuZnVuY3Rpb24gcGxhY2VUYWcodGFnLCBjbHMsIHRhcmcsIHJlZkVsKSB7XHJcblx0bGV0IGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQodGFnKTtcclxuXHJcblx0aWYgKGNscyAhPSBudWxsKVxyXG5cdFx0YWRkQ2xhc3MoZWwsIGNscyk7XHJcblxyXG5cdGlmICh0YXJnICE9IG51bGwpXHJcblx0XHR0YXJnLmluc2VydEJlZm9yZShlbCwgcmVmRWwpO1xyXG5cclxuXHRyZXR1cm4gZWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBsYWNlRGl2KGNscywgdGFyZykge1xyXG5cdHJldHVybiBwbGFjZVRhZyhcImRpdlwiLCBjbHMsIHRhcmcpO1xyXG59XHJcblxyXG5jb25zdCB4Zm9ybUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbmZ1bmN0aW9uIGVsVHJhbnMoZWwsIHhQb3MsIHlQb3MsIHhNYXgsIHlNYXgpIHtcclxuXHRsZXQgeGZvcm0gPSBcInRyYW5zbGF0ZShcIiArIHhQb3MgKyBcInB4LFwiICsgeVBvcyArIFwicHgpXCI7XHJcblx0bGV0IHhmb3JtT2xkID0geGZvcm1DYWNoZS5nZXQoZWwpO1xyXG5cclxuXHRpZiAoeGZvcm0gIT0geGZvcm1PbGQpIHtcclxuXHRcdGVsLnN0eWxlLnRyYW5zZm9ybSA9IHhmb3JtO1xyXG5cdFx0eGZvcm1DYWNoZS5zZXQoZWwsIHhmb3JtKTtcclxuXHJcblx0XHRpZiAoeFBvcyA8IDAgfHwgeVBvcyA8IDAgfHwgeFBvcyA+IHhNYXggfHwgeVBvcyA+IHlNYXgpXHJcblx0XHRcdGFkZENsYXNzKGVsLCBPRkYpO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRyZW1DbGFzcyhlbCwgT0ZGKTtcclxuXHR9XHJcbn1cclxuXHJcbmNvbnN0IGNvbG9yQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuZnVuY3Rpb24gZWxDb2xvcihlbCwgYmFja2dyb3VuZCwgYm9yZGVyQ29sb3IpIHtcclxuXHRsZXQgbmV3Q29sb3IgPSBiYWNrZ3JvdW5kICsgYm9yZGVyQ29sb3I7XHJcblx0bGV0IG9sZENvbG9yID0gY29sb3JDYWNoZS5nZXQoZWwpO1xyXG5cclxuXHRpZiAobmV3Q29sb3IgIT0gb2xkQ29sb3IpIHtcclxuXHRcdGNvbG9yQ2FjaGUuc2V0KGVsLCBuZXdDb2xvcik7XHJcblx0XHRlbC5zdHlsZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcclxuXHRcdGVsLnN0eWxlLmJvcmRlckNvbG9yID0gYm9yZGVyQ29sb3I7XHJcblx0fVxyXG59XHJcblxyXG5jb25zdCBzaXplQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xyXG5cclxuZnVuY3Rpb24gZWxTaXplKGVsLCBuZXdXaWQsIG5ld0hndCwgY2VudGVyZWQpIHtcclxuXHRsZXQgbmV3U2l6ZSA9IG5ld1dpZCArIFwiXCIgKyBuZXdIZ3Q7XHJcblx0bGV0IG9sZFNpemUgPSBzaXplQ2FjaGUuZ2V0KGVsKTtcclxuXHJcblx0aWYgKG5ld1NpemUgIT0gb2xkU2l6ZSkge1xyXG5cdFx0c2l6ZUNhY2hlLnNldChlbCwgbmV3U2l6ZSk7XHJcblx0XHRlbC5zdHlsZS5oZWlnaHQgPSBuZXdIZ3QgKyBcInB4XCI7XHJcblx0XHRlbC5zdHlsZS53aWR0aCA9IG5ld1dpZCArIFwicHhcIjtcclxuXHRcdGVsLnN0eWxlLm1hcmdpbkxlZnQgPSBjZW50ZXJlZCA/IC1uZXdXaWQvMiArIFwicHhcIiA6IDA7XHJcblx0XHRlbC5zdHlsZS5tYXJnaW5Ub3AgPSBjZW50ZXJlZCA/IC1uZXdIZ3QvMiArIFwicHhcIiA6IDA7XHJcblx0fVxyXG59XHJcblxyXG5jb25zdCBldk9wdHMgPSB7cGFzc2l2ZTogdHJ1ZX07XHJcbmNvbnN0IGV2T3B0czIgPSB7Li4uZXZPcHRzLCBjYXB0dXJlOiB0cnVlfTtcclxuXHJcbmZ1bmN0aW9uIG9uKGV2LCBlbCwgY2IsIGNhcHQpIHtcclxuXHRlbC5hZGRFdmVudExpc3RlbmVyKGV2LCBjYiwgY2FwdCA/IGV2T3B0czIgOiBldk9wdHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvZmYoZXYsIGVsLCBjYiwgY2FwdCkge1xyXG5cdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXYsIGNiLCBjYXB0ID8gZXZPcHRzMiA6IGV2T3B0cyk7XHJcbn1cclxuXHJcbmRvbUVudiAmJiBzZXRQeFJhdGlvKCk7XHJcblxyXG4vLyBiaW5hcnkgc2VhcmNoIGZvciBpbmRleCBvZiBjbG9zZXN0IHZhbHVlXHJcbmZ1bmN0aW9uIGNsb3Nlc3RJZHgobnVtLCBhcnIsIGxvLCBoaSkge1xyXG5cdGxldCBtaWQ7XHJcblx0bG8gPSBsbyB8fCAwO1xyXG5cdGhpID0gaGkgfHwgYXJyLmxlbmd0aCAtIDE7XHJcblx0bGV0IGJpdHdpc2UgPSBoaSA8PSAyMTQ3NDgzNjQ3O1xyXG5cclxuXHR3aGlsZSAoaGkgLSBsbyA+IDEpIHtcclxuXHRcdG1pZCA9IGJpdHdpc2UgPyAobG8gKyBoaSkgPj4gMSA6IGZsb29yKChsbyArIGhpKSAvIDIpO1xyXG5cclxuXHRcdGlmIChhcnJbbWlkXSA8IG51bSlcclxuXHRcdFx0bG8gPSBtaWQ7XHJcblx0XHRlbHNlXHJcblx0XHRcdGhpID0gbWlkO1xyXG5cdH1cclxuXHJcblx0aWYgKG51bSAtIGFycltsb10gPD0gYXJyW2hpXSAtIG51bSlcclxuXHRcdHJldHVybiBsbztcclxuXHJcblx0cmV0dXJuIGhpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub25OdWxsSWR4KGRhdGEsIF9pMCwgX2kxLCBkaXIpIHtcclxuXHRmb3IgKGxldCBpID0gZGlyID09IDEgPyBfaTAgOiBfaTE7IGkgPj0gX2kwICYmIGkgPD0gX2kxOyBpICs9IGRpcikge1xyXG5cdFx0aWYgKGRhdGFbaV0gIT0gbnVsbClcclxuXHRcdFx0cmV0dXJuIGk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gLTE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE1pbk1heChkYXRhLCBfaTAsIF9pMSwgc29ydGVkKSB7XHJcbi8vXHRjb25zb2xlLmxvZyhcImdldE1pbk1heCgpXCIpO1xyXG5cclxuXHRsZXQgX21pbiA9IGluZjtcclxuXHRsZXQgX21heCA9IC1pbmY7XHJcblxyXG5cdGlmIChzb3J0ZWQgPT0gMSkge1xyXG5cdFx0X21pbiA9IGRhdGFbX2kwXTtcclxuXHRcdF9tYXggPSBkYXRhW19pMV07XHJcblx0fVxyXG5cdGVsc2UgaWYgKHNvcnRlZCA9PSAtMSkge1xyXG5cdFx0X21pbiA9IGRhdGFbX2kxXTtcclxuXHRcdF9tYXggPSBkYXRhW19pMF07XHJcblx0fVxyXG5cdGVsc2Uge1xyXG5cdFx0Zm9yIChsZXQgaSA9IF9pMDsgaSA8PSBfaTE7IGkrKykge1xyXG5cdFx0XHRsZXQgdiA9IGRhdGFbaV07XHJcblxyXG5cdFx0XHRpZiAodiAhPSBudWxsKSB7XHJcblx0XHRcdFx0aWYgKHYgPCBfbWluKVxyXG5cdFx0XHRcdFx0X21pbiA9IHY7XHJcblx0XHRcdFx0aWYgKHYgPiBfbWF4KVxyXG5cdFx0XHRcdFx0X21heCA9IHY7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBbX21pbiwgX21heF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE1pbk1heExvZyhkYXRhLCBfaTAsIF9pMSkge1xyXG4vL1x0Y29uc29sZS5sb2coXCJnZXRNaW5NYXgoKVwiKTtcclxuXHJcblx0bGV0IF9taW4gPSBpbmY7XHJcblx0bGV0IF9tYXggPSAtaW5mO1xyXG5cclxuXHRmb3IgKGxldCBpID0gX2kwOyBpIDw9IF9pMTsgaSsrKSB7XHJcblx0XHRsZXQgdiA9IGRhdGFbaV07XHJcblxyXG5cdFx0aWYgKHYgIT0gbnVsbCAmJiB2ID4gMCkge1xyXG5cdFx0XHRpZiAodiA8IF9taW4pXHJcblx0XHRcdFx0X21pbiA9IHY7XHJcblx0XHRcdGlmICh2ID4gX21heClcclxuXHRcdFx0XHRfbWF4ID0gdjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBbXHJcblx0XHRfbWluID09ICBpbmYgPyAgMSA6IF9taW4sXHJcblx0XHRfbWF4ID09IC1pbmYgPyAxMCA6IF9tYXgsXHJcblx0XTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmFuZ2VMb2cobWluLCBtYXgsIGJhc2UsIGZ1bGxNYWdzKSB7XHJcblx0bGV0IG1pblNpZ24gPSBzaWduKG1pbik7XHJcblx0bGV0IG1heFNpZ24gPSBzaWduKG1heCk7XHJcblxyXG5cdGxldCBsb2dGbiA9IGJhc2UgPT0gMTAgPyBsb2cxMCA6IGxvZzI7XHJcblxyXG5cdGlmIChtaW4gPT0gbWF4KSB7XHJcblx0XHRpZiAobWluU2lnbiA9PSAtMSkge1xyXG5cdFx0XHRtaW4gKj0gYmFzZTtcclxuXHRcdFx0bWF4IC89IGJhc2U7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0bWluIC89IGJhc2U7XHJcblx0XHRcdG1heCAqPSBiYXNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0bGV0IGdyb3dNaW5BYnMgPSBtaW5TaWduID09IDEgPyBmbG9vciA6IGNlaWw7XHJcblx0bGV0IGdyb3dNYXhBYnMgPSBtYXhTaWduID09IDEgPyBjZWlsIDogZmxvb3I7XHJcblxyXG5cdGxldCBtaW5FeHAgPSBncm93TWluQWJzKGxvZ0ZuKGFicyhtaW4pKSk7XHJcblx0bGV0IG1heEV4cCA9IGdyb3dNYXhBYnMobG9nRm4oYWJzKG1heCkpKTtcclxuXHJcblx0bGV0IG1pbkluY3IgPSBwb3coYmFzZSwgbWluRXhwKTtcclxuXHRsZXQgbWF4SW5jciA9IHBvdyhiYXNlLCBtYXhFeHApO1xyXG5cclxuXHQvLyBmaXggdmFsdWVzIGxpa2UgTWF0aC5wb3coMTAsIC01KSA9PT0gMC4wMDAwMDk5OTk5OTk5OTk5OTk5OTlcclxuXHRpZiAoYmFzZSA9PSAxMCkge1xyXG5cdFx0aWYgKG1pbkV4cCA8IDApXHJcblx0XHRcdG1pbkluY3IgPSByb3VuZERlYyhtaW5JbmNyLCAtbWluRXhwKTtcclxuXHRcdGlmIChtYXhFeHAgPCAwKVxyXG5cdFx0XHRtYXhJbmNyID0gcm91bmREZWMobWF4SW5jciwgLW1heEV4cCk7XHJcblx0fVxyXG5cclxuXHRpZiAoZnVsbE1hZ3MgfHwgYmFzZSA9PSAyKSB7XHJcblx0XHRtaW4gPSBtaW5JbmNyICogbWluU2lnbjtcclxuXHRcdG1heCA9IG1heEluY3IgKiBtYXhTaWduO1xyXG5cdH1cclxuXHRlbHNlIHtcclxuXHRcdG1pbiA9IGluY3JSb3VuZERuKG1pbiwgbWluSW5jcik7XHJcblx0XHRtYXggPSBpbmNyUm91bmRVcChtYXgsIG1heEluY3IpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIFttaW4sIG1heF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJhbmdlQXNpbmgobWluLCBtYXgsIGJhc2UsIGZ1bGxNYWdzKSB7XHJcblx0bGV0IG1pbk1heCA9IHJhbmdlTG9nKG1pbiwgbWF4LCBiYXNlLCBmdWxsTWFncyk7XHJcblxyXG5cdGlmIChtaW4gPT0gMClcclxuXHRcdG1pbk1heFswXSA9IDA7XHJcblxyXG5cdGlmIChtYXggPT0gMClcclxuXHRcdG1pbk1heFsxXSA9IDA7XHJcblxyXG5cdHJldHVybiBtaW5NYXg7XHJcbn1cclxuXHJcbmNvbnN0IHJhbmdlUGFkID0gMC4xO1xyXG5cclxuY29uc3QgYXV0b1JhbmdlUGFydCA9IHtcclxuXHRtb2RlOiAzLFxyXG5cdHBhZDogcmFuZ2VQYWQsXHJcbn07XHJcblxyXG5jb25zdCBfZXFSYW5nZVBhcnQgPSB7XHJcblx0cGFkOiAgMCxcclxuXHRzb2Z0OiBudWxsLFxyXG5cdG1vZGU6IDAsXHJcbn07XHJcblxyXG5jb25zdCBfZXFSYW5nZSA9IHtcclxuXHRtaW46IF9lcVJhbmdlUGFydCxcclxuXHRtYXg6IF9lcVJhbmdlUGFydCxcclxufTtcclxuXHJcbi8vIHRoaXMgZW5zdXJlcyB0aGF0IG5vbi10ZW1wb3JhbC9udW1lcmljIHktYXhlcyBnZXQgbXVsdGlwbGUtc25hcHBlZCBwYWRkaW5nIGFkZGVkIGFib3ZlL2JlbG93XHJcbi8vIFRPRE86IGFsc28gYWNjb3VudCBmb3IgaW5jcnMgd2hlbiBzbmFwcGluZyB0byBlbnN1cmUgdG9wIG9mIGF4aXMgZ2V0cyBhIHRpY2sgJiB2YWx1ZVxyXG5mdW5jdGlvbiByYW5nZU51bShfbWluLCBfbWF4LCBtdWx0LCBleHRyYSkge1xyXG5cdGlmIChpc09iaihtdWx0KSlcclxuXHRcdHJldHVybiBfcmFuZ2VOdW0oX21pbiwgX21heCwgbXVsdCk7XHJcblxyXG5cdF9lcVJhbmdlUGFydC5wYWQgID0gbXVsdDtcclxuXHRfZXFSYW5nZVBhcnQuc29mdCA9IGV4dHJhID8gMCA6IG51bGw7XHJcblx0X2VxUmFuZ2VQYXJ0Lm1vZGUgPSBleHRyYSA/IDMgOiAwO1xyXG5cclxuXHRyZXR1cm4gX3JhbmdlTnVtKF9taW4sIF9tYXgsIF9lcVJhbmdlKTtcclxufVxyXG5cclxuLy8gbnVsbGlzaCBjb2FsZXNjZVxyXG5mdW5jdGlvbiBpZk51bGwobGgsIHJoKSB7XHJcblx0cmV0dXJuIGxoID09IG51bGwgPyByaCA6IGxoO1xyXG59XHJcblxyXG4vLyBjaGVja3MgaWYgZ2l2ZW4gaW5kZXggcmFuZ2UgaW4gYW4gYXJyYXkgY29udGFpbnMgYSBub24tbnVsbCB2YWx1ZVxyXG4vLyBha2EgYSByYW5nZS1ib3VuZGVkIEFycmF5LnNvbWUoKVxyXG5mdW5jdGlvbiBoYXNEYXRhKGRhdGEsIGlkeDAsIGlkeDEpIHtcclxuXHRpZHgwID0gaWZOdWxsKGlkeDAsIDApO1xyXG5cdGlkeDEgPSBpZk51bGwoaWR4MSwgZGF0YS5sZW5ndGggLSAxKTtcclxuXHJcblx0d2hpbGUgKGlkeDAgPD0gaWR4MSkge1xyXG5cdFx0aWYgKGRhdGFbaWR4MF0gIT0gbnVsbClcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRpZHgwKys7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9yYW5nZU51bShfbWluLCBfbWF4LCBjZmcpIHtcclxuXHRsZXQgY21pbiA9IGNmZy5taW47XHJcblx0bGV0IGNtYXggPSBjZmcubWF4O1xyXG5cclxuXHRsZXQgcGFkTWluID0gaWZOdWxsKGNtaW4ucGFkLCAwKTtcclxuXHRsZXQgcGFkTWF4ID0gaWZOdWxsKGNtYXgucGFkLCAwKTtcclxuXHJcblx0bGV0IGhhcmRNaW4gPSBpZk51bGwoY21pbi5oYXJkLCAtaW5mKTtcclxuXHRsZXQgaGFyZE1heCA9IGlmTnVsbChjbWF4LmhhcmQsICBpbmYpO1xyXG5cclxuXHRsZXQgc29mdE1pbiA9IGlmTnVsbChjbWluLnNvZnQsICBpbmYpO1xyXG5cdGxldCBzb2Z0TWF4ID0gaWZOdWxsKGNtYXguc29mdCwgLWluZik7XHJcblxyXG5cdGxldCBzb2Z0TWluTW9kZSA9IGlmTnVsbChjbWluLm1vZGUsIDApO1xyXG5cdGxldCBzb2Z0TWF4TW9kZSA9IGlmTnVsbChjbWF4Lm1vZGUsIDApO1xyXG5cclxuXHRsZXQgZGVsdGEgPSBfbWF4IC0gX21pbjtcclxuXHRsZXQgZGVsdGFNYWcgPSBsb2cxMChkZWx0YSk7XHJcblxyXG5cdGxldCBzY2FsYXJNYXggPSBtYXgoYWJzKF9taW4pLCBhYnMoX21heCkpO1xyXG5cdGxldCBzY2FsYXJNYWcgPSBsb2cxMChzY2FsYXJNYXgpO1xyXG5cclxuXHRsZXQgc2NhbGFyTWFnRGVsdGEgPSBhYnMoc2NhbGFyTWFnIC0gZGVsdGFNYWcpO1xyXG5cclxuXHQvLyB0aGlzIGhhbmRsZXMgc2l0dWF0aW9ucyBsaWtlIDg5LjcsIDg5LjY5OTk5OTk5OTk5OTk5XHJcblx0Ly8gYnkgYXNzdW1pbmcgMC4wMDF4IGRlbHRhcyBhcmUgcHJlY2lzaW9uIGVycm9yc1xyXG4vL1x0aWYgKGRlbHRhID4gMCAmJiBkZWx0YSA8IGFicyhfbWF4KSAvIDFlMylcclxuLy9cdFx0ZGVsdGEgPSAwO1xyXG5cclxuXHQvLyB0cmVhdCBkYXRhIGFzIGZsYXQgaWYgZGVsdGEgaXMgbGVzcyB0aGFuIDEgYmlsbGlvbnRoXHJcblx0Ly8gb3IgcmFuZ2UgaXMgMTErIG9yZGVycyBvZiBtYWduaXR1ZGUgYmVsb3cgcmF3IHZhbHVlcywgZS5nLiA5OTk5OTk5OS45OTk5OTk5NiAtIDEwMDAwMDAwMC4wMDAwMDAwNFxyXG5cdGlmIChkZWx0YSA8IDFlLTkgfHwgc2NhbGFyTWFnRGVsdGEgPiAxMCkge1xyXG5cdFx0ZGVsdGEgPSAwO1xyXG5cclxuXHRcdC8vIGlmIHNvZnQgbW9kZSBpcyAyIGFuZCBhbGwgdmFscyBhcmUgZmxhdCBhdCAwLCBhdm9pZCB0aGUgMC4xICogMWUzIGZhbGxiYWNrXHJcblx0XHQvLyB0aGlzIHByZXZlbnRzIDAsMCwwIGZyb20gcmFuZ2luZyB0byAtMTAwLDEwMCB3aGVuIHNvZnRNaW4vc29mdE1heCBhcmUgLTEsMVxyXG5cdFx0aWYgKF9taW4gPT0gMCB8fCBfbWF4ID09IDApIHtcclxuXHRcdFx0ZGVsdGEgPSAxZS05O1xyXG5cclxuXHRcdFx0aWYgKHNvZnRNaW5Nb2RlID09IDIgJiYgc29mdE1pbiAhPSBpbmYpXHJcblx0XHRcdFx0cGFkTWluID0gMDtcclxuXHJcblx0XHRcdGlmIChzb2Z0TWF4TW9kZSA9PSAyICYmIHNvZnRNYXggIT0gLWluZilcclxuXHRcdFx0XHRwYWRNYXggPSAwO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0bGV0IG5vblplcm9EZWx0YSA9IGRlbHRhIHx8IHNjYWxhck1heCB8fCAxZTM7XHJcblx0bGV0IG1hZyAgICAgICAgICA9IGxvZzEwKG5vblplcm9EZWx0YSk7XHJcblx0bGV0IGJhc2UgICAgICAgICA9IHBvdygxMCwgZmxvb3IobWFnKSk7XHJcblxyXG5cdGxldCBfcGFkTWluICA9IG5vblplcm9EZWx0YSAqIChkZWx0YSA9PSAwID8gKF9taW4gPT0gMCA/IC4xIDogMSkgOiBwYWRNaW4pO1xyXG5cdGxldCBfbmV3TWluICA9IHJvdW5kRGVjKGluY3JSb3VuZERuKF9taW4gLSBfcGFkTWluLCBiYXNlLzEwKSwgOSk7XHJcblx0bGV0IF9zb2Z0TWluID0gX21pbiA+PSBzb2Z0TWluICYmIChzb2Z0TWluTW9kZSA9PSAxIHx8IHNvZnRNaW5Nb2RlID09IDMgJiYgX25ld01pbiA8PSBzb2Z0TWluIHx8IHNvZnRNaW5Nb2RlID09IDIgJiYgX25ld01pbiA+PSBzb2Z0TWluKSA/IHNvZnRNaW4gOiBpbmY7XHJcblx0bGV0IG1pbkxpbSAgID0gbWF4KGhhcmRNaW4sIF9uZXdNaW4gPCBfc29mdE1pbiAmJiBfbWluID49IF9zb2Z0TWluID8gX3NvZnRNaW4gOiBtaW4oX3NvZnRNaW4sIF9uZXdNaW4pKTtcclxuXHJcblx0bGV0IF9wYWRNYXggID0gbm9uWmVyb0RlbHRhICogKGRlbHRhID09IDAgPyAoX21heCA9PSAwID8gLjEgOiAxKSA6IHBhZE1heCk7XHJcblx0bGV0IF9uZXdNYXggID0gcm91bmREZWMoaW5jclJvdW5kVXAoX21heCArIF9wYWRNYXgsIGJhc2UvMTApLCA5KTtcclxuXHRsZXQgX3NvZnRNYXggPSBfbWF4IDw9IHNvZnRNYXggJiYgKHNvZnRNYXhNb2RlID09IDEgfHwgc29mdE1heE1vZGUgPT0gMyAmJiBfbmV3TWF4ID49IHNvZnRNYXggfHwgc29mdE1heE1vZGUgPT0gMiAmJiBfbmV3TWF4IDw9IHNvZnRNYXgpID8gc29mdE1heCA6IC1pbmY7XHJcblx0bGV0IG1heExpbSAgID0gbWluKGhhcmRNYXgsIF9uZXdNYXggPiBfc29mdE1heCAmJiBfbWF4IDw9IF9zb2Z0TWF4ID8gX3NvZnRNYXggOiBtYXgoX3NvZnRNYXgsIF9uZXdNYXgpKTtcclxuXHJcblx0aWYgKG1pbkxpbSA9PSBtYXhMaW0gJiYgbWluTGltID09IDApXHJcblx0XHRtYXhMaW0gPSAxMDA7XHJcblxyXG5cdHJldHVybiBbbWluTGltLCBtYXhMaW1dO1xyXG59XHJcblxyXG4vLyBhbHRlcm5hdGl2ZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNTQ4OTZcclxuY29uc3QgbnVtRm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGRvbUVudiA/IG5hdi5sYW5ndWFnZSA6ICdlbi1VUycpO1xyXG5jb25zdCBmbXROdW0gPSB2YWwgPT4gbnVtRm9ybWF0dGVyLmZvcm1hdCh2YWwpO1xyXG5cclxuY29uc3QgTSA9IE1hdGg7XHJcblxyXG5jb25zdCBQSSA9IE0uUEk7XHJcbmNvbnN0IGFicyA9IE0uYWJzO1xyXG5jb25zdCBmbG9vciA9IE0uZmxvb3I7XHJcbmNvbnN0IHJvdW5kID0gTS5yb3VuZDtcclxuY29uc3QgY2VpbCA9IE0uY2VpbDtcclxuY29uc3QgbWluID0gTS5taW47XHJcbmNvbnN0IG1heCA9IE0ubWF4O1xyXG5jb25zdCBwb3cgPSBNLnBvdztcclxuY29uc3Qgc2lnbiA9IE0uc2lnbjtcclxuY29uc3QgbG9nMTAgPSBNLmxvZzEwO1xyXG5jb25zdCBsb2cyID0gTS5sb2cyO1xyXG4vLyBUT0RPOiBzZWVtcyBsaWtlIHRoaXMgbmVlZHMgdG8gbWF0Y2ggYXNpbmggaW1wbCBpZiB0aGUgcGFzc2VkIHYgaXMgdHdlYWtlZD9cclxuY29uc3Qgc2luaCA9ICAodiwgbGludGhyZXNoID0gMSkgPT4gTS5zaW5oKHYpICogbGludGhyZXNoO1xyXG5jb25zdCBhc2luaCA9ICh2LCBsaW50aHJlc2ggPSAxKSA9PiBNLmFzaW5oKHYgLyBsaW50aHJlc2gpO1xyXG5cclxuY29uc3QgaW5mID0gSW5maW5pdHk7XHJcblxyXG5mdW5jdGlvbiBudW1JbnREaWdpdHMoeCkge1xyXG5cdHJldHVybiAobG9nMTAoKHggXiAoeCA+PiAzMSkpIC0gKHggPj4gMzEpKSB8IDApICsgMTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2xhbXAobnVtLCBfbWluLCBfbWF4KSB7XHJcblx0cmV0dXJuIG1pbihtYXgobnVtLCBfbWluKSwgX21heCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZuT3JTZWxmKHYpIHtcclxuXHRyZXR1cm4gdHlwZW9mIHYgPT0gXCJmdW5jdGlvblwiID8gdiA6ICgpID0+IHY7XHJcbn1cclxuXHJcbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcclxuXHJcbmNvbnN0IHJldEFyZzAgPSBfMCA9PiBfMDtcclxuXHJcbmNvbnN0IHJldEFyZzEgPSAoXzAsIF8xKSA9PiBfMTtcclxuXHJcbmNvbnN0IHJldE51bGwgPSBfID0+IG51bGw7XHJcblxyXG5jb25zdCByZXRUcnVlID0gXyA9PiB0cnVlO1xyXG5cclxuY29uc3QgcmV0RXEgPSAoYSwgYikgPT4gYSA9PSBiO1xyXG5cclxuLy8gdGhpcyB3aWxsIHByb2JhYmx5IHByZXZlbnQgdGljayBpbmNycyA+IDE0IGRlY2ltYWwgcGxhY2VzXHJcbi8vICh3ZSBnZW5lcmF0ZSB1cCB0byAxNyBkZWMsIHNlZSBmaXhlZERlYyBjb25zdClcclxuY29uc3QgZml4RmxvYXQgPSB2ID0+IHJvdW5kRGVjKHYsIDE0KTtcclxuXHJcbmZ1bmN0aW9uIGluY3JSb3VuZChudW0sIGluY3IpIHtcclxuXHRyZXR1cm4gZml4RmxvYXQocm91bmREZWMoZml4RmxvYXQobnVtL2luY3IpKSppbmNyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5jclJvdW5kVXAobnVtLCBpbmNyKSB7XHJcblx0cmV0dXJuIGZpeEZsb2F0KGNlaWwoZml4RmxvYXQobnVtL2luY3IpKSppbmNyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaW5jclJvdW5kRG4obnVtLCBpbmNyKSB7XHJcblx0cmV0dXJuIGZpeEZsb2F0KGZsb29yKGZpeEZsb2F0KG51bS9pbmNyKSkqaW5jcik7XHJcbn1cclxuXHJcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80ODc2NDQzNlxyXG4vLyByb3VuZHMgaGFsZiBhd2F5IGZyb20gemVyb1xyXG5mdW5jdGlvbiByb3VuZERlYyh2YWwsIGRlYyA9IDApIHtcclxuXHRpZiAoaXNJbnQodmFsKSlcclxuXHRcdHJldHVybiB2YWw7XHJcbi8vXHRlbHNlIGlmIChkZWMgPT0gMClcclxuLy9cdFx0cmV0dXJuIHJvdW5kKHZhbCk7XHJcblxyXG5cdGxldCBwID0gMTAgKiogZGVjO1xyXG5cdGxldCBuID0gKHZhbCAqIHApICogKDEgKyBOdW1iZXIuRVBTSUxPTik7XHJcblx0cmV0dXJuIHJvdW5kKG4pIC8gcDtcclxufVxyXG5cclxuY29uc3QgZml4ZWREZWMgPSBuZXcgTWFwKCk7XHJcblxyXG5mdW5jdGlvbiBndWVzc0RlYyhudW0pIHtcclxuXHRyZXR1cm4gKChcIlwiK251bSkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuSW5jcnMoYmFzZSwgbWluRXhwLCBtYXhFeHAsIG11bHRzKSB7XHJcblx0bGV0IGluY3JzID0gW107XHJcblxyXG5cdGxldCBtdWx0RGVjID0gbXVsdHMubWFwKGd1ZXNzRGVjKTtcclxuXHJcblx0Zm9yIChsZXQgZXhwID0gbWluRXhwOyBleHAgPCBtYXhFeHA7IGV4cCsrKSB7XHJcblx0XHRsZXQgZXhwYSA9IGFicyhleHApO1xyXG5cdFx0bGV0IG1hZyA9IHJvdW5kRGVjKHBvdyhiYXNlLCBleHApLCBleHBhKTtcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG11bHRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBfaW5jciA9IG11bHRzW2ldICogbWFnO1xyXG5cdFx0XHRsZXQgZGVjID0gKF9pbmNyID49IDAgJiYgZXhwID49IDAgPyAwIDogZXhwYSkgKyAoZXhwID49IG11bHREZWNbaV0gPyAwIDogbXVsdERlY1tpXSk7XHJcblx0XHRcdGxldCBpbmNyID0gcm91bmREZWMoX2luY3IsIGRlYyk7XHJcblx0XHRcdGluY3JzLnB1c2goaW5jcik7XHJcblx0XHRcdGZpeGVkRGVjLnNldChpbmNyLCBkZWMpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGluY3JzO1xyXG59XHJcblxyXG4vL2V4cG9ydCBjb25zdCBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xyXG5cclxuY29uc3QgRU1QVFlfT0JKID0ge307XHJcbmNvbnN0IEVNUFRZX0FSUiA9IFtdO1xyXG5cclxuY29uc3QgbnVsbE51bGxUdXBsZSA9IFtudWxsLCBudWxsXTtcclxuXHJcbmNvbnN0IGlzQXJyID0gQXJyYXkuaXNBcnJheTtcclxuY29uc3QgaXNJbnQgPSBOdW1iZXIuaXNJbnRlZ2VyO1xyXG5jb25zdCBpc1VuZGVmID0gdiA9PiB2ID09PSB2b2lkIDA7XHJcblxyXG5mdW5jdGlvbiBpc1N0cih2KSB7XHJcblx0cmV0dXJuIHR5cGVvZiB2ID09ICdzdHJpbmcnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc09iaih2KSB7XHJcblx0bGV0IGlzID0gZmFsc2U7XHJcblxyXG5cdGlmICh2ICE9IG51bGwpIHtcclxuXHRcdGxldCBjID0gdi5jb25zdHJ1Y3RvcjtcclxuXHRcdGlzID0gYyA9PSBudWxsIHx8IGMgPT0gT2JqZWN0O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmYXN0SXNPYmoodikge1xyXG5cdHJldHVybiB2ICE9IG51bGwgJiYgdHlwZW9mIHYgPT0gJ29iamVjdCc7XHJcbn1cclxuXHJcbmNvbnN0IFR5cGVkQXJyYXkgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSk7XHJcblxyXG5mdW5jdGlvbiBjb3B5KG8sIF9pc09iaiA9IGlzT2JqKSB7XHJcblx0bGV0IG91dDtcclxuXHJcblx0aWYgKGlzQXJyKG8pKSB7XHJcblx0XHRsZXQgdmFsID0gby5maW5kKHYgPT4gdiAhPSBudWxsKTtcclxuXHJcblx0XHRpZiAoaXNBcnIodmFsKSB8fCBfaXNPYmoodmFsKSkge1xyXG5cdFx0XHRvdXQgPSBBcnJheShvLmxlbmd0aCk7XHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgby5sZW5ndGg7IGkrKylcclxuXHRcdFx0XHRvdXRbaV0gPSBjb3B5KG9baV0sIF9pc09iaik7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHRcdG91dCA9IG8uc2xpY2UoKTtcclxuXHR9XHJcblx0ZWxzZSBpZiAobyBpbnN0YW5jZW9mIFR5cGVkQXJyYXkpIC8vIGFsc28gKEFycmF5QnVmZmVyLmlzVmlldyhvKSAmJiAhKG8gaW5zdGFuY2VvZiBEYXRhVmlldykpXHJcblx0XHRvdXQgPSBvLnNsaWNlKCk7XHJcblx0ZWxzZSBpZiAoX2lzT2JqKG8pKSB7XHJcblx0XHRvdXQgPSB7fTtcclxuXHRcdGZvciAobGV0IGsgaW4gbylcclxuXHRcdFx0b3V0W2tdID0gY29weShvW2tdLCBfaXNPYmopO1xyXG5cdH1cclxuXHRlbHNlXHJcblx0XHRvdXQgPSBvO1xyXG5cclxuXHRyZXR1cm4gb3V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhc3NpZ24odGFyZykge1xyXG5cdGxldCBhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuXHRmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdGxldCBzcmMgPSBhcmdzW2ldO1xyXG5cclxuXHRcdGZvciAobGV0IGtleSBpbiBzcmMpIHtcclxuXHRcdFx0aWYgKGlzT2JqKHRhcmdba2V5XSkpXHJcblx0XHRcdFx0YXNzaWduKHRhcmdba2V5XSwgY29weShzcmNba2V5XSkpO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0dGFyZ1trZXldID0gY29weShzcmNba2V5XSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGFyZztcclxufVxyXG5cclxuLy8gbnVsbE1vZGVzXHJcbmNvbnN0IE5VTExfUkVNT1ZFID0gMDsgIC8vIG51bGxzIGFyZSBjb252ZXJ0ZWQgdG8gdW5kZWZpbmVkIChlLmcuIGZvciBzcGFuR2FwczogdHJ1ZSlcclxuY29uc3QgTlVMTF9SRVRBSU4gPSAxOyAgLy8gbnVsbHMgYXJlIHJldGFpbmVkLCB3aXRoIGFsaWdubWVudCBhcnRpZmFjdHMgc2V0IHRvIHVuZGVmaW5lZCAoZGVmYXVsdClcclxuY29uc3QgTlVMTF9FWFBBTkQgPSAyOyAgLy8gbnVsbHMgYXJlIGV4cGFuZGVkIHRvIGluY2x1ZGUgYW55IGFkamFjZW50IGFsaWdubWVudCBhcnRpZmFjdHNcclxuXHJcbi8vIHNldHMgdW5kZWZpbmVkIHZhbHVlcyB0byBudWxscyB3aGVuIGFkamFjZW50IHRvIGV4aXN0aW5nIG51bGxzIChtaW5lc3dlZXBlcilcclxuZnVuY3Rpb24gbnVsbEV4cGFuZCh5VmFscywgbnVsbElkeHMsIGFsaWduZWRMZW4pIHtcclxuXHRmb3IgKGxldCBpID0gMCwgeGksIGxhc3ROdWxsSWR4ID0gLTE7IGkgPCBudWxsSWR4cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0bGV0IG51bGxJZHggPSBudWxsSWR4c1tpXTtcclxuXHJcblx0XHRpZiAobnVsbElkeCA+IGxhc3ROdWxsSWR4KSB7XHJcblx0XHRcdHhpID0gbnVsbElkeCAtIDE7XHJcblx0XHRcdHdoaWxlICh4aSA+PSAwICYmIHlWYWxzW3hpXSA9PSBudWxsKVxyXG5cdFx0XHRcdHlWYWxzW3hpLS1dID0gbnVsbDtcclxuXHJcblx0XHRcdHhpID0gbnVsbElkeCArIDE7XHJcblx0XHRcdHdoaWxlICh4aSA8IGFsaWduZWRMZW4gJiYgeVZhbHNbeGldID09IG51bGwpXHJcblx0XHRcdFx0eVZhbHNbbGFzdE51bGxJZHggPSB4aSsrXSA9IG51bGw7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBudWxsTW9kZXMgaXMgYSB0YWJsZXMtbWF0Y2hlZCBhcnJheSBpbmRpY2F0aW5nIGhvdyB0byB0cmVhdCBudWxscyBpbiBlYWNoIHNlcmllc1xyXG4vLyBvdXRwdXQgaXMgc29ydGVkIEFTQyBvbiB0aGUgam9pbmVkIGZpZWxkICh0YWJsZVswXSkgYW5kIGR1cGxpY2F0ZSBqb2luIHZhbHVlcyBhcmUgY29sbGFwc2VkXHJcbmZ1bmN0aW9uIGpvaW4odGFibGVzLCBudWxsTW9kZXMpIHtcclxuXHRpZiAoYWxsSGVhZGVyc1NhbWUodGFibGVzKSkge1xyXG5cdC8vXHRjb25zb2xlLmxvZygnY2hlYXAgam9pbiEnKTtcclxuXHJcblx0XHRsZXQgdGFibGUgPSB0YWJsZXNbMF0uc2xpY2UoKTtcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHRhYmxlcy5sZW5ndGg7IGkrKylcclxuXHRcdFx0dGFibGUucHVzaCguLi50YWJsZXNbaV0uc2xpY2UoMSkpO1xyXG5cclxuXHRcdGlmICghaXNBc2ModGFibGVbMF0pKVxyXG5cdFx0XHR0YWJsZSA9IHNvcnRDb2xzKHRhYmxlKTtcclxuXHJcblx0XHRyZXR1cm4gdGFibGU7XHJcblx0fVxyXG5cclxuXHRsZXQgeFZhbHMgPSBuZXcgU2V0KCk7XHJcblxyXG5cdGZvciAobGV0IHRpID0gMDsgdGkgPCB0YWJsZXMubGVuZ3RoOyB0aSsrKSB7XHJcblx0XHRsZXQgdCA9IHRhYmxlc1t0aV07XHJcblx0XHRsZXQgeHMgPSB0WzBdO1xyXG5cdFx0bGV0IGxlbiA9IHhzLmxlbmd0aDtcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG5cdFx0XHR4VmFscy5hZGQoeHNbaV0pO1xyXG5cdH1cclxuXHJcblx0bGV0IGRhdGEgPSBbQXJyYXkuZnJvbSh4VmFscykuc29ydCgoYSwgYikgPT4gYSAtIGIpXTtcclxuXHJcblx0bGV0IGFsaWduZWRMZW4gPSBkYXRhWzBdLmxlbmd0aDtcclxuXHJcblx0bGV0IHhJZHhzID0gbmV3IE1hcCgpO1xyXG5cclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGFsaWduZWRMZW47IGkrKylcclxuXHRcdHhJZHhzLnNldChkYXRhWzBdW2ldLCBpKTtcclxuXHJcblx0Zm9yIChsZXQgdGkgPSAwOyB0aSA8IHRhYmxlcy5sZW5ndGg7IHRpKyspIHtcclxuXHRcdGxldCB0ID0gdGFibGVzW3RpXTtcclxuXHRcdGxldCB4cyA9IHRbMF07XHJcblxyXG5cdFx0Zm9yIChsZXQgc2kgPSAxOyBzaSA8IHQubGVuZ3RoOyBzaSsrKSB7XHJcblx0XHRcdGxldCB5cyA9IHRbc2ldO1xyXG5cclxuXHRcdFx0bGV0IHlWYWxzID0gQXJyYXkoYWxpZ25lZExlbikuZmlsbCh1bmRlZmluZWQpO1xyXG5cclxuXHRcdFx0bGV0IG51bGxNb2RlID0gbnVsbE1vZGVzID8gbnVsbE1vZGVzW3RpXVtzaV0gOiBOVUxMX1JFVEFJTjtcclxuXHJcblx0XHRcdGxldCBudWxsSWR4cyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB5cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGxldCB5VmFsID0geXNbaV07XHJcblx0XHRcdFx0bGV0IGFsaWduZWRJZHggPSB4SWR4cy5nZXQoeHNbaV0pO1xyXG5cclxuXHRcdFx0XHRpZiAoeVZhbCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0aWYgKG51bGxNb2RlICE9IE5VTExfUkVNT1ZFKSB7XHJcblx0XHRcdFx0XHRcdHlWYWxzW2FsaWduZWRJZHhdID0geVZhbDtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChudWxsTW9kZSA9PSBOVUxMX0VYUEFORClcclxuXHRcdFx0XHRcdFx0XHRudWxsSWR4cy5wdXNoKGFsaWduZWRJZHgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHR5VmFsc1thbGlnbmVkSWR4XSA9IHlWYWw7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG51bGxFeHBhbmQoeVZhbHMsIG51bGxJZHhzLCBhbGlnbmVkTGVuKTtcclxuXHJcblx0XHRcdGRhdGEucHVzaCh5VmFscyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxufVxyXG5cclxuY29uc3QgbWljcm9UYXNrID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09IFwidW5kZWZpbmVkXCIgPyBmbiA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZuKSA6IHF1ZXVlTWljcm90YXNrO1xyXG5cclxuLy8gVE9ETzogaHR0cHM6Ly9naXRodWIuY29tL2R5L3NvcnQtaWRzICh+MnggZmFzdGVyIGZvciAxZTUrIGFycmF5cylcclxuZnVuY3Rpb24gc29ydENvbHModGFibGUpIHtcclxuXHRsZXQgaGVhZCA9IHRhYmxlWzBdO1xyXG5cdGxldCBybGVuID0gaGVhZC5sZW5ndGg7XHJcblxyXG5cdGxldCBpZHhzID0gQXJyYXkocmxlbik7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpZHhzLmxlbmd0aDsgaSsrKVxyXG5cdFx0aWR4c1tpXSA9IGk7XHJcblxyXG5cdGlkeHMuc29ydCgoaTAsIGkxKSA9PiBoZWFkW2kwXSAtIGhlYWRbaTFdKTtcclxuXHJcblx0bGV0IHRhYmxlMiA9IFtdO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdGFibGUubGVuZ3RoOyBpKyspIHtcclxuXHRcdGxldCByb3cgPSB0YWJsZVtpXTtcclxuXHRcdGxldCByb3cyID0gQXJyYXkocmxlbik7XHJcblxyXG5cdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBybGVuOyBqKyspXHJcblx0XHRcdHJvdzJbal0gPSByb3dbaWR4c1tqXV07XHJcblxyXG5cdFx0dGFibGUyLnB1c2gocm93Mik7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGFibGUyO1xyXG59XHJcblxyXG4vLyB0ZXN0IGlmIHdlIGNhbiBkbyBjaGVhcCBqb2luIChhbGwgam9pbiBmaWVsZHMgc2FtZSlcclxuZnVuY3Rpb24gYWxsSGVhZGVyc1NhbWUodGFibGVzKSB7XHJcblx0bGV0IHZhbHMwID0gdGFibGVzWzBdWzBdO1xyXG5cdGxldCBsZW4wID0gdmFsczAubGVuZ3RoO1xyXG5cclxuXHRmb3IgKGxldCBpID0gMTsgaSA8IHRhYmxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0bGV0IHZhbHMxID0gdGFibGVzW2ldWzBdO1xyXG5cclxuXHRcdGlmICh2YWxzMS5sZW5ndGggIT0gbGVuMClcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdGlmICh2YWxzMSAhPSB2YWxzMCkge1xyXG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGxlbjA7IGorKykge1xyXG5cdFx0XHRcdGlmICh2YWxzMVtqXSAhPSB2YWxzMFtqXSlcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQXNjKHZhbHMsIHNhbXBsZXMgPSAxMDApIHtcclxuXHRjb25zdCBsZW4gPSB2YWxzLmxlbmd0aDtcclxuXHJcblx0Ly8gZW1wdHkgb3Igc2luZ2xlIHZhbHVlXHJcblx0aWYgKGxlbiA8PSAxKVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdC8vIHNraXAgbGVhZGluZyAmIHRyYWlsaW5nIG51bGxpc2hcclxuXHRsZXQgZmlyc3RJZHggPSAwO1xyXG5cdGxldCBsYXN0SWR4ID0gbGVuIC0gMTtcclxuXHJcblx0d2hpbGUgKGZpcnN0SWR4IDw9IGxhc3RJZHggJiYgdmFsc1tmaXJzdElkeF0gPT0gbnVsbClcclxuXHRcdGZpcnN0SWR4Kys7XHJcblxyXG5cdHdoaWxlIChsYXN0SWR4ID49IGZpcnN0SWR4ICYmIHZhbHNbbGFzdElkeF0gPT0gbnVsbClcclxuXHRcdGxhc3RJZHgtLTtcclxuXHJcblx0Ly8gYWxsIG51bGxpc2ggb3Igb25lIHZhbHVlIHN1cnJvdW5kZWQgYnkgbnVsbGlzaFxyXG5cdGlmIChsYXN0SWR4IDw9IGZpcnN0SWR4KVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdGNvbnN0IHN0cmlkZSA9IG1heCgxLCBmbG9vcigobGFzdElkeCAtIGZpcnN0SWR4ICsgMSkgLyBzYW1wbGVzKSk7XHJcblxyXG5cdGZvciAobGV0IHByZXZWYWwgPSB2YWxzW2ZpcnN0SWR4XSwgaSA9IGZpcnN0SWR4ICsgc3RyaWRlOyBpIDw9IGxhc3RJZHg7IGkgKz0gc3RyaWRlKSB7XHJcblx0XHRjb25zdCB2ID0gdmFsc1tpXTtcclxuXHJcblx0XHRpZiAodiAhPSBudWxsKSB7XHJcblx0XHRcdGlmICh2IDw9IHByZXZWYWwpXHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0cHJldlZhbCA9IHY7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuY29uc3QgbW9udGhzID0gW1xyXG5cdFwiSmFudWFyeVwiLFxyXG5cdFwiRmVicnVhcnlcIixcclxuXHRcIk1hcmNoXCIsXHJcblx0XCJBcHJpbFwiLFxyXG5cdFwiTWF5XCIsXHJcblx0XCJKdW5lXCIsXHJcblx0XCJKdWx5XCIsXHJcblx0XCJBdWd1c3RcIixcclxuXHRcIlNlcHRlbWJlclwiLFxyXG5cdFwiT2N0b2JlclwiLFxyXG5cdFwiTm92ZW1iZXJcIixcclxuXHRcIkRlY2VtYmVyXCIsXHJcbl07XHJcblxyXG5jb25zdCBkYXlzID0gW1xyXG5cdFwiU3VuZGF5XCIsXHJcblx0XCJNb25kYXlcIixcclxuXHRcIlR1ZXNkYXlcIixcclxuXHRcIldlZG5lc2RheVwiLFxyXG5cdFwiVGh1cnNkYXlcIixcclxuXHRcIkZyaWRheVwiLFxyXG5cdFwiU2F0dXJkYXlcIixcclxuXTtcclxuXHJcbmZ1bmN0aW9uIHNsaWNlMyhzdHIpIHtcclxuXHRyZXR1cm4gc3RyLnNsaWNlKDAsIDMpO1xyXG59XHJcblxyXG5jb25zdCBkYXlzMyA9IGRheXMubWFwKHNsaWNlMyk7XHJcblxyXG5jb25zdCBtb250aHMzID0gbW9udGhzLm1hcChzbGljZTMpO1xyXG5cclxuY29uc3QgZW5nTmFtZXMgPSB7XHJcblx0TU1NTTogbW9udGhzLFxyXG5cdE1NTTogIG1vbnRoczMsXHJcblx0V1dXVzogZGF5cyxcclxuXHRXV1c6ICBkYXlzMyxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHplcm9QYWQyKGludCkge1xyXG5cdHJldHVybiAoaW50IDwgMTAgPyAnMCcgOiAnJykgKyBpbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHplcm9QYWQzKGludCkge1xyXG5cdHJldHVybiAoaW50IDwgMTAgPyAnMDAnIDogaW50IDwgMTAwID8gJzAnIDogJycpICsgaW50O1xyXG59XHJcblxyXG4vKlxyXG5mdW5jdGlvbiBzdWZmaXgoaW50KSB7XHJcblx0bGV0IG1vZDEwID0gaW50ICUgMTA7XHJcblxyXG5cdHJldHVybiBpbnQgKyAoXHJcblx0XHRtb2QxMCA9PSAxICYmIGludCAhPSAxMSA/IFwic3RcIiA6XHJcblx0XHRtb2QxMCA9PSAyICYmIGludCAhPSAxMiA/IFwibmRcIiA6XHJcblx0XHRtb2QxMCA9PSAzICYmIGludCAhPSAxMyA/IFwicmRcIiA6IFwidGhcIlxyXG5cdCk7XHJcbn1cclxuKi9cclxuXHJcbmNvbnN0IHN1YnMgPSB7XHJcblx0Ly8gMjAxOVxyXG5cdFlZWVk6XHRkID0+IGQuZ2V0RnVsbFllYXIoKSxcclxuXHQvLyAxOVxyXG5cdFlZOlx0XHRkID0+IChkLmdldEZ1bGxZZWFyKCkrJycpLnNsaWNlKDIpLFxyXG5cdC8vIEp1bHlcclxuXHRNTU1NOlx0KGQsIG5hbWVzKSA9PiBuYW1lcy5NTU1NW2QuZ2V0TW9udGgoKV0sXHJcblx0Ly8gSnVsXHJcblx0TU1NOlx0KGQsIG5hbWVzKSA9PiBuYW1lcy5NTU1bZC5nZXRNb250aCgpXSxcclxuXHQvLyAwN1xyXG5cdE1NOlx0XHRkID0+IHplcm9QYWQyKGQuZ2V0TW9udGgoKSsxKSxcclxuXHQvLyA3XHJcblx0TTpcdFx0ZCA9PiBkLmdldE1vbnRoKCkrMSxcclxuXHQvLyAwOVxyXG5cdEREOlx0XHRkID0+IHplcm9QYWQyKGQuZ2V0RGF0ZSgpKSxcclxuXHQvLyA5XHJcblx0RDpcdFx0ZCA9PiBkLmdldERhdGUoKSxcclxuXHQvLyBNb25kYXlcclxuXHRXV1dXOlx0KGQsIG5hbWVzKSA9PiBuYW1lcy5XV1dXW2QuZ2V0RGF5KCldLFxyXG5cdC8vIE1vblxyXG5cdFdXVzpcdChkLCBuYW1lcykgPT4gbmFtZXMuV1dXW2QuZ2V0RGF5KCldLFxyXG5cdC8vIDAzXHJcblx0SEg6XHRcdGQgPT4gemVyb1BhZDIoZC5nZXRIb3VycygpKSxcclxuXHQvLyAzXHJcblx0SDpcdFx0ZCA9PiBkLmdldEhvdXJzKCksXHJcblx0Ly8gOSAoMTJociwgdW5wYWRkZWQpXHJcblx0aDpcdFx0ZCA9PiB7bGV0IGggPSBkLmdldEhvdXJzKCk7IHJldHVybiBoID09IDAgPyAxMiA6IGggPiAxMiA/IGggLSAxMiA6IGg7fSxcclxuXHQvLyBBTVxyXG5cdEFBOlx0XHRkID0+IGQuZ2V0SG91cnMoKSA+PSAxMiA/ICdQTScgOiAnQU0nLFxyXG5cdC8vIGFtXHJcblx0YWE6XHRcdGQgPT4gZC5nZXRIb3VycygpID49IDEyID8gJ3BtJyA6ICdhbScsXHJcblx0Ly8gYVxyXG5cdGE6XHRcdGQgPT4gZC5nZXRIb3VycygpID49IDEyID8gJ3AnIDogJ2EnLFxyXG5cdC8vIDA5XHJcblx0bW06XHRcdGQgPT4gemVyb1BhZDIoZC5nZXRNaW51dGVzKCkpLFxyXG5cdC8vIDlcclxuXHRtOlx0XHRkID0+IGQuZ2V0TWludXRlcygpLFxyXG5cdC8vIDA5XHJcblx0c3M6XHRcdGQgPT4gemVyb1BhZDIoZC5nZXRTZWNvbmRzKCkpLFxyXG5cdC8vIDlcclxuXHRzOlx0XHRkID0+IGQuZ2V0U2Vjb25kcygpLFxyXG5cdC8vIDM3NFxyXG5cdGZmZjpcdGQgPT4gemVyb1BhZDMoZC5nZXRNaWxsaXNlY29uZHMoKSksXHJcbn07XHJcblxyXG5mdW5jdGlvbiBmbXREYXRlKHRwbCwgbmFtZXMpIHtcclxuXHRuYW1lcyA9IG5hbWVzIHx8IGVuZ05hbWVzO1xyXG5cdGxldCBwYXJ0cyA9IFtdO1xyXG5cclxuXHRsZXQgUiA9IC9cXHsoW2Etel0rKVxcfXxbXntdKy9naSwgbTtcclxuXHJcblx0d2hpbGUgKG0gPSBSLmV4ZWModHBsKSlcclxuXHRcdHBhcnRzLnB1c2gobVswXVswXSA9PSAneycgPyBzdWJzW21bMV1dIDogbVswXSk7XHJcblxyXG5cdHJldHVybiBkID0+IHtcclxuXHRcdGxldCBvdXQgPSAnJztcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRvdXQgKz0gdHlwZW9mIHBhcnRzW2ldID09IFwic3RyaW5nXCIgPyBwYXJ0c1tpXSA6IHBhcnRzW2ldKGQsIG5hbWVzKTtcclxuXHJcblx0XHRyZXR1cm4gb3V0O1xyXG5cdH1cclxufVxyXG5cclxuY29uc3QgbG9jYWxUeiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmU7XHJcblxyXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTE0MTc2Mi9ob3ctdG8taW5pdGlhbGl6ZS1hLWphdmFzY3JpcHQtZGF0ZS10by1hLXBhcnRpY3VsYXItdGltZS16b25lLzUzNjUyMTMxIzUzNjUyMTMxXHJcbmZ1bmN0aW9uIHR6RGF0ZShkYXRlLCB0eikge1xyXG5cdGxldCBkYXRlMjtcclxuXHJcblx0Ly8gcGVyZiBvcHRpbWl6YXRpb25cclxuXHRpZiAodHogPT0gJ1VUQycgfHwgdHogPT0gJ0V0Yy9VVEMnKVxyXG5cdFx0ZGF0ZTIgPSBuZXcgRGF0ZSgrZGF0ZSArIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDZlNCk7XHJcblx0ZWxzZSBpZiAodHogPT0gbG9jYWxUeilcclxuXHRcdGRhdGUyID0gZGF0ZTtcclxuXHRlbHNlIHtcclxuXHRcdGRhdGUyID0gbmV3IERhdGUoZGF0ZS50b0xvY2FsZVN0cmluZygnZW4tVVMnLCB7dGltZVpvbmU6IHR6fSkpO1xyXG5cdFx0ZGF0ZTIuc2V0TWlsbGlzZWNvbmRzKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGRhdGUyO1xyXG59XHJcblxyXG4vL2V4cG9ydCBjb25zdCBzZXJpZXMgPSBbXTtcclxuXHJcbi8vIGRlZmF1bHQgZm9ybWF0dGVyczpcclxuXHJcbmNvbnN0IG9ubHlXaG9sZSA9IHYgPT4gdiAlIDEgPT0gMDtcclxuXHJcbmNvbnN0IGFsbE11bHRzID0gWzEsMiwyLjUsNV07XHJcblxyXG4vLyAuLi4wLjAxLCAwLjAyLCAwLjAyNSwgMC4wNSwgMC4xLCAwLjIsIDAuMjUsIDAuNVxyXG5jb25zdCBkZWNJbmNycyA9IGdlbkluY3JzKDEwLCAtMTYsIDAsIGFsbE11bHRzKTtcclxuXHJcbi8vIDEsIDIsIDIuNSwgNSwgMTAsIDIwLCAyNSwgNTAuLi5cclxuY29uc3Qgb25lSW5jcnMgPSBnZW5JbmNycygxMCwgMCwgMTYsIGFsbE11bHRzKTtcclxuXHJcbi8vIDEsIDIsICAgICAgNSwgMTAsIDIwLCAyNSwgNTAuLi5cclxuY29uc3Qgd2hvbGVJbmNycyA9IG9uZUluY3JzLmZpbHRlcihvbmx5V2hvbGUpO1xyXG5cclxuY29uc3QgbnVtSW5jcnMgPSBkZWNJbmNycy5jb25jYXQob25lSW5jcnMpO1xyXG5cclxuY29uc3QgTkwgPSBcIlxcblwiO1xyXG5cclxuY29uc3QgeXl5eSAgICA9IFwie1lZWVl9XCI7XHJcbmNvbnN0IE5MeXl5eSAgPSBOTCArIHl5eXk7XHJcbmNvbnN0IG1kICAgICAgPSBcIntNfS97RH1cIjtcclxuY29uc3QgTkxtZCAgICA9IE5MICsgbWQ7XHJcbmNvbnN0IE5MbWR5eSAgPSBOTG1kICsgXCIve1lZfVwiO1xyXG5cclxuY29uc3QgYWEgICAgICA9IFwie2FhfVwiO1xyXG5jb25zdCBobW0gICAgID0gXCJ7aH06e21tfVwiO1xyXG5jb25zdCBobW1hYSAgID0gaG1tICsgYWE7XHJcbmNvbnN0IE5MaG1tYWEgPSBOTCArIGhtbWFhO1xyXG5jb25zdCBzcyAgICAgID0gXCI6e3NzfVwiO1xyXG5cclxuY29uc3QgXyA9IG51bGw7XHJcblxyXG5mdW5jdGlvbiBnZW5UaW1lU3R1ZmZzKG1zKSB7XHJcblx0bGV0XHRzICA9IG1zICogMWUzLFxyXG5cdFx0bSAgPSBzICAqIDYwLFxyXG5cdFx0aCAgPSBtICAqIDYwLFxyXG5cdFx0ZCAgPSBoICAqIDI0LFxyXG5cdFx0bW8gPSBkICAqIDMwLFxyXG5cdFx0eSAgPSBkICAqIDM2NTtcclxuXHJcblx0Ly8gbWluIG9mIDFlLTMgcHJldmVudHMgc2V0dGluZyBhIHRlbXBvcmFsIHggdGlja3MgdG9vIHNtYWxsIHNpbmNlIERhdGUgb2JqZWN0cyBjYW5ub3QgYWR2YW5jZSB0aWNrcyBzbWFsbGVyIHRoYW4gMW1zXHJcblx0bGV0IHN1YlNlY0luY3JzID0gbXMgPT0gMSA/IGdlbkluY3JzKDEwLCAwLCAzLCBhbGxNdWx0cykuZmlsdGVyKG9ubHlXaG9sZSkgOiBnZW5JbmNycygxMCwgLTMsIDAsIGFsbE11bHRzKTtcclxuXHJcblx0bGV0IHRpbWVJbmNycyA9IHN1YlNlY0luY3JzLmNvbmNhdChbXHJcblx0XHQvLyBtaW51dGUgZGl2aXNvcnMgKCMgb2Ygc2VjcylcclxuXHRcdHMsXHJcblx0XHRzICogNSxcclxuXHRcdHMgKiAxMCxcclxuXHRcdHMgKiAxNSxcclxuXHRcdHMgKiAzMCxcclxuXHRcdC8vIGhvdXIgZGl2aXNvcnMgKCMgb2YgbWlucylcclxuXHRcdG0sXHJcblx0XHRtICogNSxcclxuXHRcdG0gKiAxMCxcclxuXHRcdG0gKiAxNSxcclxuXHRcdG0gKiAzMCxcclxuXHRcdC8vIGRheSBkaXZpc29ycyAoIyBvZiBocnMpXHJcblx0XHRoLFxyXG5cdFx0aCAqIDIsXHJcblx0XHRoICogMyxcclxuXHRcdGggKiA0LFxyXG5cdFx0aCAqIDYsXHJcblx0XHRoICogOCxcclxuXHRcdGggKiAxMixcclxuXHRcdC8vIG1vbnRoIGRpdmlzb3JzIFRPRE86IG5lZWQgbW9yZT9cclxuXHRcdGQsXHJcblx0XHRkICogMixcclxuXHRcdGQgKiAzLFxyXG5cdFx0ZCAqIDQsXHJcblx0XHRkICogNSxcclxuXHRcdGQgKiA2LFxyXG5cdFx0ZCAqIDcsXHJcblx0XHRkICogOCxcclxuXHRcdGQgKiA5LFxyXG5cdFx0ZCAqIDEwLFxyXG5cdFx0ZCAqIDE1LFxyXG5cdFx0Ly8geWVhciBkaXZpc29ycyAoIyBtb250aHMsIGFwcHJveClcclxuXHRcdG1vLFxyXG5cdFx0bW8gKiAyLFxyXG5cdFx0bW8gKiAzLFxyXG5cdFx0bW8gKiA0LFxyXG5cdFx0bW8gKiA2LFxyXG5cdFx0Ly8gY2VudHVyeSBkaXZpc29yc1xyXG5cdFx0eSxcclxuXHRcdHkgKiAyLFxyXG5cdFx0eSAqIDUsXHJcblx0XHR5ICogMTAsXHJcblx0XHR5ICogMjUsXHJcblx0XHR5ICogNTAsXHJcblx0XHR5ICogMTAwLFxyXG5cdF0pO1xyXG5cclxuXHQvLyBbMF06ICAgbWluaW11bSBudW0gc2VjcyBpbiB0aGUgdGljayBpbmNyXHJcblx0Ly8gWzFdOiAgIGRlZmF1bHQgdGljayBmb3JtYXRcclxuXHQvLyBbMi03XTogcm9sbG92ZXIgdGljayBmb3JtYXRzXHJcblx0Ly8gWzhdOiAgIG1vZGU6IDA6IHJlcGxhY2UgWzFdIC0+IFsyLTddLCAxOiBjb25jYXQgWzFdICsgWzItN11cclxuXHRjb25zdCBfdGltZUF4aXNTdGFtcHMgPSBbXHJcblx0Ly8gICB0aWNrIGluY3IgICAgZGVmYXVsdCAgICAgICAgICB5ZWFyICAgICAgICAgICAgICAgICAgICBtb250aCAgIGRheSAgICAgICAgICAgICAgICAgICBob3VyICAgIG1pbiAgICAgICBzZWMgICBtb2RlXHJcblx0XHRbeSwgICAgICAgICAgIHl5eXksICAgICAgICAgICAgXywgICAgICAgICAgICAgICAgICAgICAgXywgICAgICBfLCAgICAgICAgICAgICAgICAgICAgXywgICAgICBfLCAgICAgICAgXywgICAgICAgMV0sXHJcblx0XHRbZCAqIDI4LCAgICAgIFwie01NTX1cIiwgICAgICAgICBOTHl5eXksICAgICAgICAgICAgICAgICBfLCAgICAgIF8sICAgICAgICAgICAgICAgICAgICBfLCAgICAgIF8sICAgICAgICBfLCAgICAgICAxXSxcclxuXHRcdFtkLCAgICAgICAgICAgbWQsICAgICAgICAgICAgICBOTHl5eXksICAgICAgICAgICAgICAgICBfLCAgICAgIF8sICAgICAgICAgICAgICAgICAgICBfLCAgICAgIF8sICAgICAgICBfLCAgICAgICAxXSxcclxuXHRcdFtoLCAgICAgICAgICAgXCJ7aH1cIiArIGFhLCAgICAgIE5MbWR5eSwgICAgICAgICAgICAgICAgIF8sICAgICAgTkxtZCwgICAgICAgICAgICAgICAgIF8sICAgICAgXywgICAgICAgIF8sICAgICAgIDFdLFxyXG5cdFx0W20sICAgICAgICAgICBobW1hYSwgICAgICAgICAgIE5MbWR5eSwgICAgICAgICAgICAgICAgIF8sICAgICAgTkxtZCwgICAgICAgICAgICAgICAgIF8sICAgICAgXywgICAgICAgIF8sICAgICAgIDFdLFxyXG5cdFx0W3MsICAgICAgICAgICBzcywgICAgICAgICAgICAgIE5MbWR5eSArIFwiIFwiICsgaG1tYWEsICAgXywgICAgICBOTG1kICsgXCIgXCIgKyBobW1hYSwgICBfLCAgICAgIE5MaG1tYWEsICBfLCAgICAgICAxXSxcclxuXHRcdFttcywgICAgICAgICAgc3MgKyBcIi57ZmZmfVwiLCAgIE5MbWR5eSArIFwiIFwiICsgaG1tYWEsICAgXywgICAgICBOTG1kICsgXCIgXCIgKyBobW1hYSwgICBfLCAgICAgIE5MaG1tYWEsICBfLCAgICAgICAxXSxcclxuXHRdO1xyXG5cclxuXHQvLyB0aGUgZW5zdXJlcyB0aGF0IGF4aXMgdGlja3MsIHZhbHVlcyAmIGdyaWQgYXJlIGFsaWduZWQgdG8gbG9naWNhbCB0ZW1wb3JhbCBicmVha3BvaW50cyBhbmQgbm90IGFuIGFyYml0cmFyeSB0aW1lc3RhbXBcclxuXHQvLyBodHRwczovL3d3dy50aW1lYW5kZGF0ZS5jb20vdGltZS9kc3QvXHJcblx0Ly8gaHR0cHM6Ly93d3cudGltZWFuZGRhdGUuY29tL3RpbWUvZHN0LzIwMTkuaHRtbFxyXG5cdC8vIGh0dHBzOi8vd3d3LmVwb2NoY29udmVydGVyLmNvbS90aW1lem9uZXNcclxuXHRmdW5jdGlvbiB0aW1lQXhpc1NwbGl0cyh0ekRhdGUpIHtcclxuXHRcdHJldHVybiAoc2VsZiwgYXhpc0lkeCwgc2NhbGVNaW4sIHNjYWxlTWF4LCBmb3VuZEluY3IsIGZvdW5kU3BhY2UpID0+IHtcclxuXHRcdFx0bGV0IHNwbGl0cyA9IFtdO1xyXG5cdFx0XHRsZXQgaXNZciA9IGZvdW5kSW5jciA+PSB5O1xyXG5cdFx0XHRsZXQgaXNNbyA9IGZvdW5kSW5jciA+PSBtbyAmJiBmb3VuZEluY3IgPCB5O1xyXG5cclxuXHRcdFx0Ly8gZ2V0IHRoZSB0aW1lem9uZS1hZGp1c3RlZCBkYXRlXHJcblx0XHRcdGxldCBtaW5EYXRlID0gdHpEYXRlKHNjYWxlTWluKTtcclxuXHRcdFx0bGV0IG1pbkRhdGVUcyA9IHJvdW5kRGVjKG1pbkRhdGUgKiBtcywgMyk7XHJcblxyXG5cdFx0XHQvLyBnZXQgdHMgb2YgMTJhbSAodGhpcyBsYW5kcyB1cyBhdCBvciBiZWZvcmUgdGhlIG9yaWdpbmFsIHNjYWxlTWluKVxyXG5cdFx0XHRsZXQgbWluTWluID0gbWtEYXRlKG1pbkRhdGUuZ2V0RnVsbFllYXIoKSwgaXNZciA/IDAgOiBtaW5EYXRlLmdldE1vbnRoKCksIGlzTW8gfHwgaXNZciA/IDEgOiBtaW5EYXRlLmdldERhdGUoKSk7XHJcblx0XHRcdGxldCBtaW5NaW5UcyA9IHJvdW5kRGVjKG1pbk1pbiAqIG1zLCAzKTtcclxuXHJcblx0XHRcdGlmIChpc01vIHx8IGlzWXIpIHtcclxuXHRcdFx0XHRsZXQgbW9JbmNyID0gaXNNbyA/IGZvdW5kSW5jciAvIG1vIDogMDtcclxuXHRcdFx0XHRsZXQgeXJJbmNyID0gaXNZciA/IGZvdW5kSW5jciAvIHkgIDogMDtcclxuXHRcdFx0Ly9cdGxldCB0ek9mZnNldCA9IHNjYWxlTWluIC0gbWluRGF0ZVRzO1x0XHQvLyBuZWVkZWQ/XHJcblx0XHRcdFx0bGV0IHNwbGl0ID0gbWluRGF0ZVRzID09IG1pbk1pblRzID8gbWluRGF0ZVRzIDogcm91bmREZWMobWtEYXRlKG1pbk1pbi5nZXRGdWxsWWVhcigpICsgeXJJbmNyLCBtaW5NaW4uZ2V0TW9udGgoKSArIG1vSW5jciwgMSkgKiBtcywgMyk7XHJcblx0XHRcdFx0bGV0IHNwbGl0RGF0ZSA9IG5ldyBEYXRlKHJvdW5kKHNwbGl0IC8gbXMpKTtcclxuXHRcdFx0XHRsZXQgYmFzZVllYXIgPSBzcGxpdERhdGUuZ2V0RnVsbFllYXIoKTtcclxuXHRcdFx0XHRsZXQgYmFzZU1vbnRoID0gc3BsaXREYXRlLmdldE1vbnRoKCk7XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBzcGxpdCA8PSBzY2FsZU1heDsgaSsrKSB7XHJcblx0XHRcdFx0XHRsZXQgbmV4dCA9IG1rRGF0ZShiYXNlWWVhciArIHlySW5jciAqIGksIGJhc2VNb250aCArIG1vSW5jciAqIGksIDEpO1xyXG5cdFx0XHRcdFx0bGV0IG9mZnMgPSBuZXh0IC0gdHpEYXRlKHJvdW5kRGVjKG5leHQgKiBtcywgMykpO1xyXG5cclxuXHRcdFx0XHRcdHNwbGl0ID0gcm91bmREZWMoKCtuZXh0ICsgb2ZmcykgKiBtcywgMyk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKHNwbGl0IDw9IHNjYWxlTWF4KVxyXG5cdFx0XHRcdFx0XHRzcGxpdHMucHVzaChzcGxpdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGxldCBpbmNyMCA9IGZvdW5kSW5jciA+PSBkID8gZCA6IGZvdW5kSW5jcjtcclxuXHRcdFx0XHRsZXQgdHpPZmZzZXQgPSBmbG9vcihzY2FsZU1pbikgLSBmbG9vcihtaW5EYXRlVHMpO1xyXG5cdFx0XHRcdGxldCBzcGxpdCA9IG1pbk1pblRzICsgdHpPZmZzZXQgKyBpbmNyUm91bmRVcChtaW5EYXRlVHMgLSBtaW5NaW5UcywgaW5jcjApO1xyXG5cdFx0XHRcdHNwbGl0cy5wdXNoKHNwbGl0KTtcclxuXHJcblx0XHRcdFx0bGV0IGRhdGUwID0gdHpEYXRlKHNwbGl0KTtcclxuXHJcblx0XHRcdFx0bGV0IHByZXZIb3VyID0gZGF0ZTAuZ2V0SG91cnMoKSArIChkYXRlMC5nZXRNaW51dGVzKCkgLyBtKSArIChkYXRlMC5nZXRTZWNvbmRzKCkgLyBoKTtcclxuXHRcdFx0XHRsZXQgaW5jckhvdXJzID0gZm91bmRJbmNyIC8gaDtcclxuXHJcblx0XHRcdFx0bGV0IG1pblNwYWNlID0gc2VsZi5heGVzW2F4aXNJZHhdLl9zcGFjZTtcclxuXHRcdFx0XHRsZXQgcGN0U3BhY2UgPSBmb3VuZFNwYWNlIC8gbWluU3BhY2U7XHJcblxyXG5cdFx0XHRcdHdoaWxlICgxKSB7XHJcblx0XHRcdFx0XHRzcGxpdCA9IHJvdW5kRGVjKHNwbGl0ICsgZm91bmRJbmNyLCBtcyA9PSAxID8gMCA6IDMpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChzcGxpdCA+IHNjYWxlTWF4KVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRpZiAoaW5jckhvdXJzID4gMSkge1xyXG5cdFx0XHRcdFx0XHRsZXQgZXhwZWN0ZWRIb3VyID0gZmxvb3Iocm91bmREZWMocHJldkhvdXIgKyBpbmNySG91cnMsIDYpKSAlIDI0O1xyXG5cdFx0XHRcdFx0XHRsZXQgc3BsaXREYXRlID0gdHpEYXRlKHNwbGl0KTtcclxuXHRcdFx0XHRcdFx0bGV0IGFjdHVhbEhvdXIgPSBzcGxpdERhdGUuZ2V0SG91cnMoKTtcclxuXHJcblx0XHRcdFx0XHRcdGxldCBkc3RTaGlmdCA9IGFjdHVhbEhvdXIgLSBleHBlY3RlZEhvdXI7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoZHN0U2hpZnQgPiAxKVxyXG5cdFx0XHRcdFx0XHRcdGRzdFNoaWZ0ID0gLTE7XHJcblxyXG5cdFx0XHRcdFx0XHRzcGxpdCAtPSBkc3RTaGlmdCAqIGg7XHJcblxyXG5cdFx0XHRcdFx0XHRwcmV2SG91ciA9IChwcmV2SG91ciArIGluY3JIb3VycykgJSAyNDtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGFkZCBhIHRpY2sgb25seSBpZiBpdCdzIGZ1cnRoZXIgdGhhbiA3MCUgb2YgdGhlIG1pbiBhbGxvd2VkIGxhYmVsIHNwYWNpbmdcclxuXHRcdFx0XHRcdFx0bGV0IHByZXZTcGxpdCA9IHNwbGl0c1tzcGxpdHMubGVuZ3RoIC0gMV07XHJcblx0XHRcdFx0XHRcdGxldCBwY3RJbmNyID0gcm91bmREZWMoKHNwbGl0IC0gcHJldlNwbGl0KSAvIGZvdW5kSW5jciwgMyk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAocGN0SW5jciAqIHBjdFNwYWNlID49IC43KVxyXG5cdFx0XHRcdFx0XHRcdHNwbGl0cy5wdXNoKHNwbGl0KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0c3BsaXRzLnB1c2goc3BsaXQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHNwbGl0cztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBbXHJcblx0XHR0aW1lSW5jcnMsXHJcblx0XHRfdGltZUF4aXNTdGFtcHMsXHJcblx0XHR0aW1lQXhpc1NwbGl0cyxcclxuXHRdO1xyXG59XHJcblxyXG5jb25zdCBbIHRpbWVJbmNyc01zLCBfdGltZUF4aXNTdGFtcHNNcywgdGltZUF4aXNTcGxpdHNNcyBdID0gZ2VuVGltZVN0dWZmcygxKTtcclxuY29uc3QgWyB0aW1lSW5jcnNTLCAgX3RpbWVBeGlzU3RhbXBzUywgIHRpbWVBeGlzU3BsaXRzUyAgXSA9IGdlblRpbWVTdHVmZnMoMWUtMyk7XHJcblxyXG4vLyBiYXNlIDJcclxuZ2VuSW5jcnMoMiwgLTUzLCA1MywgWzFdKTtcclxuXHJcbi8qXHJcbmNvbnNvbGUubG9nKHtcclxuXHRkZWNJbmNycyxcclxuXHRvbmVJbmNycyxcclxuXHR3aG9sZUluY3JzLFxyXG5cdG51bUluY3JzLFxyXG5cdHRpbWVJbmNycyxcclxuXHRmaXhlZERlYyxcclxufSk7XHJcbiovXHJcblxyXG5mdW5jdGlvbiB0aW1lQXhpc1N0YW1wcyhzdGFtcENmZywgZm10RGF0ZSkge1xyXG5cdHJldHVybiBzdGFtcENmZy5tYXAocyA9PiBzLm1hcCgodiwgaSkgPT5cclxuXHRcdGkgPT0gMCB8fCBpID09IDggfHwgdiA9PSBudWxsID8gdiA6IGZtdERhdGUoaSA9PSAxIHx8IHNbOF0gPT0gMCA/IHYgOiBzWzFdICsgdilcclxuXHQpKTtcclxufVxyXG5cclxuLy8gVE9ETzogd2lsbCBuZWVkIHRvIGFjY2VwdCBzcGFjZXNbXSBhbmQgcHVsbCBpbmNyIGludG8gdGhlIGxvb3Agd2hlbiBncmlkIHdpbGwgYmUgbm9uLXVuaWZvcm0sIGVnIGZvciBsb2cgc2NhbGVzLlxyXG4vLyBjdXJyZW50bHkgd2UgaWdub3JlIHRoaXMgZm9yIG1vbnRocyBzaW5jZSB0aGV5J3JlICpuZWFybHkqIHVuaWZvcm0gYW5kIHRoZSBhZGRlZCBjb21wbGV4aXR5IGlzIG5vdCB3b3J0aCBpdFxyXG5mdW5jdGlvbiB0aW1lQXhpc1ZhbHModHpEYXRlLCBzdGFtcHMpIHtcclxuXHRyZXR1cm4gKHNlbGYsIHNwbGl0cywgYXhpc0lkeCwgZm91bmRTcGFjZSwgZm91bmRJbmNyKSA9PiB7XHJcblx0XHRsZXQgcyA9IHN0YW1wcy5maW5kKHMgPT4gZm91bmRJbmNyID49IHNbMF0pIHx8IHN0YW1wc1tzdGFtcHMubGVuZ3RoIC0gMV07XHJcblxyXG5cdFx0Ly8gdGhlc2UgdHJhY2sgYm91bmRhcmllcyB3aGVuIGEgZnVsbCBsYWJlbCBpcyBuZWVkZWQgYWdhaW5cclxuXHRcdGxldCBwcmV2WWVhcjtcclxuXHRcdGxldCBwcmV2TW50aDtcclxuXHRcdGxldCBwcmV2RGF0ZTtcclxuXHRcdGxldCBwcmV2SG91cjtcclxuXHRcdGxldCBwcmV2TWlucztcclxuXHRcdGxldCBwcmV2U2VjcztcclxuXHJcblx0XHRyZXR1cm4gc3BsaXRzLm1hcChzcGxpdCA9PiB7XHJcblx0XHRcdGxldCBkYXRlID0gdHpEYXRlKHNwbGl0KTtcclxuXHJcblx0XHRcdGxldCBuZXdZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xyXG5cdFx0XHRsZXQgbmV3TW50aCA9IGRhdGUuZ2V0TW9udGgoKTtcclxuXHRcdFx0bGV0IG5ld0RhdGUgPSBkYXRlLmdldERhdGUoKTtcclxuXHRcdFx0bGV0IG5ld0hvdXIgPSBkYXRlLmdldEhvdXJzKCk7XHJcblx0XHRcdGxldCBuZXdNaW5zID0gZGF0ZS5nZXRNaW51dGVzKCk7XHJcblx0XHRcdGxldCBuZXdTZWNzID0gZGF0ZS5nZXRTZWNvbmRzKCk7XHJcblxyXG5cdFx0XHRsZXQgc3RhbXAgPSAoXHJcblx0XHRcdFx0bmV3WWVhciAhPSBwcmV2WWVhciAmJiBzWzJdIHx8XHJcblx0XHRcdFx0bmV3TW50aCAhPSBwcmV2TW50aCAmJiBzWzNdIHx8XHJcblx0XHRcdFx0bmV3RGF0ZSAhPSBwcmV2RGF0ZSAmJiBzWzRdIHx8XHJcblx0XHRcdFx0bmV3SG91ciAhPSBwcmV2SG91ciAmJiBzWzVdIHx8XHJcblx0XHRcdFx0bmV3TWlucyAhPSBwcmV2TWlucyAmJiBzWzZdIHx8XHJcblx0XHRcdFx0bmV3U2VjcyAhPSBwcmV2U2VjcyAmJiBzWzddIHx8XHJcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICBzWzFdXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRwcmV2WWVhciA9IG5ld1llYXI7XHJcblx0XHRcdHByZXZNbnRoID0gbmV3TW50aDtcclxuXHRcdFx0cHJldkRhdGUgPSBuZXdEYXRlO1xyXG5cdFx0XHRwcmV2SG91ciA9IG5ld0hvdXI7XHJcblx0XHRcdHByZXZNaW5zID0gbmV3TWlucztcclxuXHRcdFx0cHJldlNlY3MgPSBuZXdTZWNzO1xyXG5cclxuXHRcdFx0cmV0dXJuIHN0YW1wKGRhdGUpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBmb3Igd2hlbiBheGlzLnZhbHVlcyBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIGZtdERhdGUgdGVtcGxhdGUgc3RyaW5nXHJcbmZ1bmN0aW9uIHRpbWVBeGlzVmFsKHR6RGF0ZSwgZGF0ZVRwbCkge1xyXG5cdGxldCBzdGFtcCA9IGZtdERhdGUoZGF0ZVRwbCk7XHJcblx0cmV0dXJuIChzZWxmLCBzcGxpdHMsIGF4aXNJZHgsIGZvdW5kU3BhY2UsIGZvdW5kSW5jcikgPT4gc3BsaXRzLm1hcChzcGxpdCA9PiBzdGFtcCh0ekRhdGUoc3BsaXQpKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1rRGF0ZSh5LCBtLCBkKSB7XHJcblx0cmV0dXJuIG5ldyBEYXRlKHksIG0sIGQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0aW1lU2VyaWVzU3RhbXAoc3RhbXBDZmcsIGZtdERhdGUpIHtcclxuXHRyZXR1cm4gZm10RGF0ZShzdGFtcENmZyk7XHJcbn1cclxuY29uc3QgX3RpbWVTZXJpZXNTdGFtcCA9ICd7WVlZWX0te01NfS17RER9IHtofTp7bW19e2FhfSc7XHJcblxyXG5mdW5jdGlvbiB0aW1lU2VyaWVzVmFsKHR6RGF0ZSwgc3RhbXApIHtcclxuXHRyZXR1cm4gKHNlbGYsIHZhbCwgc2VyaWVzSWR4LCBkYXRhSWR4KSA9PiBkYXRhSWR4ID09IG51bGwgPyBMRUdFTkRfRElTUCA6IHN0YW1wKHR6RGF0ZSh2YWwpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGVnZW5kU3Ryb2tlKHNlbGYsIHNlcmllc0lkeCkge1xyXG5cdGxldCBzID0gc2VsZi5zZXJpZXNbc2VyaWVzSWR4XTtcclxuXHRyZXR1cm4gcy53aWR0aCA/IHMuc3Ryb2tlKHNlbGYsIHNlcmllc0lkeCkgOiBzLnBvaW50cy53aWR0aCA/IHMucG9pbnRzLnN0cm9rZShzZWxmLCBzZXJpZXNJZHgpIDogbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gbGVnZW5kRmlsbChzZWxmLCBzZXJpZXNJZHgpIHtcclxuXHRyZXR1cm4gc2VsZi5zZXJpZXNbc2VyaWVzSWR4XS5maWxsKHNlbGYsIHNlcmllc0lkeCk7XHJcbn1cclxuXHJcbmNvbnN0IGxlZ2VuZE9wdHMgPSB7XHJcblx0c2hvdzogdHJ1ZSxcclxuXHRsaXZlOiB0cnVlLFxyXG5cdGlzb2xhdGU6IGZhbHNlLFxyXG5cdG1vdW50OiBub29wLFxyXG5cdG1hcmtlcnM6IHtcclxuXHRcdHNob3c6IHRydWUsXHJcblx0XHR3aWR0aDogMixcclxuXHRcdHN0cm9rZTogbGVnZW5kU3Ryb2tlLFxyXG5cdFx0ZmlsbDogbGVnZW5kRmlsbCxcclxuXHRcdGRhc2g6IFwic29saWRcIixcclxuXHR9LFxyXG5cdGlkeDogbnVsbCxcclxuXHRpZHhzOiBudWxsLFxyXG5cdHZhbHVlczogW10sXHJcbn07XHJcblxyXG5mdW5jdGlvbiBjdXJzb3JQb2ludFNob3coc2VsZiwgc2kpIHtcclxuXHRsZXQgbyA9IHNlbGYuY3Vyc29yLnBvaW50cztcclxuXHJcblx0bGV0IHB0ID0gcGxhY2VEaXYoKTtcclxuXHJcblx0bGV0IHNpemUgPSBvLnNpemUoc2VsZiwgc2kpO1xyXG5cdHNldFN0eWxlUHgocHQsIFdJRFRILCBzaXplKTtcclxuXHRzZXRTdHlsZVB4KHB0LCBIRUlHSFQsIHNpemUpO1xyXG5cclxuXHRsZXQgbWFyID0gc2l6ZSAvIC0yO1xyXG5cdHNldFN0eWxlUHgocHQsIFwibWFyZ2luTGVmdFwiLCBtYXIpO1xyXG5cdHNldFN0eWxlUHgocHQsIFwibWFyZ2luVG9wXCIsIG1hcik7XHJcblxyXG5cdGxldCB3aWR0aCA9IG8ud2lkdGgoc2VsZiwgc2ksIHNpemUpO1xyXG5cdHdpZHRoICYmIHNldFN0eWxlUHgocHQsIFwiYm9yZGVyV2lkdGhcIiwgd2lkdGgpO1xyXG5cclxuXHRyZXR1cm4gcHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGN1cnNvclBvaW50RmlsbChzZWxmLCBzaSkge1xyXG5cdGxldCBzcCA9IHNlbGYuc2VyaWVzW3NpXS5wb2ludHM7XHJcblx0cmV0dXJuIHNwLl9maWxsIHx8IHNwLl9zdHJva2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGN1cnNvclBvaW50U3Ryb2tlKHNlbGYsIHNpKSB7XHJcblx0bGV0IHNwID0gc2VsZi5zZXJpZXNbc2ldLnBvaW50cztcclxuXHRyZXR1cm4gc3AuX3N0cm9rZSB8fCBzcC5fZmlsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3Vyc29yUG9pbnRTaXplKHNlbGYsIHNpKSB7XHJcblx0bGV0IHNwID0gc2VsZi5zZXJpZXNbc2ldLnBvaW50cztcclxuXHRyZXR1cm4gc3Auc2l6ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGF0YUlkeChzZWxmLCBzZXJpZXNJZHgsIGN1cnNvcklkeCkge1xyXG5cdHJldHVybiBjdXJzb3JJZHg7XHJcbn1cclxuXHJcbmNvbnN0IG1vdmVUdXBsZSA9IFswLDBdO1xyXG5cclxuZnVuY3Rpb24gY3Vyc29yTW92ZShzZWxmLCBtb3VzZUxlZnQxLCBtb3VzZVRvcDEpIHtcclxuXHRtb3ZlVHVwbGVbMF0gPSBtb3VzZUxlZnQxO1xyXG5cdG1vdmVUdXBsZVsxXSA9IG1vdXNlVG9wMTtcclxuXHRyZXR1cm4gbW92ZVR1cGxlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0QnRuMChzZWxmLCB0YXJnLCBoYW5kbGUsIG9ubHlUYXJnID0gdHJ1ZSkge1xyXG5cdHJldHVybiBlID0+IHtcclxuXHRcdGUuYnV0dG9uID09IDAgJiYgKCFvbmx5VGFyZyB8fCBlLnRhcmdldCA9PSB0YXJnKSAmJiBoYW5kbGUoZSk7XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmlsdFRhcmcoc2VsZiwgdGFyZywgaGFuZGxlLCBvbmx5VGFyZyA9IHRydWUpIHtcclxuXHRyZXR1cm4gZSA9PiB7XHJcblx0XHQoIW9ubHlUYXJnIHx8IGUudGFyZ2V0ID09IHRhcmcpICYmIGhhbmRsZShlKTtcclxuXHR9O1xyXG59XHJcblxyXG5jb25zdCBjdXJzb3JPcHRzID0ge1xyXG5cdHNob3c6IHRydWUsXHJcblx0eDogdHJ1ZSxcclxuXHR5OiB0cnVlLFxyXG5cdGxvY2s6IGZhbHNlLFxyXG5cdG1vdmU6IGN1cnNvck1vdmUsXHJcblx0cG9pbnRzOiB7XHJcblx0XHRzaG93OiAgIGN1cnNvclBvaW50U2hvdyxcclxuXHRcdHNpemU6ICAgY3Vyc29yUG9pbnRTaXplLFxyXG5cdFx0d2lkdGg6ICAwLFxyXG5cdFx0c3Ryb2tlOiBjdXJzb3JQb2ludFN0cm9rZSxcclxuXHRcdGZpbGw6ICAgY3Vyc29yUG9pbnRGaWxsLFxyXG5cdH0sXHJcblxyXG5cdGJpbmQ6IHtcclxuXHRcdG1vdXNlZG93bjogICBmaWx0QnRuMCxcclxuXHRcdG1vdXNldXA6ICAgICBmaWx0QnRuMCxcclxuXHRcdGNsaWNrOiAgICAgICBmaWx0QnRuMCwgLy8gbGVnZW5kIGNsaWNrcywgbm90IC51LW92ZXIgY2xpY2tzXHJcblx0XHRkYmxjbGljazogICAgZmlsdEJ0bjAsXHJcblxyXG5cdFx0bW91c2Vtb3ZlOiAgIGZpbHRUYXJnLFxyXG5cdFx0bW91c2VsZWF2ZTogIGZpbHRUYXJnLFxyXG5cdFx0bW91c2VlbnRlcjogIGZpbHRUYXJnLFxyXG5cdH0sXHJcblxyXG5cdGRyYWc6IHtcclxuXHRcdHNldFNjYWxlOiB0cnVlLFxyXG5cdFx0eDogdHJ1ZSxcclxuXHRcdHk6IGZhbHNlLFxyXG5cdFx0ZGlzdDogMCxcclxuXHRcdHVuaTogbnVsbCxcclxuXHRcdGNsaWNrOiAoc2VsZiwgZSkgPT4ge1xyXG5cdFx0Ly9cdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuXHRcdH0sXHJcblx0XHRfeDogZmFsc2UsXHJcblx0XHRfeTogZmFsc2UsXHJcblx0fSxcclxuXHJcblx0Zm9jdXM6IHtcclxuXHRcdHByb3g6IC0xLFxyXG5cdFx0YmlhczogMCxcclxuXHR9LFxyXG5cclxuXHRsZWZ0OiAtMTAsXHJcblx0dG9wOiAtMTAsXHJcblx0aWR4OiBudWxsLFxyXG5cdGRhdGFJZHgsXHJcblx0aWR4czogbnVsbCxcclxuXHJcblx0ZXZlbnQ6IG51bGwsXHJcbn07XHJcblxyXG5jb25zdCBheGlzTGluZXMgPSB7XHJcblx0c2hvdzogdHJ1ZSxcclxuXHRzdHJva2U6IFwicmdiYSgwLDAsMCwwLjA3KVwiLFxyXG5cdHdpZHRoOiAyLFxyXG4vL1x0ZGFzaDogW10sXHJcbn07XHJcblxyXG5jb25zdCBncmlkID0gYXNzaWduKHt9LCBheGlzTGluZXMsIHtcclxuXHRmaWx0ZXI6IHJldEFyZzEsXHJcbn0pO1xyXG5cclxuY29uc3QgdGlja3MgPSBhc3NpZ24oe30sIGdyaWQsIHtcclxuXHRzaXplOiAxMCxcclxufSk7XHJcblxyXG5jb25zdCBib3JkZXIgPSBhc3NpZ24oe30sIGF4aXNMaW5lcywge1xyXG5cdHNob3c6IGZhbHNlLFxyXG59KTtcclxuXHJcbmNvbnN0IGZvbnQgICAgICA9ICcxMnB4IHN5c3RlbS11aSwgLWFwcGxlLXN5c3RlbSwgXCJTZWdvZSBVSVwiLCBSb2JvdG8sIFwiSGVsdmV0aWNhIE5ldWVcIiwgQXJpYWwsIFwiTm90byBTYW5zXCIsIHNhbnMtc2VyaWYsIFwiQXBwbGUgQ29sb3IgRW1vamlcIiwgXCJTZWdvZSBVSSBFbW9qaVwiLCBcIlNlZ29lIFVJIFN5bWJvbFwiLCBcIk5vdG8gQ29sb3IgRW1vamlcIic7XHJcbmNvbnN0IGxhYmVsRm9udCA9IFwiYm9sZCBcIiArIGZvbnQ7XHJcbmNvbnN0IGxpbmVHYXAgPSAxLjU7XHQvLyBmb250LXNpemUgbXVsdGlwbGllclxyXG5cclxuY29uc3QgeEF4aXNPcHRzID0ge1xyXG5cdHNob3c6IHRydWUsXHJcblx0c2NhbGU6IFwieFwiLFxyXG5cdHN0cm9rZTogaGV4QmxhY2ssXHJcblx0c3BhY2U6IDUwLFxyXG5cdGdhcDogNSxcclxuXHRzaXplOiA1MCxcclxuXHRsYWJlbEdhcDogMCxcclxuXHRsYWJlbFNpemU6IDMwLFxyXG5cdGxhYmVsRm9udCxcclxuXHRzaWRlOiAyLFxyXG4vL1x0Y2xhc3M6IFwieC12YWxzXCIsXHJcbi8vXHRpbmNyczogdGltZUluY3JzLFxyXG4vL1x0dmFsdWVzOiB0aW1lVmFscyxcclxuLy9cdGZpbHRlcjogcmV0QXJnMSxcclxuXHRncmlkLFxyXG5cdHRpY2tzLFxyXG5cdGJvcmRlcixcclxuXHRmb250LFxyXG5cdGxpbmVHYXAsXHJcblx0cm90YXRlOiAwLFxyXG59O1xyXG5cclxuY29uc3QgbnVtU2VyaWVzTGFiZWwgPSBcIlZhbHVlXCI7XHJcbmNvbnN0IHRpbWVTZXJpZXNMYWJlbCA9IFwiVGltZVwiO1xyXG5cclxuY29uc3QgeFNlcmllc09wdHMgPSB7XHJcblx0c2hvdzogdHJ1ZSxcclxuXHRzY2FsZTogXCJ4XCIsXHJcblx0YXV0bzogZmFsc2UsXHJcblx0c29ydGVkOiAxLFxyXG4vL1x0bGFiZWw6IFwiVGltZVwiLFxyXG4vL1x0dmFsdWU6IHYgPT4gc3RhbXAobmV3IERhdGUodiAqIDFlMykpLFxyXG5cclxuXHQvLyBpbnRlcm5hbCBjYWNoZXNcclxuXHRtaW46IGluZixcclxuXHRtYXg6IC1pbmYsXHJcblx0aWR4czogW10sXHJcbn07XHJcblxyXG5mdW5jdGlvbiBudW1BeGlzVmFscyhzZWxmLCBzcGxpdHMsIGF4aXNJZHgsIGZvdW5kU3BhY2UsIGZvdW5kSW5jcikge1xyXG5cdHJldHVybiBzcGxpdHMubWFwKHYgPT4gdiA9PSBudWxsID8gXCJcIiA6IGZtdE51bSh2KSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG51bUF4aXNTcGxpdHMoc2VsZiwgYXhpc0lkeCwgc2NhbGVNaW4sIHNjYWxlTWF4LCBmb3VuZEluY3IsIGZvdW5kU3BhY2UsIGZvcmNlTWluKSB7XHJcblx0bGV0IHNwbGl0cyA9IFtdO1xyXG5cclxuXHRsZXQgbnVtRGVjID0gZml4ZWREZWMuZ2V0KGZvdW5kSW5jcikgfHwgMDtcclxuXHJcblx0c2NhbGVNaW4gPSBmb3JjZU1pbiA/IHNjYWxlTWluIDogcm91bmREZWMoaW5jclJvdW5kVXAoc2NhbGVNaW4sIGZvdW5kSW5jciksIG51bURlYyk7XHJcblxyXG5cdGZvciAobGV0IHZhbCA9IHNjYWxlTWluOyB2YWwgPD0gc2NhbGVNYXg7IHZhbCA9IHJvdW5kRGVjKHZhbCArIGZvdW5kSW5jciwgbnVtRGVjKSlcclxuXHRcdHNwbGl0cy5wdXNoKE9iamVjdC5pcyh2YWwsIC0wKSA/IDAgOiB2YWwpO1x0XHQvLyBjb2FsZXNjZXMgLTBcclxuXHJcblx0cmV0dXJuIHNwbGl0cztcclxufVxyXG5cclxuLy8gdGhpcyBkb2VzbnQgd29yayBmb3Igc2luLCB3aGljaCBuZWVkcyB0byBjb21lIG9mZiBmcm9tIDAgaW5kZXBlbmRlbnRseSBpbiBwb3MgYW5kIG5lZyBkaXJzXHJcbmZ1bmN0aW9uIGxvZ0F4aXNTcGxpdHMoc2VsZiwgYXhpc0lkeCwgc2NhbGVNaW4sIHNjYWxlTWF4LCBmb3VuZEluY3IsIGZvdW5kU3BhY2UsIGZvcmNlTWluKSB7XHJcblx0Y29uc3Qgc3BsaXRzID0gW107XHJcblxyXG5cdGNvbnN0IGxvZ0Jhc2UgPSBzZWxmLnNjYWxlc1tzZWxmLmF4ZXNbYXhpc0lkeF0uc2NhbGVdLmxvZztcclxuXHJcblx0Y29uc3QgbG9nRm4gPSBsb2dCYXNlID09IDEwID8gbG9nMTAgOiBsb2cyO1xyXG5cclxuXHRjb25zdCBleHAgPSBmbG9vcihsb2dGbihzY2FsZU1pbikpO1xyXG5cclxuXHRmb3VuZEluY3IgPSBwb3cobG9nQmFzZSwgZXhwKTtcclxuXHJcblx0aWYgKGxvZ0Jhc2UgPT0gMTAgJiYgZXhwIDwgMClcclxuXHRcdGZvdW5kSW5jciA9IHJvdW5kRGVjKGZvdW5kSW5jciwgLWV4cCk7XHJcblxyXG5cdGxldCBzcGxpdCA9IHNjYWxlTWluO1xyXG5cclxuXHRkbyB7XHJcblx0XHRzcGxpdHMucHVzaChzcGxpdCk7XHJcblx0XHRzcGxpdCA9IHNwbGl0ICsgZm91bmRJbmNyO1xyXG5cclxuXHRcdGlmIChsb2dCYXNlID09IDEwKVxyXG5cdFx0XHRzcGxpdCA9IHJvdW5kRGVjKHNwbGl0LCBmaXhlZERlYy5nZXQoZm91bmRJbmNyKSk7XHJcblxyXG5cdFx0aWYgKHNwbGl0ID49IGZvdW5kSW5jciAqIGxvZ0Jhc2UpXHJcblx0XHRcdGZvdW5kSW5jciA9IHNwbGl0O1xyXG5cclxuXHR9IHdoaWxlIChzcGxpdCA8PSBzY2FsZU1heCk7XHJcblxyXG5cdHJldHVybiBzcGxpdHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFzaW5oQXhpc1NwbGl0cyhzZWxmLCBheGlzSWR4LCBzY2FsZU1pbiwgc2NhbGVNYXgsIGZvdW5kSW5jciwgZm91bmRTcGFjZSwgZm9yY2VNaW4pIHtcclxuXHRsZXQgc2MgPSBzZWxmLnNjYWxlc1tzZWxmLmF4ZXNbYXhpc0lkeF0uc2NhbGVdO1xyXG5cclxuXHRsZXQgbGludGhyZXNoID0gc2MuYXNpbmg7XHJcblxyXG5cdGxldCBwb3NTcGxpdHMgPSBzY2FsZU1heCA+IGxpbnRocmVzaCA/IGxvZ0F4aXNTcGxpdHMoc2VsZiwgYXhpc0lkeCwgbWF4KGxpbnRocmVzaCwgc2NhbGVNaW4pLCBzY2FsZU1heCwgZm91bmRJbmNyKSA6IFtsaW50aHJlc2hdO1xyXG5cdGxldCB6ZXJvID0gc2NhbGVNYXggPj0gMCAmJiBzY2FsZU1pbiA8PSAwID8gWzBdIDogW107XHJcblx0bGV0IG5lZ1NwbGl0cyA9IHNjYWxlTWluIDwgLWxpbnRocmVzaCA/IGxvZ0F4aXNTcGxpdHMoc2VsZiwgYXhpc0lkeCwgbWF4KGxpbnRocmVzaCwgLXNjYWxlTWF4KSwgLXNjYWxlTWluLCBmb3VuZEluY3IpOiBbbGludGhyZXNoXTtcclxuXHJcblx0cmV0dXJuIG5lZ1NwbGl0cy5yZXZlcnNlKCkubWFwKHYgPT4gLXYpLmNvbmNhdCh6ZXJvLCBwb3NTcGxpdHMpO1xyXG59XHJcblxyXG5jb25zdCBSRV9BTEwgICA9IC8uLztcclxuY29uc3QgUkVfMTIzNTcgPSAvWzEyMzU3XS87XHJcbmNvbnN0IFJFXzEyNSAgID0gL1sxMjVdLztcclxuY29uc3QgUkVfMSAgICAgPSAvMS87XHJcblxyXG5jb25zdCBfZmlsdCA9IChzcGxpdHMsIGRpc3RyLCByZSwga2VlcE1vZCkgPT4gc3BsaXRzLm1hcCgodiwgaSkgPT4gKChkaXN0ciA9PSA0ICYmIHYgPT0gMCkgfHwgaSAlIGtlZXBNb2QgPT0gMCAmJiByZS50ZXN0KHYudG9FeHBvbmVudGlhbCgpW3YgPCAwID8gMSA6IDBdKSkgPyB2IDogbnVsbCk7XHJcblxyXG5mdW5jdGlvbiBsb2cxMEF4aXNWYWxzRmlsdChzZWxmLCBzcGxpdHMsIGF4aXNJZHgsIGZvdW5kU3BhY2UsIGZvdW5kSW5jcikge1xyXG5cdGxldCBheGlzID0gc2VsZi5heGVzW2F4aXNJZHhdO1xyXG5cdGxldCBzY2FsZUtleSA9IGF4aXMuc2NhbGU7XHJcblx0bGV0IHNjID0gc2VsZi5zY2FsZXNbc2NhbGVLZXldO1xyXG5cclxuLy9cdGlmIChzYy5kaXN0ciA9PSAzICYmIHNjLmxvZyA9PSAyKVxyXG4vL1x0XHRyZXR1cm4gc3BsaXRzO1xyXG5cclxuXHRsZXQgdmFsVG9Qb3MgPSBzZWxmLnZhbFRvUG9zO1xyXG5cclxuXHRsZXQgbWluU3BhY2UgPSBheGlzLl9zcGFjZTtcclxuXHJcblx0bGV0IF8xMCA9IHZhbFRvUG9zKDEwLCBzY2FsZUtleSk7XHJcblxyXG5cdGxldCByZSA9IChcclxuXHRcdHZhbFRvUG9zKDksIHNjYWxlS2V5KSAtIF8xMCA+PSBtaW5TcGFjZSA/IFJFX0FMTCA6XHJcblx0XHR2YWxUb1Bvcyg3LCBzY2FsZUtleSkgLSBfMTAgPj0gbWluU3BhY2UgPyBSRV8xMjM1NyA6XHJcblx0XHR2YWxUb1Bvcyg1LCBzY2FsZUtleSkgLSBfMTAgPj0gbWluU3BhY2UgPyBSRV8xMjUgOlxyXG5cdFx0UkVfMVxyXG5cdCk7XHJcblxyXG5cdGlmIChyZSA9PSBSRV8xKSB7XHJcblx0XHRsZXQgbWFnU3BhY2UgPSBhYnModmFsVG9Qb3MoMSwgc2NhbGVLZXkpIC0gXzEwKTtcclxuXHJcblx0XHRpZiAobWFnU3BhY2UgPCBtaW5TcGFjZSlcclxuXHRcdFx0cmV0dXJuIF9maWx0KHNwbGl0cy5zbGljZSgpLnJldmVyc2UoKSwgc2MuZGlzdHIsIHJlLCBjZWlsKG1pblNwYWNlIC8gbWFnU3BhY2UpKS5yZXZlcnNlKCk7IC8vIG1heC0+bWluIHNraXBcclxuXHR9XHJcblxyXG5cdHJldHVybiBfZmlsdChzcGxpdHMsIHNjLmRpc3RyLCByZSwgMSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvZzJBeGlzVmFsc0ZpbHQoc2VsZiwgc3BsaXRzLCBheGlzSWR4LCBmb3VuZFNwYWNlLCBmb3VuZEluY3IpIHtcclxuXHRsZXQgYXhpcyA9IHNlbGYuYXhlc1theGlzSWR4XTtcclxuXHRsZXQgc2NhbGVLZXkgPSBheGlzLnNjYWxlO1xyXG5cdGxldCBtaW5TcGFjZSA9IGF4aXMuX3NwYWNlO1xyXG5cdGxldCB2YWxUb1BvcyA9IHNlbGYudmFsVG9Qb3M7XHJcblxyXG5cdGxldCBtYWdTcGFjZSA9IGFicyh2YWxUb1BvcygxLCBzY2FsZUtleSkgLSB2YWxUb1BvcygyLCBzY2FsZUtleSkpO1xyXG5cclxuXHRpZiAobWFnU3BhY2UgPCBtaW5TcGFjZSlcclxuXHRcdHJldHVybiBfZmlsdChzcGxpdHMuc2xpY2UoKS5yZXZlcnNlKCksIDMsIFJFX0FMTCwgY2VpbChtaW5TcGFjZSAvIG1hZ1NwYWNlKSkucmV2ZXJzZSgpOyAvLyBtYXgtPm1pbiBza2lwXHJcblxyXG5cdHJldHVybiBzcGxpdHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG51bVNlcmllc1ZhbChzZWxmLCB2YWwsIHNlcmllc0lkeCwgZGF0YUlkeCkge1xyXG5cdHJldHVybiBkYXRhSWR4ID09IG51bGwgPyBMRUdFTkRfRElTUCA6IHZhbCA9PSBudWxsID8gXCJcIiA6IGZtdE51bSh2YWwpO1xyXG59XHJcblxyXG5jb25zdCB5QXhpc09wdHMgPSB7XHJcblx0c2hvdzogdHJ1ZSxcclxuXHRzY2FsZTogXCJ5XCIsXHJcblx0c3Ryb2tlOiBoZXhCbGFjayxcclxuXHRzcGFjZTogMzAsXHJcblx0Z2FwOiA1LFxyXG5cdHNpemU6IDUwLFxyXG5cdGxhYmVsR2FwOiAwLFxyXG5cdGxhYmVsU2l6ZTogMzAsXHJcblx0bGFiZWxGb250LFxyXG5cdHNpZGU6IDMsXHJcbi8vXHRjbGFzczogXCJ5LXZhbHNcIixcclxuLy9cdGluY3JzOiBudW1JbmNycyxcclxuLy9cdHZhbHVlczogKHZhbHMsIHNwYWNlKSA9PiB2YWxzLFxyXG4vL1x0ZmlsdGVyOiByZXRBcmcxLFxyXG5cdGdyaWQsXHJcblx0dGlja3MsXHJcblx0Ym9yZGVyLFxyXG5cdGZvbnQsXHJcblx0bGluZUdhcCxcclxuXHRyb3RhdGU6IDAsXHJcbn07XHJcblxyXG4vLyB0YWtlcyBzdHJva2Ugd2lkdGhcclxuZnVuY3Rpb24gcHREaWEod2lkdGgsIG11bHQpIHtcclxuXHRsZXQgZGlhID0gMyArICh3aWR0aCB8fCAxKSAqIDI7XHJcblx0cmV0dXJuIHJvdW5kRGVjKGRpYSAqIG11bHQsIDMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXJpZXNQb2ludHNTaG93KHNlbGYsIHNpKSB7XHJcblx0bGV0IHsgc2NhbGUsIGlkeHMgfSA9IHNlbGYuc2VyaWVzWzBdO1xyXG5cdGxldCB4RGF0YSA9IHNlbGYuX2RhdGFbMF07XHJcblx0bGV0IHAwID0gc2VsZi52YWxUb1Bvcyh4RGF0YVtpZHhzWzBdXSwgc2NhbGUsIHRydWUpO1xyXG5cdGxldCBwMSA9IHNlbGYudmFsVG9Qb3MoeERhdGFbaWR4c1sxXV0sIHNjYWxlLCB0cnVlKTtcclxuXHRsZXQgZGltID0gYWJzKHAxIC0gcDApO1xyXG5cclxuXHRsZXQgcyA9IHNlbGYuc2VyaWVzW3NpXTtcclxuLy9cdGNvbnN0IGRpYSA9IHB0RGlhKHMud2lkdGgsIHB4UmF0aW8pO1xyXG5cdGxldCBtYXhQdHMgPSBkaW0gLyAocy5wb2ludHMuc3BhY2UgKiBweFJhdGlvKTtcclxuXHRyZXR1cm4gaWR4c1sxXSAtIGlkeHNbMF0gPD0gbWF4UHRzO1xyXG59XHJcblxyXG5jb25zdCBmYWNldCA9IHtcclxuXHRzY2FsZTogbnVsbCxcclxuXHRhdXRvOiB0cnVlLFxyXG5cdHNvcnRlZDogMCxcclxuXHJcblx0Ly8gaW50ZXJuYWwgY2FjaGVzXHJcblx0bWluOiBpbmYsXHJcblx0bWF4OiAtaW5mLFxyXG59O1xyXG5cclxuY29uc3QgZ2FwcyA9IChzZWxmLCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEsIG51bGxHYXBzKSA9PiBudWxsR2FwcztcclxuXHJcbmNvbnN0IHh5U2VyaWVzT3B0cyA9IHtcclxuXHRzaG93OiB0cnVlLFxyXG5cdGF1dG86IHRydWUsXHJcblx0c29ydGVkOiAwLFxyXG5cdGdhcHMsXHJcblx0YWxwaGE6IDEsXHJcblx0ZmFjZXRzOiBbXHJcblx0XHRhc3NpZ24oe30sIGZhY2V0LCB7c2NhbGU6ICd4J30pLFxyXG5cdFx0YXNzaWduKHt9LCBmYWNldCwge3NjYWxlOiAneSd9KSxcclxuXHRdLFxyXG59O1xyXG5cclxuY29uc3QgeVNlcmllc09wdHMgPSB7XHJcblx0c2NhbGU6IFwieVwiLFxyXG5cdGF1dG86IHRydWUsXHJcblx0c29ydGVkOiAwLFxyXG5cdHNob3c6IHRydWUsXHJcblx0c3BhbkdhcHM6IGZhbHNlLFxyXG5cdGdhcHMsXHJcblx0YWxwaGE6IDEsXHJcblx0cG9pbnRzOiB7XHJcblx0XHRzaG93OiBzZXJpZXNQb2ludHNTaG93LFxyXG5cdFx0ZmlsdGVyOiBudWxsLFxyXG5cdC8vICBwYXRoczpcclxuXHQvL1x0c3Ryb2tlOiBcIiMwMDBcIixcclxuXHQvL1x0ZmlsbDogXCIjZmZmXCIsXHJcblx0Ly9cdHdpZHRoOiAxLFxyXG5cdC8vXHRzaXplOiAxMCxcclxuXHR9LFxyXG4vL1x0bGFiZWw6IFwiVmFsdWVcIixcclxuLy9cdHZhbHVlOiB2ID0+IHYsXHJcblx0dmFsdWVzOiBudWxsLFxyXG5cclxuXHQvLyBpbnRlcm5hbCBjYWNoZXNcclxuXHRtaW46IGluZixcclxuXHRtYXg6IC1pbmYsXHJcblx0aWR4czogW10sXHJcblxyXG5cdHBhdGg6IG51bGwsXHJcblx0Y2xpcDogbnVsbCxcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNsYW1wU2NhbGUoc2VsZiwgdmFsLCBzY2FsZU1pbiwgc2NhbGVNYXgsIHNjYWxlS2V5KSB7XHJcbi8qXHJcblx0aWYgKHZhbCA8IDApIHtcclxuXHRcdGxldCBjc3NIZ3QgPSBzZWxmLmJib3guaGVpZ2h0IC8gcHhSYXRpbztcclxuXHRcdGxldCBhYnNQb3MgPSBzZWxmLnZhbFRvUG9zKGFicyh2YWwpLCBzY2FsZUtleSk7XHJcblx0XHRsZXQgZnJvbUJ0bSA9IGNzc0hndCAtIGFic1BvcztcclxuXHRcdHJldHVybiBzZWxmLnBvc1RvVmFsKGNzc0hndCArIGZyb21CdG0sIHNjYWxlS2V5KTtcclxuXHR9XHJcbiovXHJcblx0cmV0dXJuIHNjYWxlTWluIC8gMTA7XHJcbn1cclxuXHJcbmNvbnN0IHhTY2FsZU9wdHMgPSB7XHJcblx0dGltZTogRkVBVF9USU1FLFxyXG5cdGF1dG86IHRydWUsXHJcblx0ZGlzdHI6IDEsXHJcblx0bG9nOiAxMCxcclxuXHRhc2luaDogMSxcclxuXHRtaW46IG51bGwsXHJcblx0bWF4OiBudWxsLFxyXG5cdGRpcjogMSxcclxuXHRvcmk6IDAsXHJcbn07XHJcblxyXG5jb25zdCB5U2NhbGVPcHRzID0gYXNzaWduKHt9LCB4U2NhbGVPcHRzLCB7XHJcblx0dGltZTogZmFsc2UsXHJcblx0b3JpOiAxLFxyXG59KTtcclxuXHJcbmNvbnN0IHN5bmNzID0ge307XHJcblxyXG5mdW5jdGlvbiBfc3luYyhrZXksIG9wdHMpIHtcclxuXHRsZXQgcyA9IHN5bmNzW2tleV07XHJcblxyXG5cdGlmICghcykge1xyXG5cdFx0cyA9IHtcclxuXHRcdFx0a2V5LFxyXG5cdFx0XHRwbG90czogW10sXHJcblx0XHRcdHN1YihwbG90KSB7XHJcblx0XHRcdFx0cy5wbG90cy5wdXNoKHBsb3QpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHR1bnN1YihwbG90KSB7XHJcblx0XHRcdFx0cy5wbG90cyA9IHMucGxvdHMuZmlsdGVyKGMgPT4gYyAhPSBwbG90KTtcclxuXHRcdFx0fSxcclxuXHRcdFx0cHViKHR5cGUsIHNlbGYsIHgsIHksIHcsIGgsIGkpIHtcclxuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHMucGxvdHMubGVuZ3RoOyBqKyspXHJcblx0XHRcdFx0XHRzLnBsb3RzW2pdICE9IHNlbGYgJiYgcy5wbG90c1tqXS5wdWIodHlwZSwgc2VsZiwgeCwgeSwgdywgaCwgaSk7XHJcblx0XHRcdH0sXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChrZXkgIT0gbnVsbClcclxuXHRcdFx0c3luY3Nba2V5XSA9IHM7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcztcclxufVxyXG5cclxuY29uc3QgQkFORF9DTElQX0ZJTEwgICA9IDEgPDwgMDtcclxuY29uc3QgQkFORF9DTElQX1NUUk9LRSA9IDEgPDwgMTtcclxuXHJcbmZ1bmN0aW9uIG9yaWVudCh1LCBzZXJpZXNJZHgsIGNiKSB7XHJcblx0Y29uc3QgbW9kZSA9IHUubW9kZTtcclxuXHRjb25zdCBzZXJpZXMgPSB1LnNlcmllc1tzZXJpZXNJZHhdO1xyXG5cdGNvbnN0IGRhdGEgPSBtb2RlID09IDIgPyB1Ll9kYXRhW3Nlcmllc0lkeF0gOiB1Ll9kYXRhO1xyXG5cdGNvbnN0IHNjYWxlcyA9IHUuc2NhbGVzO1xyXG5cdGNvbnN0IGJib3ggICA9IHUuYmJveDtcclxuXHJcblx0bGV0IGR4ID0gZGF0YVswXSxcclxuXHRcdGR5ID0gbW9kZSA9PSAyID8gZGF0YVsxXSA6IGRhdGFbc2VyaWVzSWR4XSxcclxuXHRcdHN4ID0gbW9kZSA9PSAyID8gc2NhbGVzW3Nlcmllcy5mYWNldHNbMF0uc2NhbGVdIDogc2NhbGVzW3Uuc2VyaWVzWzBdLnNjYWxlXSxcclxuXHRcdHN5ID0gbW9kZSA9PSAyID8gc2NhbGVzW3Nlcmllcy5mYWNldHNbMV0uc2NhbGVdIDogc2NhbGVzW3Nlcmllcy5zY2FsZV0sXHJcblx0XHRsID0gYmJveC5sZWZ0LFxyXG5cdFx0dCA9IGJib3gudG9wLFxyXG5cdFx0dyA9IGJib3gud2lkdGgsXHJcblx0XHRoID0gYmJveC5oZWlnaHQsXHJcblx0XHRIID0gdS52YWxUb1Bvc0gsXHJcblx0XHRWID0gdS52YWxUb1Bvc1Y7XHJcblxyXG5cdHJldHVybiAoc3gub3JpID09IDBcclxuXHRcdD8gY2IoXHJcblx0XHRcdHNlcmllcyxcclxuXHRcdFx0ZHgsXHJcblx0XHRcdGR5LFxyXG5cdFx0XHRzeCxcclxuXHRcdFx0c3ksXHJcblx0XHRcdEgsXHJcblx0XHRcdFYsXHJcblx0XHRcdGwsXHJcblx0XHRcdHQsXHJcblx0XHRcdHcsXHJcblx0XHRcdGgsXHJcblx0XHRcdG1vdmVUb0gsXHJcblx0XHRcdGxpbmVUb0gsXHJcblx0XHRcdHJlY3RILFxyXG5cdFx0XHRhcmNILFxyXG5cdFx0XHRiZXppZXJDdXJ2ZVRvSCxcclxuXHRcdClcclxuXHRcdDogY2IoXHJcblx0XHRcdHNlcmllcyxcclxuXHRcdFx0ZHgsXHJcblx0XHRcdGR5LFxyXG5cdFx0XHRzeCxcclxuXHRcdFx0c3ksXHJcblx0XHRcdFYsXHJcblx0XHRcdEgsXHJcblx0XHRcdHQsXHJcblx0XHRcdGwsXHJcblx0XHRcdGgsXHJcblx0XHRcdHcsXHJcblx0XHRcdG1vdmVUb1YsXHJcblx0XHRcdGxpbmVUb1YsXHJcblx0XHRcdHJlY3RWLFxyXG5cdFx0XHRhcmNWLFxyXG5cdFx0XHRiZXppZXJDdXJ2ZVRvVixcclxuXHRcdClcclxuXHQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBiYW5kRmlsbENsaXBEaXJzKHNlbGYsIHNlcmllc0lkeCkge1xyXG5cdGxldCBmaWxsRGlyID0gMDtcclxuXHJcblx0Ly8gMiBiaXRzLCAtMSB8IDFcclxuXHRsZXQgY2xpcERpcnMgPSAwO1xyXG5cclxuXHRsZXQgYmFuZHMgPSBpZk51bGwoc2VsZi5iYW5kcywgRU1QVFlfQVJSKTtcclxuXHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBiYW5kcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0bGV0IGIgPSBiYW5kc1tpXTtcclxuXHJcblx0XHQvLyBpcyBhIFwiZnJvbVwiIGJhbmQgZWRnZVxyXG5cdFx0aWYgKGIuc2VyaWVzWzBdID09IHNlcmllc0lkeClcclxuXHRcdFx0ZmlsbERpciA9IGIuZGlyO1xyXG5cdFx0Ly8gaXMgYSBcInRvXCIgYmFuZCBlZGdlXHJcblx0XHRlbHNlIGlmIChiLnNlcmllc1sxXSA9PSBzZXJpZXNJZHgpIHtcclxuXHRcdFx0aWYgKGIuZGlyID09IDEpXHJcblx0XHRcdFx0Y2xpcERpcnMgfD0gMTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdGNsaXBEaXJzIHw9IDI7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gW1xyXG5cdFx0ZmlsbERpcixcclxuXHRcdChcclxuXHRcdFx0Y2xpcERpcnMgPT0gMSA/IC0xIDogLy8gbmVnIG9ubHlcclxuXHRcdFx0Y2xpcERpcnMgPT0gMiA/ICAxIDogLy8gcG9zIG9ubHlcclxuXHRcdFx0Y2xpcERpcnMgPT0gMyA/ICAyIDogLy8gYm90aFxyXG5cdFx0XHQgICAgICAgICAgICAgICAgIDAgICAvLyBuZWl0aGVyXHJcblx0XHQpXHJcblx0XTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VyaWVzRmlsbFRvKHNlbGYsIHNlcmllc0lkeCwgZGF0YU1pbiwgZGF0YU1heCwgYmFuZEZpbGxEaXIpIHtcclxuXHRsZXQgbW9kZSA9IHNlbGYubW9kZTtcclxuXHRsZXQgc2VyaWVzID0gc2VsZi5zZXJpZXNbc2VyaWVzSWR4XTtcclxuXHRsZXQgc2NhbGVLZXkgPSBtb2RlID09IDIgPyBzZXJpZXMuZmFjZXRzWzFdLnNjYWxlIDogc2VyaWVzLnNjYWxlO1xyXG5cdGxldCBzY2FsZSA9IHNlbGYuc2NhbGVzW3NjYWxlS2V5XTtcclxuXHJcblx0cmV0dXJuIChcclxuXHRcdGJhbmRGaWxsRGlyID09IC0xID8gc2NhbGUubWluIDpcclxuXHRcdGJhbmRGaWxsRGlyID09ICAxID8gc2NhbGUubWF4IDpcclxuXHRcdHNjYWxlLmRpc3RyID09ICAzID8gKFxyXG5cdFx0XHRzY2FsZS5kaXIgPT0gMSA/IHNjYWxlLm1pbiA6XHJcblx0XHRcdHNjYWxlLm1heFxyXG5cdFx0KSA6IDBcclxuXHQpO1xyXG59XHJcblxyXG4vLyBjcmVhdGVzIGludmVydGVkIGJhbmQgY2xpcCBwYXRoIChmcm9tIHN0cm9rZSBwYXRoIC0+IHlNYXggfHwgeU1pbilcclxuLy8gY2xpcERpciBpcyBhbHdheXMgaW52ZXJzZSBvZiBmaWxsRGlyXHJcbi8vIGRlZmF1bHQgY2xpcCBkaXIgaXMgdXB3YXJkcyAoMSksIHNpbmNlIGRlZmF1bHQgYmFuZCBmaWxsIGlzIGRvd253YXJkcy9maWxsQmVsb3dUbyAoLTEpIChoaWdoSWR4IC0+IGxvd0lkeClcclxuZnVuY3Rpb24gY2xpcEJhbmRMaW5lKHNlbGYsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgc3Ryb2tlUGF0aCwgY2xpcERpcikge1xyXG5cdHJldHVybiBvcmllbnQoc2VsZiwgc2VyaWVzSWR4LCAoc2VyaWVzLCBkYXRhWCwgZGF0YVksIHNjYWxlWCwgc2NhbGVZLCB2YWxUb1Bvc1gsIHZhbFRvUG9zWSwgeE9mZiwgeU9mZiwgeERpbSwgeURpbSkgPT4ge1xyXG5cdFx0bGV0IHB4Um91bmQgPSBzZXJpZXMucHhSb3VuZDtcclxuXHJcblx0XHRjb25zdCBkaXIgPSBzY2FsZVguZGlyICogKHNjYWxlWC5vcmkgPT0gMCA/IDEgOiAtMSk7XHJcblx0XHRjb25zdCBsaW5lVG8gPSBzY2FsZVgub3JpID09IDAgPyBsaW5lVG9IIDogbGluZVRvVjtcclxuXHJcblx0XHRsZXQgZnJJZHgsIHRvSWR4O1xyXG5cclxuXHRcdGlmIChkaXIgPT0gMSkge1xyXG5cdFx0XHRmcklkeCA9IGlkeDA7XHJcblx0XHRcdHRvSWR4ID0gaWR4MTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRmcklkeCA9IGlkeDE7XHJcblx0XHRcdHRvSWR4ID0gaWR4MDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBwYXRoIHN0YXJ0XHJcblx0XHRsZXQgeDAgPSBweFJvdW5kKHZhbFRvUG9zWChkYXRhWFtmcklkeF0sIHNjYWxlWCwgeERpbSwgeE9mZikpO1xyXG5cdFx0bGV0IHkwID0gcHhSb3VuZCh2YWxUb1Bvc1koZGF0YVlbZnJJZHhdLCBzY2FsZVksIHlEaW0sIHlPZmYpKTtcclxuXHRcdC8vIHBhdGggZW5kIHhcclxuXHRcdGxldCB4MSA9IHB4Um91bmQodmFsVG9Qb3NYKGRhdGFYW3RvSWR4XSwgc2NhbGVYLCB4RGltLCB4T2ZmKSk7XHJcblx0XHQvLyB1cHBlciBvciBsb3dlciB5IGxpbWl0XHJcblx0XHRsZXQgeUxpbWl0ID0gcHhSb3VuZCh2YWxUb1Bvc1koY2xpcERpciA9PSAxID8gc2NhbGVZLm1heCA6IHNjYWxlWS5taW4sIHNjYWxlWSwgeURpbSwgeU9mZikpO1xyXG5cclxuXHRcdGxldCBjbGlwID0gbmV3IFBhdGgyRChzdHJva2VQYXRoKTtcclxuXHJcblx0XHRsaW5lVG8oY2xpcCwgeDEsIHlMaW1pdCk7XHJcblx0XHRsaW5lVG8oY2xpcCwgeDAsIHlMaW1pdCk7XHJcblx0XHRsaW5lVG8oY2xpcCwgeDAsIHkwKTtcclxuXHJcblx0XHRyZXR1cm4gY2xpcDtcclxuXHR9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2xpcEdhcHMoZ2Fwcywgb3JpLCBwbG90TGZ0LCBwbG90VG9wLCBwbG90V2lkLCBwbG90SGd0KSB7XHJcblx0bGV0IGNsaXAgPSBudWxsO1xyXG5cclxuXHQvLyBjcmVhdGUgY2xpcCBwYXRoIChpbnZlcnQgZ2FwcyBhbmQgbm9uLWdhcHMpXHJcblx0aWYgKGdhcHMubGVuZ3RoID4gMCkge1xyXG5cdFx0Y2xpcCA9IG5ldyBQYXRoMkQoKTtcclxuXHJcblx0XHRjb25zdCByZWN0ID0gb3JpID09IDAgPyByZWN0SCA6IHJlY3RWO1xyXG5cclxuXHRcdGxldCBwcmV2R2FwRW5kID0gcGxvdExmdDtcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGdhcHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGcgPSBnYXBzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGdbMV0gPiBnWzBdKSB7XHJcblx0XHRcdFx0bGV0IHcgPSBnWzBdIC0gcHJldkdhcEVuZDtcclxuXHJcblx0XHRcdFx0dyA+IDAgJiYgcmVjdChjbGlwLCBwcmV2R2FwRW5kLCBwbG90VG9wLCB3LCBwbG90VG9wICsgcGxvdEhndCk7XHJcblxyXG5cdFx0XHRcdHByZXZHYXBFbmQgPSBnWzFdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHcgPSBwbG90TGZ0ICsgcGxvdFdpZCAtIHByZXZHYXBFbmQ7XHJcblxyXG5cdFx0Ly8gaGFjayB0byBlbnN1cmUgd2UgZXhwYW5kIHRoZSBjbGlwIGVub3VnaCB0byBhdm9pZCBjdXR0aW5nIG9mZiBzdHJva2VzIGF0IGVkZ2VzXHJcblx0XHRsZXQgbWF4U3Ryb2tlV2lkdGggPSAxMDtcclxuXHJcblx0XHR3ID4gMCAmJiByZWN0KGNsaXAsIHByZXZHYXBFbmQsIHBsb3RUb3AgLSBtYXhTdHJva2VXaWR0aCAvIDIsIHcsIHBsb3RUb3AgKyBwbG90SGd0ICsgbWF4U3Ryb2tlV2lkdGgpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNsaXA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZEdhcChnYXBzLCBmcm9tWCwgdG9YKSB7XHJcblx0bGV0IHByZXZHYXAgPSBnYXBzW2dhcHMubGVuZ3RoIC0gMV07XHJcblxyXG5cdGlmIChwcmV2R2FwICYmIHByZXZHYXBbMF0gPT0gZnJvbVgpXHRcdFx0Ly8gVE9ETzogZ2FwcyBtdXN0IGJlIGVuY29kZWQgYXQgc3Ryb2tlIHdpZHRocz9cclxuXHRcdHByZXZHYXBbMV0gPSB0b1g7XHJcblx0ZWxzZVxyXG5cdFx0Z2Fwcy5wdXNoKFtmcm9tWCwgdG9YXSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbmRHYXBzKHhzLCB5cywgaWR4MCwgaWR4MSwgZGlyLCBwaXhlbEZvclgsIGFsaWduKSB7XHJcblx0bGV0IGdhcHMgPSBbXTtcclxuXHRsZXQgbGVuID0geHMubGVuZ3RoO1xyXG5cclxuXHRmb3IgKGxldCBpID0gZGlyID09IDEgPyBpZHgwIDogaWR4MTsgaSA+PSBpZHgwICYmIGkgPD0gaWR4MTsgaSArPSBkaXIpIHtcclxuXHRcdGxldCB5VmFsID0geXNbaV07XHJcblxyXG5cdFx0aWYgKHlWYWwgPT09IG51bGwpIHtcclxuXHRcdFx0bGV0IGZyID0gaSwgdG8gPSBpO1xyXG5cclxuXHRcdFx0aWYgKGRpciA9PSAxKSB7XHJcblx0XHRcdFx0d2hpbGUgKCsraSA8PSBpZHgxICYmIHlzW2ldID09PSBudWxsKVxyXG5cdFx0XHRcdFx0dG8gPSBpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHdoaWxlICgtLWkgPj0gaWR4MCAmJiB5c1tpXSA9PT0gbnVsbClcclxuXHRcdFx0XHRcdHRvID0gaTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IGZyUHggPSBwaXhlbEZvclgoeHNbZnJdKTtcclxuXHRcdFx0bGV0IHRvUHggPSB0byA9PSBmciA/IGZyUHggOiBwaXhlbEZvclgoeHNbdG9dKTtcclxuXHJcblx0XHRcdC8vIGlmIHZhbHVlIGFkamFjZW50IHRvIGVkZ2UgbnVsbCBpcyBzYW1lIHBpeGVsLCB0aGVuIGl0J3MgcGFydGlhbGx5XHJcblx0XHRcdC8vIGZpbGxlZCBhbmQgZ2FwIHNob3VsZCBzdGFydCBhdCBuZXh0IHBpeGVsXHJcblx0XHRcdGxldCBmcmkyID0gZnIgLSBkaXI7XHJcblx0XHRcdGxldCBmclB4MiA9IGFsaWduIDw9IDAgJiYgZnJpMiA+PSAwICYmIGZyaTIgPCBsZW4gPyBwaXhlbEZvclgoeHNbZnJpMl0pIDogZnJQeDtcclxuXHRcdC8vXHRpZiAoZnJQeDIgPT0gZnJQeClcclxuXHRcdC8vXHRcdGZyUHgrKztcclxuXHRcdC8vXHRlbHNlXHJcblx0XHRcdFx0ZnJQeCA9IGZyUHgyO1xyXG5cclxuXHRcdFx0bGV0IHRvaTIgPSB0byArIGRpcjtcclxuXHRcdFx0bGV0IHRvUHgyID0gYWxpZ24gPj0gMCAmJiB0b2kyID49IDAgJiYgdG9pMiA8IGxlbiA/IHBpeGVsRm9yWCh4c1t0b2kyXSkgOiB0b1B4O1xyXG5cdFx0Ly9cdGlmICh0b1B4MiA9PSB0b1B4KVxyXG5cdFx0Ly9cdFx0dG9QeC0tO1xyXG5cdFx0Ly9cdGVsc2VcclxuXHRcdFx0XHR0b1B4ID0gdG9QeDI7XHJcblxyXG5cdFx0XHRpZiAodG9QeCA+PSBmclB4KVxyXG5cdFx0XHRcdGdhcHMucHVzaChbZnJQeCwgdG9QeF0pOyAvLyBhZGRHYXBcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBnYXBzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBweFJvdW5kR2VuKHB4QWxpZ24pIHtcclxuXHRyZXR1cm4gcHhBbGlnbiA9PSAwID8gcmV0QXJnMCA6IHB4QWxpZ24gPT0gMSA/IHJvdW5kIDogdiA9PiBpbmNyUm91bmQodiwgcHhBbGlnbik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlY3Qob3JpKSB7XHJcblx0bGV0IG1vdmVUbyA9IG9yaSA9PSAwID9cclxuXHRcdG1vdmVUb0ggOlxyXG5cdFx0bW92ZVRvVjtcclxuXHJcblx0bGV0IGFyY1RvID0gb3JpID09IDAgP1xyXG5cdFx0KHAsIHgxLCB5MSwgeDIsIHkyLCByKSA9PiB7IHAuYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHIpOyB9IDpcclxuXHRcdChwLCB5MSwgeDEsIHkyLCB4MiwgcikgPT4geyBwLmFyY1RvKHgxLCB5MSwgeDIsIHkyLCByKTsgfTtcclxuXHJcblx0bGV0IHJlY3QgPSBvcmkgPT0gMCA/XHJcblx0XHQocCwgeCwgeSwgdywgaCkgPT4geyBwLnJlY3QoeCwgeSwgdywgaCk7IH0gOlxyXG5cdFx0KHAsIHksIHgsIGgsIHcpID0+IHsgcC5yZWN0KHgsIHksIHcsIGgpOyB9O1xyXG5cclxuXHQvLyBUT0RPIChwZW5kaW5nIGJldHRlciBicm93c2VyIHN1cHBvcnQpOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL3JvdW5kUmVjdFxyXG5cdHJldHVybiAocCwgeCwgeSwgdywgaCwgZW5kUmFkID0gMCwgYmFzZVJhZCA9IDApID0+IHtcclxuXHRcdGlmIChlbmRSYWQgPT0gMCAmJiBiYXNlUmFkID09IDApXHJcblx0XHRcdHJlY3QocCwgeCwgeSwgdywgaCk7XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0ZW5kUmFkICA9IG1pbihlbmRSYWQsICB3IC8gMiwgaCAvIDIpO1xyXG5cdFx0XHRiYXNlUmFkID0gbWluKGJhc2VSYWQsIHcgLyAyLCBoIC8gMik7XHJcblxyXG5cdFx0XHQvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI1NTUxMi9ob3ctdG8tZHJhdy1hLXJvdW5kZWQtcmVjdGFuZ2xlLXVzaW5nLWh0bWwtY2FudmFzLzc4Mzg4NzEjNzgzODg3MVxyXG5cdFx0XHRtb3ZlVG8ocCwgeCArIGVuZFJhZCwgeSk7XHJcblx0XHRcdGFyY1RvKHAsIHggKyB3LCB5LCB4ICsgdywgeSArIGgsIGVuZFJhZCk7XHJcblx0XHRcdGFyY1RvKHAsIHggKyB3LCB5ICsgaCwgeCwgeSArIGgsIGJhc2VSYWQpO1xyXG5cdFx0XHRhcmNUbyhwLCB4LCB5ICsgaCwgeCwgeSwgYmFzZVJhZCk7XHJcblx0XHRcdGFyY1RvKHAsIHgsIHksIHggKyB3LCB5LCBlbmRSYWQpO1xyXG5cdFx0XHRwLmNsb3NlUGF0aCgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbi8vIG9yaWVudGF0aW9uLWludmVydGluZyBjYW52YXMgZnVuY3Rpb25zXHJcbmNvbnN0IG1vdmVUb0ggPSAocCwgeCwgeSkgPT4geyBwLm1vdmVUbyh4LCB5KTsgfTtcclxuY29uc3QgbW92ZVRvViA9IChwLCB5LCB4KSA9PiB7IHAubW92ZVRvKHgsIHkpOyB9O1xyXG5jb25zdCBsaW5lVG9IID0gKHAsIHgsIHkpID0+IHsgcC5saW5lVG8oeCwgeSk7IH07XHJcbmNvbnN0IGxpbmVUb1YgPSAocCwgeSwgeCkgPT4geyBwLmxpbmVUbyh4LCB5KTsgfTtcclxuY29uc3QgcmVjdEggPSByZWN0KDApO1xyXG5jb25zdCByZWN0ViA9IHJlY3QoMSk7XHJcbmNvbnN0IGFyY0ggPSAocCwgeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpID0+IHsgcC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpOyB9O1xyXG5jb25zdCBhcmNWID0gKHAsIHksIHgsIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSA9PiB7IHAuYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTsgfTtcclxuY29uc3QgYmV6aWVyQ3VydmVUb0ggPSAocCwgYnAxeCwgYnAxeSwgYnAyeCwgYnAyeSwgcDJ4LCBwMnkpID0+IHsgcC5iZXppZXJDdXJ2ZVRvKGJwMXgsIGJwMXksIGJwMngsIGJwMnksIHAyeCwgcDJ5KTsgfTtcclxuY29uc3QgYmV6aWVyQ3VydmVUb1YgPSAocCwgYnAxeSwgYnAxeCwgYnAyeSwgYnAyeCwgcDJ5LCBwMngpID0+IHsgcC5iZXppZXJDdXJ2ZVRvKGJwMXgsIGJwMXksIGJwMngsIGJwMnksIHAyeCwgcDJ5KTsgfTtcclxuXHJcbi8vIFRPRE86IGRyYXdXcmFwKHNlcmllc0lkeCwgZHJhd1BvaW50cykgKHNhdmUsIHJlc3RvcmUsIHRyYW5zbGF0ZSwgY2xpcClcclxuZnVuY3Rpb24gcG9pbnRzKG9wdHMpIHtcclxuXHRyZXR1cm4gKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgZmlsdElkeHMpID0+IHtcclxuXHQvL1x0bG9nKFwiZHJhd1BvaW50cygpXCIsIGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0cmV0dXJuIG9yaWVudCh1LCBzZXJpZXNJZHgsIChzZXJpZXMsIGRhdGFYLCBkYXRhWSwgc2NhbGVYLCBzY2FsZVksIHZhbFRvUG9zWCwgdmFsVG9Qb3NZLCB4T2ZmLCB5T2ZmLCB4RGltLCB5RGltKSA9PiB7XHJcblx0XHRcdGxldCB7IHB4Um91bmQsIHBvaW50cyB9ID0gc2VyaWVzO1xyXG5cclxuXHRcdFx0bGV0IG1vdmVUbywgYXJjO1xyXG5cclxuXHRcdFx0aWYgKHNjYWxlWC5vcmkgPT0gMCkge1xyXG5cdFx0XHRcdG1vdmVUbyA9IG1vdmVUb0g7XHJcblx0XHRcdFx0YXJjID0gYXJjSDtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRtb3ZlVG8gPSBtb3ZlVG9WO1xyXG5cdFx0XHRcdGFyYyA9IGFyY1Y7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHdpZHRoID0gcm91bmREZWMocG9pbnRzLndpZHRoICogcHhSYXRpbywgMyk7XHJcblxyXG5cdFx0XHRsZXQgcmFkID0gKHBvaW50cy5zaXplIC0gcG9pbnRzLndpZHRoKSAvIDIgKiBweFJhdGlvO1xyXG5cdFx0XHRsZXQgZGlhID0gcm91bmREZWMocmFkICogMiwgMyk7XHJcblxyXG5cdFx0XHRsZXQgZmlsbCA9IG5ldyBQYXRoMkQoKTtcclxuXHRcdFx0bGV0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XHJcblxyXG5cdFx0XHRsZXQgeyBsZWZ0OiBsZnQsIHRvcDogdG9wLCB3aWR0aDogd2lkLCBoZWlnaHQ6IGhndCB9ID0gdS5iYm94O1xyXG5cclxuXHRcdFx0cmVjdEgoY2xpcCxcclxuXHRcdFx0XHRsZnQgLSBkaWEsXHJcblx0XHRcdFx0dG9wIC0gZGlhLFxyXG5cdFx0XHRcdHdpZCArIGRpYSAqIDIsXHJcblx0XHRcdFx0aGd0ICsgZGlhICogMixcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGNvbnN0IGRyYXdQb2ludCA9IHBpID0+IHtcclxuXHRcdFx0XHRpZiAoZGF0YVlbcGldICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGxldCB4ID0gcHhSb3VuZCh2YWxUb1Bvc1goZGF0YVhbcGldLCBzY2FsZVgsIHhEaW0sIHhPZmYpKTtcclxuXHRcdFx0XHRcdGxldCB5ID0gcHhSb3VuZCh2YWxUb1Bvc1koZGF0YVlbcGldLCBzY2FsZVksIHlEaW0sIHlPZmYpKTtcclxuXHJcblx0XHRcdFx0XHRtb3ZlVG8oZmlsbCwgeCArIHJhZCwgeSk7XHJcblx0XHRcdFx0XHRhcmMoZmlsbCwgeCwgeSwgcmFkLCAwLCBQSSAqIDIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGlmIChmaWx0SWR4cylcclxuXHRcdFx0XHRmaWx0SWR4cy5mb3JFYWNoKGRyYXdQb2ludCk7XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGZvciAobGV0IHBpID0gaWR4MDsgcGkgPD0gaWR4MTsgcGkrKylcclxuXHRcdFx0XHRcdGRyYXdQb2ludChwaSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0c3Ryb2tlOiB3aWR0aCA+IDAgPyBmaWxsIDogbnVsbCxcclxuXHRcdFx0XHRmaWxsLFxyXG5cdFx0XHRcdGNsaXAsXHJcblx0XHRcdFx0ZmxhZ3M6IEJBTkRfQ0xJUF9GSUxMIHwgQkFORF9DTElQX1NUUk9LRSxcclxuXHRcdFx0fTtcclxuXHRcdH0pO1xyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9kcmF3QWNjKGxpbmVUbykge1xyXG5cdHJldHVybiAoc3Ryb2tlLCBhY2NYLCBtaW5ZLCBtYXhZLCBpblksIG91dFkpID0+IHtcclxuXHRcdGlmIChtaW5ZICE9IG1heFkpIHtcclxuXHRcdFx0aWYgKGluWSAhPSBtaW5ZICYmIG91dFkgIT0gbWluWSlcclxuXHRcdFx0XHRsaW5lVG8oc3Ryb2tlLCBhY2NYLCBtaW5ZKTtcclxuXHRcdFx0aWYgKGluWSAhPSBtYXhZICYmIG91dFkgIT0gbWF4WSlcclxuXHRcdFx0XHRsaW5lVG8oc3Ryb2tlLCBhY2NYLCBtYXhZKTtcclxuXHJcblx0XHRcdGxpbmVUbyhzdHJva2UsIGFjY1gsIG91dFkpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmNvbnN0IGRyYXdBY2NIID0gX2RyYXdBY2MobGluZVRvSCk7XHJcbmNvbnN0IGRyYXdBY2NWID0gX2RyYXdBY2MobGluZVRvVik7XHJcblxyXG5mdW5jdGlvbiBsaW5lYXIob3B0cykge1xyXG5cdGNvbnN0IGFsaWduR2FwcyA9IGlmTnVsbChvcHRzPy5hbGlnbkdhcHMsIDApO1xyXG5cclxuXHRyZXR1cm4gKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSkgPT4ge1xyXG5cdFx0cmV0dXJuIG9yaWVudCh1LCBzZXJpZXNJZHgsIChzZXJpZXMsIGRhdGFYLCBkYXRhWSwgc2NhbGVYLCBzY2FsZVksIHZhbFRvUG9zWCwgdmFsVG9Qb3NZLCB4T2ZmLCB5T2ZmLCB4RGltLCB5RGltKSA9PiB7XHJcblx0XHRcdGxldCBweFJvdW5kID0gc2VyaWVzLnB4Um91bmQ7XHJcblxyXG5cdFx0XHRsZXQgcGl4ZWxGb3JYID0gdmFsID0+IHB4Um91bmQodmFsVG9Qb3NYKHZhbCwgc2NhbGVYLCB4RGltLCB4T2ZmKSk7XHJcblx0XHRcdGxldCBwaXhlbEZvclkgPSB2YWwgPT4gcHhSb3VuZCh2YWxUb1Bvc1kodmFsLCBzY2FsZVksIHlEaW0sIHlPZmYpKTtcclxuXHJcblx0XHRcdGxldCBsaW5lVG8sIGRyYXdBY2M7XHJcblxyXG5cdFx0XHRpZiAoc2NhbGVYLm9yaSA9PSAwKSB7XHJcblx0XHRcdFx0bGluZVRvID0gbGluZVRvSDtcclxuXHRcdFx0XHRkcmF3QWNjID0gZHJhd0FjY0g7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0bGluZVRvID0gbGluZVRvVjtcclxuXHRcdFx0XHRkcmF3QWNjID0gZHJhd0FjY1Y7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IGRpciA9IHNjYWxlWC5kaXIgKiAoc2NhbGVYLm9yaSA9PSAwID8gMSA6IC0xKTtcclxuXHJcblx0XHRcdGNvbnN0IF9wYXRocyA9IHtzdHJva2U6IG5ldyBQYXRoMkQoKSwgZmlsbDogbnVsbCwgY2xpcDogbnVsbCwgYmFuZDogbnVsbCwgZ2FwczogbnVsbCwgZmxhZ3M6IEJBTkRfQ0xJUF9GSUxMfTtcclxuXHRcdFx0Y29uc3Qgc3Ryb2tlID0gX3BhdGhzLnN0cm9rZTtcclxuXHJcblx0XHRcdGxldCBtaW5ZID0gaW5mLFxyXG5cdFx0XHRcdG1heFkgPSAtaW5mLFxyXG5cdFx0XHRcdGluWSwgb3V0WSwgZHJhd25BdFg7XHJcblxyXG5cdFx0XHRsZXQgYWNjWCA9IHBpeGVsRm9yWChkYXRhWFtkaXIgPT0gMSA/IGlkeDAgOiBpZHgxXSk7XHJcblxyXG5cdFx0XHQvLyBkYXRhIGVkZ2VzXHJcblx0XHRcdGxldCBsZnRJZHggPSBub25OdWxsSWR4KGRhdGFZLCBpZHgwLCBpZHgxLCAgMSAqIGRpcik7XHJcblx0XHRcdGxldCByZ3RJZHggPSBub25OdWxsSWR4KGRhdGFZLCBpZHgwLCBpZHgxLCAtMSAqIGRpcik7XHJcblx0XHRcdGxldCBsZnRYICAgPSAgcGl4ZWxGb3JYKGRhdGFYW2xmdElkeF0pO1xyXG5cdFx0XHRsZXQgcmd0WCAgID0gIHBpeGVsRm9yWChkYXRhWFtyZ3RJZHhdKTtcclxuXHJcblx0XHRcdGxldCBoYXNHYXAgPSBmYWxzZTtcclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSBkaXIgPT0gMSA/IGlkeDAgOiBpZHgxOyBpID49IGlkeDAgJiYgaSA8PSBpZHgxOyBpICs9IGRpcikge1xyXG5cdFx0XHRcdGxldCB4ID0gcGl4ZWxGb3JYKGRhdGFYW2ldKTtcclxuXHRcdFx0XHRsZXQgeVZhbCA9IGRhdGFZW2ldO1xyXG5cclxuXHRcdFx0XHRpZiAoeCA9PSBhY2NYKSB7XHJcblx0XHRcdFx0XHRpZiAoeVZhbCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdG91dFkgPSBwaXhlbEZvclkoeVZhbCk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAobWluWSA9PSBpbmYpIHtcclxuXHRcdFx0XHRcdFx0XHRsaW5lVG8oc3Ryb2tlLCB4LCBvdXRZKTtcclxuXHRcdFx0XHRcdFx0XHRpblkgPSBvdXRZO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRtaW5ZID0gbWluKG91dFksIG1pblkpO1xyXG5cdFx0XHRcdFx0XHRtYXhZID0gbWF4KG91dFksIG1heFkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdGlmICh5VmFsID09PSBudWxsKVxyXG5cdFx0XHRcdFx0XHRcdGhhc0dhcCA9IHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKG1pblkgIT0gaW5mKSB7XHJcblx0XHRcdFx0XHRcdGRyYXdBY2Moc3Ryb2tlLCBhY2NYLCBtaW5ZLCBtYXhZLCBpblksIG91dFkpO1xyXG5cdFx0XHRcdFx0XHRkcmF3bkF0WCA9IGFjY1g7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHlWYWwgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRvdXRZID0gcGl4ZWxGb3JZKHlWYWwpO1xyXG5cdFx0XHRcdFx0XHRsaW5lVG8oc3Ryb2tlLCB4LCBvdXRZKTtcclxuXHRcdFx0XHRcdFx0bWluWSA9IG1heFkgPSBpblkgPSBvdXRZO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdG1pblkgPSBpbmY7XHJcblx0XHRcdFx0XHRcdG1heFkgPSAtaW5mO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKHlWYWwgPT09IG51bGwpXHJcblx0XHRcdFx0XHRcdFx0aGFzR2FwID0gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRhY2NYID0geDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChtaW5ZICE9IGluZiAmJiBtaW5ZICE9IG1heFkgJiYgZHJhd25BdFggIT0gYWNjWClcclxuXHRcdFx0XHRkcmF3QWNjKHN0cm9rZSwgYWNjWCwgbWluWSwgbWF4WSwgaW5ZLCBvdXRZKTtcclxuXHJcblx0XHRcdGxldCBbIGJhbmRGaWxsRGlyLCBiYW5kQ2xpcERpciBdID0gYmFuZEZpbGxDbGlwRGlycyh1LCBzZXJpZXNJZHgpO1xyXG5cclxuXHRcdFx0aWYgKHNlcmllcy5maWxsICE9IG51bGwgfHwgYmFuZEZpbGxEaXIgIT0gMCkge1xyXG5cdFx0XHRcdGxldCBmaWxsID0gX3BhdGhzLmZpbGwgPSBuZXcgUGF0aDJEKHN0cm9rZSk7XHJcblxyXG5cdFx0XHRcdGxldCBmaWxsVG9WYWwgPSBzZXJpZXMuZmlsbFRvKHUsIHNlcmllc0lkeCwgc2VyaWVzLm1pbiwgc2VyaWVzLm1heCwgYmFuZEZpbGxEaXIpO1xyXG5cdFx0XHRcdGxldCBmaWxsVG9ZID0gcGl4ZWxGb3JZKGZpbGxUb1ZhbCk7XHJcblxyXG5cdFx0XHRcdGxpbmVUbyhmaWxsLCByZ3RYLCBmaWxsVG9ZKTtcclxuXHRcdFx0XHRsaW5lVG8oZmlsbCwgbGZ0WCwgZmlsbFRvWSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghc2VyaWVzLnNwYW5HYXBzKSB7XHJcblx0XHRcdC8vXHRjb25zb2xlLnRpbWUoJ2dhcHMnKTtcclxuXHRcdFx0XHRsZXQgZ2FwcyA9IFtdO1xyXG5cclxuXHRcdFx0XHRoYXNHYXAgJiYgZ2Fwcy5wdXNoKC4uLmZpbmRHYXBzKGRhdGFYLCBkYXRhWSwgaWR4MCwgaWR4MSwgZGlyLCBwaXhlbEZvclgsIGFsaWduR2FwcykpO1xyXG5cclxuXHRcdFx0Ly9cdGNvbnNvbGUudGltZUVuZCgnZ2FwcycpO1xyXG5cclxuXHRcdFx0Ly9cdGNvbnNvbGUubG9nKCdnYXBzJywgSlNPTi5zdHJpbmdpZnkoZ2FwcykpO1xyXG5cclxuXHRcdFx0XHRfcGF0aHMuZ2FwcyA9IGdhcHMgPSBzZXJpZXMuZ2Fwcyh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEsIGdhcHMpO1xyXG5cclxuXHRcdFx0XHRfcGF0aHMuY2xpcCA9IGNsaXBHYXBzKGdhcHMsIHNjYWxlWC5vcmksIHhPZmYsIHlPZmYsIHhEaW0sIHlEaW0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoYmFuZENsaXBEaXIgIT0gMCkge1xyXG5cdFx0XHRcdF9wYXRocy5iYW5kID0gYmFuZENsaXBEaXIgPT0gMiA/IFtcclxuXHRcdFx0XHRcdGNsaXBCYW5kTGluZSh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEsIHN0cm9rZSwgLTEpLFxyXG5cdFx0XHRcdFx0Y2xpcEJhbmRMaW5lKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSwgc3Ryb2tlLCAgMSksXHJcblx0XHRcdFx0XSA6IGNsaXBCYW5kTGluZSh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEsIHN0cm9rZSwgYmFuZENsaXBEaXIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gX3BhdGhzO1xyXG5cdFx0fSk7XHJcblx0fTtcclxufVxyXG5cclxuLy8gQlVHOiBhbGlnbjogLTEgYmVoYXZlcyBsaWtlIGFsaWduOiAxIHdoZW4gc2NhbGUuZGlyOiAtMVxyXG5mdW5jdGlvbiBzdGVwcGVkKG9wdHMpIHtcclxuXHRjb25zdCBhbGlnbiA9IGlmTnVsbChvcHRzLmFsaWduLCAxKTtcclxuXHQvLyB3aGV0aGVyIHRvIGRyYXcgYXNjZW5kZXJzL2Rlc2NlbmRlcnMgYXQgbnVsbC9nYXAgYm9uZGFyaWVzXHJcblx0Y29uc3QgYXNjRGVzYyA9IGlmTnVsbChvcHRzLmFzY0Rlc2MsIGZhbHNlKTtcclxuXHRjb25zdCBhbGlnbkdhcHMgPSBpZk51bGwob3B0cy5hbGlnbkdhcHMsIDApO1xyXG5cdGNvbnN0IGV4dGVuZCA9IGlmTnVsbChvcHRzLmV4dGVuZCwgZmFsc2UpO1xyXG5cclxuXHRyZXR1cm4gKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSkgPT4ge1xyXG5cdFx0cmV0dXJuIG9yaWVudCh1LCBzZXJpZXNJZHgsIChzZXJpZXMsIGRhdGFYLCBkYXRhWSwgc2NhbGVYLCBzY2FsZVksIHZhbFRvUG9zWCwgdmFsVG9Qb3NZLCB4T2ZmLCB5T2ZmLCB4RGltLCB5RGltKSA9PiB7XHJcblx0XHRcdGxldCBweFJvdW5kID0gc2VyaWVzLnB4Um91bmQ7XHJcblxyXG5cdFx0XHRsZXQgeyBsZWZ0LCB3aWR0aCB9ID0gdS5iYm94O1xyXG5cclxuXHRcdFx0bGV0IHBpeGVsRm9yWCA9IHZhbCA9PiBweFJvdW5kKHZhbFRvUG9zWCh2YWwsIHNjYWxlWCwgeERpbSwgeE9mZikpO1xyXG5cdFx0XHRsZXQgcGl4ZWxGb3JZID0gdmFsID0+IHB4Um91bmQodmFsVG9Qb3NZKHZhbCwgc2NhbGVZLCB5RGltLCB5T2ZmKSk7XHJcblxyXG5cdFx0XHRsZXQgbGluZVRvID0gc2NhbGVYLm9yaSA9PSAwID8gbGluZVRvSCA6IGxpbmVUb1Y7XHJcblxyXG5cdFx0XHRjb25zdCBfcGF0aHMgPSB7c3Ryb2tlOiBuZXcgUGF0aDJEKCksIGZpbGw6IG51bGwsIGNsaXA6IG51bGwsIGJhbmQ6IG51bGwsIGdhcHM6IG51bGwsIGZsYWdzOiBCQU5EX0NMSVBfRklMTH07XHJcblx0XHRcdGNvbnN0IHN0cm9rZSA9IF9wYXRocy5zdHJva2U7XHJcblxyXG5cdFx0XHRjb25zdCBkaXIgPSBzY2FsZVguZGlyICogKHNjYWxlWC5vcmkgPT0gMCA/IDEgOiAtMSk7XHJcblxyXG5cdFx0XHRpZHgwID0gbm9uTnVsbElkeChkYXRhWSwgaWR4MCwgaWR4MSwgIDEpO1xyXG5cdFx0XHRpZHgxID0gbm9uTnVsbElkeChkYXRhWSwgaWR4MCwgaWR4MSwgLTEpO1xyXG5cclxuXHRcdFx0bGV0IHByZXZZUG9zICA9IHBpeGVsRm9yWShkYXRhWVtkaXIgPT0gMSA/IGlkeDAgOiBpZHgxXSk7XHJcblx0XHRcdGxldCBmaXJzdFhQb3MgPSBwaXhlbEZvclgoZGF0YVhbZGlyID09IDEgPyBpZHgwIDogaWR4MV0pO1xyXG5cdFx0XHRsZXQgcHJldlhQb3MgPSBmaXJzdFhQb3M7XHJcblxyXG5cdFx0XHRsZXQgZmlyc3RYUG9zRXh0ID0gZmlyc3RYUG9zO1xyXG5cclxuXHRcdFx0aWYgKGV4dGVuZCAmJiBhbGlnbiA9PSAtMSkge1xyXG5cdFx0XHRcdGZpcnN0WFBvc0V4dCA9IGxlZnQ7XHJcblx0XHRcdFx0bGluZVRvKHN0cm9rZSwgZmlyc3RYUG9zRXh0LCBwcmV2WVBvcyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxpbmVUbyhzdHJva2UsIGZpcnN0WFBvcywgcHJldllQb3MpO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IGRpciA9PSAxID8gaWR4MCA6IGlkeDE7IGkgPj0gaWR4MCAmJiBpIDw9IGlkeDE7IGkgKz0gZGlyKSB7XHJcblx0XHRcdFx0bGV0IHlWYWwxID0gZGF0YVlbaV07XHJcblxyXG5cdFx0XHRcdGlmICh5VmFsMSA9PSBudWxsKVxyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdGxldCB4MSA9IHBpeGVsRm9yWChkYXRhWFtpXSk7XHJcblx0XHRcdFx0bGV0IHkxID0gcGl4ZWxGb3JZKHlWYWwxKTtcclxuXHJcblx0XHRcdFx0aWYgKGFsaWduID09IDEpXHJcblx0XHRcdFx0XHRsaW5lVG8oc3Ryb2tlLCB4MSwgcHJldllQb3MpO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdGxpbmVUbyhzdHJva2UsIHByZXZYUG9zLCB5MSk7XHJcblxyXG5cdFx0XHRcdGxpbmVUbyhzdHJva2UsIHgxLCB5MSk7XHJcblxyXG5cdFx0XHRcdHByZXZZUG9zID0geTE7XHJcblx0XHRcdFx0cHJldlhQb3MgPSB4MTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IHByZXZYUG9zRXh0ID0gcHJldlhQb3M7XHJcblxyXG5cdFx0XHRpZiAoZXh0ZW5kICYmIGFsaWduID09IDEpIHtcclxuXHRcdFx0XHRwcmV2WFBvc0V4dCA9IGxlZnQgKyB3aWR0aDtcclxuXHRcdFx0XHRsaW5lVG8oc3Ryb2tlLCBwcmV2WFBvc0V4dCwgcHJldllQb3MpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgWyBiYW5kRmlsbERpciwgYmFuZENsaXBEaXIgXSA9IGJhbmRGaWxsQ2xpcERpcnModSwgc2VyaWVzSWR4KTtcclxuXHJcblx0XHRcdGlmIChzZXJpZXMuZmlsbCAhPSBudWxsIHx8IGJhbmRGaWxsRGlyICE9IDApIHtcclxuXHRcdFx0XHRsZXQgZmlsbCA9IF9wYXRocy5maWxsID0gbmV3IFBhdGgyRChzdHJva2UpO1xyXG5cclxuXHRcdFx0XHRsZXQgZmlsbFRvID0gc2VyaWVzLmZpbGxUbyh1LCBzZXJpZXNJZHgsIHNlcmllcy5taW4sIHNlcmllcy5tYXgsIGJhbmRGaWxsRGlyKTtcclxuXHRcdFx0XHRsZXQgZmlsbFRvWSA9IHBpeGVsRm9yWShmaWxsVG8pO1xyXG5cclxuXHRcdFx0XHRsaW5lVG8oZmlsbCwgcHJldlhQb3NFeHQsIGZpbGxUb1kpO1xyXG5cdFx0XHRcdGxpbmVUbyhmaWxsLCBmaXJzdFhQb3NFeHQsIGZpbGxUb1kpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIXNlcmllcy5zcGFuR2Fwcykge1xyXG5cdFx0XHQvL1x0Y29uc29sZS50aW1lKCdnYXBzJyk7XHJcblx0XHRcdFx0bGV0IGdhcHMgPSBbXTtcclxuXHJcblx0XHRcdFx0Z2Fwcy5wdXNoKC4uLmZpbmRHYXBzKGRhdGFYLCBkYXRhWSwgaWR4MCwgaWR4MSwgZGlyLCBwaXhlbEZvclgsIGFsaWduR2FwcykpO1xyXG5cclxuXHRcdFx0Ly9cdGNvbnNvbGUudGltZUVuZCgnZ2FwcycpO1xyXG5cclxuXHRcdFx0Ly9cdGNvbnNvbGUubG9nKCdnYXBzJywgSlNPTi5zdHJpbmdpZnkoZ2FwcykpO1xyXG5cclxuXHRcdFx0XHQvLyBleHBhbmQvY29udHJhY3QgY2xpcHMgZm9yIGFzY2VuZGVycy9kZXNjZW5kZXJzXHJcblx0XHRcdFx0bGV0IGhhbGZTdHJva2UgPSAoc2VyaWVzLndpZHRoICogcHhSYXRpbykgLyAyO1xyXG5cdFx0XHRcdGxldCBzdGFydHNPZmZzZXQgPSAoYXNjRGVzYyB8fCBhbGlnbiA9PSAgMSkgPyAgaGFsZlN0cm9rZSA6IC1oYWxmU3Ryb2tlO1xyXG5cdFx0XHRcdGxldCBlbmRzT2Zmc2V0ICAgPSAoYXNjRGVzYyB8fCBhbGlnbiA9PSAtMSkgPyAtaGFsZlN0cm9rZSA6ICBoYWxmU3Ryb2tlO1xyXG5cclxuXHRcdFx0XHRnYXBzLmZvckVhY2goZyA9PiB7XHJcblx0XHRcdFx0XHRnWzBdICs9IHN0YXJ0c09mZnNldDtcclxuXHRcdFx0XHRcdGdbMV0gKz0gZW5kc09mZnNldDtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0X3BhdGhzLmdhcHMgPSBnYXBzID0gc2VyaWVzLmdhcHModSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBnYXBzKTtcclxuXHJcblx0XHRcdFx0X3BhdGhzLmNsaXAgPSBjbGlwR2FwcyhnYXBzLCBzY2FsZVgub3JpLCB4T2ZmLCB5T2ZmLCB4RGltLCB5RGltKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGJhbmRDbGlwRGlyICE9IDApIHtcclxuXHRcdFx0XHRfcGF0aHMuYmFuZCA9IGJhbmRDbGlwRGlyID09IDIgPyBbXHJcblx0XHRcdFx0XHRjbGlwQmFuZExpbmUodSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBzdHJva2UsIC0xKSxcclxuXHRcdFx0XHRcdGNsaXBCYW5kTGluZSh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEsIHN0cm9rZSwgIDEpLFxyXG5cdFx0XHRcdF0gOiBjbGlwQmFuZExpbmUodSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBzdHJva2UsIGJhbmRDbGlwRGlyKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIF9wYXRocztcclxuXHRcdH0pO1xyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJhcnMob3B0cykge1xyXG5cdG9wdHMgPSBvcHRzIHx8IEVNUFRZX09CSjtcclxuXHRjb25zdCBzaXplID0gaWZOdWxsKG9wdHMuc2l6ZSwgWzAuNiwgaW5mLCAxXSk7XHJcblx0Y29uc3QgYWxpZ24gPSBvcHRzLmFsaWduIHx8IDA7XHJcblx0Y29uc3QgZXh0cmFHYXAgPSAob3B0cy5nYXAgfHwgMCkgKiBweFJhdGlvO1xyXG5cclxuXHRsZXQgcm8gPSBvcHRzLnJhZGl1cztcclxuXHJcblx0cm8gPVxyXG5cdFx0Ly8gW3ZhbHVlUmFkaXVzLCBiYXNlbGluZVJhZGl1c11cclxuXHRcdHJvID09IG51bGwgPyBbMCwgMF0gOlxyXG5cdFx0dHlwZW9mIHJvID09ICdudW1iZXInID8gW3JvLCAwXSA6IHJvO1xyXG5cclxuXHRjb25zdCByYWRpdXNGbiA9IGZuT3JTZWxmKHJvKTtcclxuXHJcblx0Y29uc3QgZ2FwRmFjdG9yID0gMSAtIHNpemVbMF07XHJcblx0Y29uc3QgbWF4V2lkdGggID0gaWZOdWxsKHNpemVbMV0sIGluZikgKiBweFJhdGlvO1xyXG5cdGNvbnN0IG1pbldpZHRoICA9IGlmTnVsbChzaXplWzJdLCAxKSAqIHB4UmF0aW87XHJcblxyXG5cdGNvbnN0IGRpc3AgPSBpZk51bGwob3B0cy5kaXNwLCBFTVBUWV9PQkopO1xyXG5cdGNvbnN0IF9lYWNoID0gaWZOdWxsKG9wdHMuZWFjaCwgXyA9PiB7fSk7XHJcblxyXG5cdGNvbnN0IHsgZmlsbDogZGlzcEZpbGxzLCBzdHJva2U6IGRpc3BTdHJva2VzIH0gPSBkaXNwO1xyXG5cclxuXHRyZXR1cm4gKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSkgPT4ge1xyXG5cdFx0cmV0dXJuIG9yaWVudCh1LCBzZXJpZXNJZHgsIChzZXJpZXMsIGRhdGFYLCBkYXRhWSwgc2NhbGVYLCBzY2FsZVksIHZhbFRvUG9zWCwgdmFsVG9Qb3NZLCB4T2ZmLCB5T2ZmLCB4RGltLCB5RGltKSA9PiB7XHJcblx0XHRcdGxldCBweFJvdW5kID0gc2VyaWVzLnB4Um91bmQ7XHJcblxyXG5cdFx0XHRsZXQgdmFsUmFkaXVzLCBiYXNlUmFkaXVzO1xyXG5cclxuXHRcdFx0aWYgKHNjYWxlWC5vcmkgPT0gMClcclxuXHRcdFx0XHRbdmFsUmFkaXVzLCBiYXNlUmFkaXVzXSA9IHJhZGl1c0ZuKHUsIHNlcmllc0lkeCk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRbYmFzZVJhZGl1cywgdmFsUmFkaXVzXSA9IHJhZGl1c0ZuKHUsIHNlcmllc0lkeCk7XHJcblxyXG5cdFx0XHRjb25zdCBfZGlyWCA9IHNjYWxlWC5kaXIgKiAoc2NhbGVYLm9yaSA9PSAwID8gMSA6IC0xKTtcclxuXHRcdFx0Y29uc3QgX2RpclkgPSBzY2FsZVkuZGlyICogKHNjYWxlWS5vcmkgPT0gMSA/IDEgOiAtMSk7XHJcblxyXG5cdFx0XHRsZXQgcmVjdCA9IHNjYWxlWC5vcmkgPT0gMCA/IHJlY3RIIDogcmVjdFY7XHJcblxyXG5cdFx0XHRsZXQgZWFjaCA9IHNjYWxlWC5vcmkgPT0gMCA/IF9lYWNoIDogKHUsIHNlcmllc0lkeCwgaSwgdG9wLCBsZnQsIGhndCwgd2lkKSA9PiB7XHJcblx0XHRcdFx0X2VhY2godSwgc2VyaWVzSWR4LCBpLCBsZnQsIHRvcCwgd2lkLCBoZ3QpO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0bGV0IFsgYmFuZEZpbGxEaXIsIGJhbmRDbGlwRGlyIF0gPSBiYW5kRmlsbENsaXBEaXJzKHUsIHNlcmllc0lkeCk7XHJcblxyXG5cdFx0Ly9cdGxldCBmaWxsVG9ZID0gc2VyaWVzLmZpbGxUbyh1LCBzZXJpZXNJZHgsIHNlcmllcy5taW4sIHNlcmllcy5tYXgsIGJhbmRGaWxsRGlyKTtcclxuXHRcdFx0bGV0IGZpbGxUb1kgPSBzY2FsZVkuZGlzdHIgPT0gMyA/IChiYW5kRmlsbERpciA9PSAxID8gc2NhbGVZLm1heCA6IHNjYWxlWS5taW4pIDogMDtcclxuXHJcblx0XHRcdGxldCB5MFBvcyA9IHZhbFRvUG9zWShmaWxsVG9ZLCBzY2FsZVksIHlEaW0sIHlPZmYpO1xyXG5cclxuXHRcdFx0Ly8gYmFyV2lkIGlzIHRvIGNlbnRlciBvZiBzdHJva2VcclxuXHRcdFx0bGV0IHhTaGlmdCwgYmFyV2lkO1xyXG5cclxuXHRcdFx0bGV0IHN0cm9rZVdpZHRoID0gcHhSb3VuZChzZXJpZXMud2lkdGggKiBweFJhdGlvKTtcclxuXHJcblx0XHRcdGxldCBtdWx0aVBhdGggPSBmYWxzZTtcclxuXHJcblx0XHRcdGxldCBmaWxsQ29sb3JzID0gbnVsbDtcclxuXHRcdFx0bGV0IGZpbGxQYXRocyA9IG51bGw7XHJcblx0XHRcdGxldCBzdHJva2VDb2xvcnMgPSBudWxsO1xyXG5cdFx0XHRsZXQgc3Ryb2tlUGF0aHMgPSBudWxsO1xyXG5cclxuXHRcdFx0aWYgKGRpc3BGaWxscyAhPSBudWxsICYmIChzdHJva2VXaWR0aCA9PSAwIHx8IGRpc3BTdHJva2VzICE9IG51bGwpKSB7XHJcblx0XHRcdFx0bXVsdGlQYXRoID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0ZmlsbENvbG9ycyA9IGRpc3BGaWxscy52YWx1ZXModSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxKTtcclxuXHRcdFx0XHRmaWxsUGF0aHMgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0KG5ldyBTZXQoZmlsbENvbG9ycykpLmZvckVhY2goY29sb3IgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKGNvbG9yICE9IG51bGwpXHJcblx0XHRcdFx0XHRcdGZpbGxQYXRocy5zZXQoY29sb3IsIG5ldyBQYXRoMkQoKSk7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGlmIChzdHJva2VXaWR0aCA+IDApIHtcclxuXHRcdFx0XHRcdHN0cm9rZUNvbG9ycyA9IGRpc3BTdHJva2VzLnZhbHVlcyh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEpO1xyXG5cdFx0XHRcdFx0c3Ryb2tlUGF0aHMgPSBuZXcgTWFwKCk7XHJcblx0XHRcdFx0XHQobmV3IFNldChzdHJva2VDb2xvcnMpKS5mb3JFYWNoKGNvbG9yID0+IHtcclxuXHRcdFx0XHRcdFx0aWYgKGNvbG9yICE9IG51bGwpXHJcblx0XHRcdFx0XHRcdFx0c3Ryb2tlUGF0aHMuc2V0KGNvbG9yLCBuZXcgUGF0aDJEKCkpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgeyB4MCwgc2l6ZSB9ID0gZGlzcDtcclxuXHJcblx0XHRcdGxldCBiYW5kQ2xpcE51bGxzID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmICh4MCAhPSBudWxsICYmIHNpemUgIT0gbnVsbCkge1xyXG5cdFx0XHRcdGRhdGFYID0geDAudmFsdWVzKHUsIHNlcmllc0lkeCwgaWR4MCwgaWR4MSk7XHJcblxyXG5cdFx0XHRcdGlmICh4MC51bml0ID09IDIpXHJcblx0XHRcdFx0XHRkYXRhWCA9IGRhdGFYLm1hcChwY3QgPT4gdS5wb3NUb1ZhbCh4T2ZmICsgcGN0ICogeERpbSwgc2NhbGVYLmtleSwgdHJ1ZSkpO1xyXG5cclxuXHRcdFx0XHQvLyBhc3N1bWVzIHVuaWZvcm0gc2l6ZXMsIGZvciBub3dcclxuXHRcdFx0XHRsZXQgc2l6ZXMgPSBzaXplLnZhbHVlcyh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEpO1xyXG5cclxuXHRcdFx0XHRpZiAoc2l6ZS51bml0ID09IDIpXHJcblx0XHRcdFx0XHRiYXJXaWQgPSBzaXplc1swXSAqIHhEaW07XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0YmFyV2lkID0gdmFsVG9Qb3NYKHNpemVzWzBdLCBzY2FsZVgsIHhEaW0sIHhPZmYpIC0gdmFsVG9Qb3NYKDAsIHNjYWxlWCwgeERpbSwgeE9mZik7IC8vIGFzc3VtZXMgbGluZWFyIHNjYWxlIChkZWx0YSBmcm9tIDApXHJcblxyXG5cdFx0XHRcdGJhcldpZCA9IHB4Um91bmQoYmFyV2lkIC0gc3Ryb2tlV2lkdGgpO1xyXG5cclxuXHRcdFx0XHR4U2hpZnQgPSAoX2RpclggPT0gMSA/IC1zdHJva2VXaWR0aCAvIDIgOiBiYXJXaWQgKyBzdHJva2VXaWR0aCAvIDIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjb2xXaWQgPSB4RGltO1xyXG5cclxuXHRcdFx0XHRpZiAoZGF0YVgubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRcdFx0Ly8gcHJpb3IgaW5kZXggd2l0aCBub24tdW5kZWZpbmVkIHkgZGF0YVxyXG5cdFx0XHRcdFx0bGV0IHByZXZJZHggPSBudWxsO1xyXG5cclxuXHRcdFx0XHRcdC8vIHNjYW4gZnVsbCBkYXRhc2V0IGZvciBzbWFsbGVzdCBhZGphY2VudCBkZWx0YVxyXG5cdFx0XHRcdFx0Ly8gd2lsbCBub3Qgd29yayBwcm9wZXJseSBmb3Igbm9uLWxpbmVhciB4IHNjYWxlcywgc2luY2UgZG9lcyBub3QgZG8gZXhwZW5zaXZlIHZhbFRvUG9zWCBjYWxjcyB0aWxsIGVuZFxyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIG1pbkRlbHRhID0gSW5maW5pdHk7IGkgPCBkYXRhWC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRpZiAoZGF0YVlbaV0gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChwcmV2SWR4ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGxldCBkZWx0YSA9IGFicyhkYXRhWFtpXSAtIGRhdGFYW3ByZXZJZHhdKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoZGVsdGEgPCBtaW5EZWx0YSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRtaW5EZWx0YSA9IGRlbHRhO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRjb2xXaWQgPSBhYnModmFsVG9Qb3NYKGRhdGFYW2ldLCBzY2FsZVgsIHhEaW0sIHhPZmYpIC0gdmFsVG9Qb3NYKGRhdGFYW3ByZXZJZHhdLCBzY2FsZVgsIHhEaW0sIHhPZmYpKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdHByZXZJZHggPSBpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgZ2FwV2lkID0gY29sV2lkICogZ2FwRmFjdG9yO1xyXG5cclxuXHRcdFx0XHRiYXJXaWQgPSBweFJvdW5kKG1pbihtYXhXaWR0aCwgbWF4KG1pbldpZHRoLCBjb2xXaWQgLSBnYXBXaWQpKSAtIHN0cm9rZVdpZHRoIC0gZXh0cmFHYXApO1xyXG5cclxuXHRcdFx0XHR4U2hpZnQgPSAoYWxpZ24gPT0gMCA/IGJhcldpZCAvIDIgOiBhbGlnbiA9PSBfZGlyWCA/IDAgOiBiYXJXaWQpIC0gYWxpZ24gKiBfZGlyWCAqIGV4dHJhR2FwIC8gMjtcclxuXHJcblx0XHRcdFx0Ly8gd2hlbiBjb2xXaWR0aCBpcyBzbWFsbGVyIHRoYW4gW21pbi1jbGFtcGVkXSBiYXIgd2lkdGggKGUuZy4gYWxpZ25lZCBkYXRhIHZhbHVlcyBhcmUgbm9uLXVuaWZvcm0pXHJcblx0XHRcdFx0Ly8gZGlzYWJsZSBjbGlwcGluZyBvZiBudWxsLXZhbHVlZCBiYW5kIGJhcnMgdG8gYXZvaWQgY2xpcCBvdmVybGFwIC8gYmxlZWQgaW50byBhZGphY2VudCBiYXJzXHJcblx0XHRcdFx0Ly8gKHRoaXMgY291bGQgc3RpbGwgYmxlZWQgY2xpcHMgb2YgYWRqYWNlbnQgYmFuZC9zdGFja2VkIGJhcnMgaW50byBlYWNoIG90aGVyLCBzbyBpcyBmYXIgZnJvbSBwZXJmZWN0KVxyXG5cdFx0XHRcdGlmIChiYXJXaWQgPiBjb2xXaWQpXHJcblx0XHRcdFx0XHRiYW5kQ2xpcE51bGxzID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IF9wYXRocyA9IHtzdHJva2U6IG51bGwsIGZpbGw6IG51bGwsIGNsaXA6IG51bGwsIGJhbmQ6IG51bGwsIGdhcHM6IG51bGwsIGZsYWdzOiBCQU5EX0NMSVBfRklMTCB8IEJBTkRfQ0xJUF9TVFJPS0V9OyAgLy8gZGlzcCwgZ2VvbVxyXG5cclxuXHRcdFx0bGV0IHlMaW1pdDtcclxuXHJcblx0XHRcdGlmIChiYW5kQ2xpcERpciAhPSAwKSB7XHJcblx0XHRcdFx0X3BhdGhzLmJhbmQgPSBuZXcgUGF0aDJEKCk7XHJcblx0XHRcdFx0eUxpbWl0ID0gcHhSb3VuZCh2YWxUb1Bvc1koYmFuZENsaXBEaXIgPT0gMSA/IHNjYWxlWS5tYXggOiBzY2FsZVkubWluLCBzY2FsZVksIHlEaW0sIHlPZmYpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3Qgc3Ryb2tlID0gbXVsdGlQYXRoID8gbnVsbCA6IG5ldyBQYXRoMkQoKTtcclxuXHRcdFx0Y29uc3QgYmFuZCA9IF9wYXRocy5iYW5kO1xyXG5cclxuXHRcdFx0bGV0IHsgeTAsIHkxIH0gPSBkaXNwO1xyXG5cclxuXHRcdFx0bGV0IGRhdGFZMCA9IG51bGw7XHJcblxyXG5cdFx0XHRpZiAoeTAgIT0gbnVsbCAmJiB5MSAhPSBudWxsKSB7XHJcblx0XHRcdFx0ZGF0YVkgPSB5MS52YWx1ZXModSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxKTtcclxuXHRcdFx0XHRkYXRhWTAgPSB5MC52YWx1ZXModSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IHJhZFZhbCA9IHZhbFJhZGl1cyAqIGJhcldpZDtcclxuXHRcdFx0bGV0IHJhZEJhc2UgPSBiYXNlUmFkaXVzICogYmFyV2lkO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IF9kaXJYID09IDEgPyBpZHgwIDogaWR4MTsgaSA+PSBpZHgwICYmIGkgPD0gaWR4MTsgaSArPSBfZGlyWCkge1xyXG5cdFx0XHRcdGxldCB5VmFsID0gZGF0YVlbaV07XHJcblxyXG5cdFx0XHRcdC8vIHdlIGNhbiBza2lwIGJvdGgsIGRyYXdpbmcgYW5kIGJhbmQgY2xpcHBpbmcgZm9yIGFsaWdubWVudCBhcnRpZmFjdHNcclxuXHRcdFx0XHRpZiAoeVZhbCA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHQvKlxyXG5cdFx0XHRcdC8vIGludGVycG9sYXRlIHVwd2FyZHMgYmFuZCBjbGlwc1xyXG5cdFx0XHRcdGlmICh5VmFsID09IG51bGwpIHtcclxuXHRcdFx0XHQvL1x0aWYgKGhhc0JhbmRzKVxyXG5cdFx0XHRcdC8vXHRcdHlWYWwgPSBjb3N0bHlMZXJwKGksIGlkeDAsIGlkeDEsIF9kaXJYLCBkYXRhWSk7XHJcblx0XHRcdFx0Ly9cdGVsc2VcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHQqL1xyXG5cclxuXHRcdFx0XHRsZXQgeFZhbCA9IHNjYWxlWC5kaXN0ciAhPSAyIHx8IGRpc3AgIT0gbnVsbCA/IGRhdGFYW2ldIDogaTtcclxuXHJcblx0XHRcdFx0Ly8gVE9ETzogYWxsIHhQb3MgY2FuIGJlIHByZS1jb21wdXRlZCBvbmNlIGZvciBhbGwgc2VyaWVzIGluIGFsaWduZWQgc2V0XHJcblx0XHRcdFx0bGV0IHhQb3MgPSB2YWxUb1Bvc1goeFZhbCwgc2NhbGVYLCB4RGltLCB4T2ZmKTtcclxuXHRcdFx0XHRsZXQgeVBvcyA9IHZhbFRvUG9zWShpZk51bGwoeVZhbCwgZmlsbFRvWSksIHNjYWxlWSwgeURpbSwgeU9mZik7XHJcblxyXG5cdFx0XHRcdGlmIChkYXRhWTAgIT0gbnVsbCAmJiB5VmFsICE9IG51bGwpXHJcblx0XHRcdFx0XHR5MFBvcyA9IHZhbFRvUG9zWShkYXRhWTBbaV0sIHNjYWxlWSwgeURpbSwgeU9mZik7XHJcblxyXG5cdFx0XHRcdGxldCBsZnQgPSBweFJvdW5kKHhQb3MgLSB4U2hpZnQpO1xyXG5cdFx0XHRcdGxldCBidG0gPSBweFJvdW5kKG1heCh5UG9zLCB5MFBvcykpO1xyXG5cdFx0XHRcdGxldCB0b3AgPSBweFJvdW5kKG1pbih5UG9zLCB5MFBvcykpO1xyXG5cdFx0XHRcdC8vIHRoaXMgaW5jbHVkZXMgdGhlIHN0cm9rZVxyXG5cdFx0XHRcdGxldCBiYXJIZ3QgPSBidG0gLSB0b3A7XHJcblxyXG5cdFx0XHRcdGlmICh5VmFsICE9IG51bGwpIHsgIC8vICYmIHlWYWwgIT0gZmlsbFRvWSAoMCBoZWlnaHQgYmFyKVxyXG5cdFx0XHRcdFx0bGV0IHJ2ID0geVZhbCA8IDAgPyByYWRCYXNlIDogcmFkVmFsO1xyXG5cdFx0XHRcdFx0bGV0IHJiID0geVZhbCA8IDAgPyByYWRWYWwgOiByYWRCYXNlO1xyXG5cclxuXHRcdFx0XHRcdGlmIChtdWx0aVBhdGgpIHtcclxuXHRcdFx0XHRcdFx0aWYgKHN0cm9rZVdpZHRoID4gMCAmJiBzdHJva2VDb2xvcnNbaV0gIT0gbnVsbClcclxuXHRcdFx0XHRcdFx0XHRyZWN0KHN0cm9rZVBhdGhzLmdldChzdHJva2VDb2xvcnNbaV0pLCBsZnQsIHRvcCArIGZsb29yKHN0cm9rZVdpZHRoIC8gMiksIGJhcldpZCwgbWF4KDAsIGJhckhndCAtIHN0cm9rZVdpZHRoKSwgcnYsIHJiKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChmaWxsQ29sb3JzW2ldICE9IG51bGwpXHJcblx0XHRcdFx0XHRcdFx0cmVjdChmaWxsUGF0aHMuZ2V0KGZpbGxDb2xvcnNbaV0pLCBsZnQsIHRvcCArIGZsb29yKHN0cm9rZVdpZHRoIC8gMiksIGJhcldpZCwgbWF4KDAsIGJhckhndCAtIHN0cm9rZVdpZHRoKSwgcnYsIHJiKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0cmVjdChzdHJva2UsIGxmdCwgdG9wICsgZmxvb3Ioc3Ryb2tlV2lkdGggLyAyKSwgYmFyV2lkLCBtYXgoMCwgYmFySGd0IC0gc3Ryb2tlV2lkdGgpLCBydiwgcmIpO1xyXG5cclxuXHRcdFx0XHRcdGVhY2godSwgc2VyaWVzSWR4LCBpLFxyXG5cdFx0XHRcdFx0XHRsZnQgICAgLSBzdHJva2VXaWR0aCAvIDIsXHJcblx0XHRcdFx0XHRcdHRvcCxcclxuXHRcdFx0XHRcdFx0YmFyV2lkICsgc3Ryb2tlV2lkdGgsXHJcblx0XHRcdFx0XHRcdGJhckhndCxcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoYmFuZENsaXBEaXIgIT0gMCAmJiAoeVZhbCAhPSBudWxsIHx8IGJhbmRDbGlwTnVsbHMpKSB7XHJcblx0XHRcdFx0XHRpZiAoX2RpclkgKiBiYW5kQ2xpcERpciA9PSAxKSB7XHJcblx0XHRcdFx0XHRcdGJ0bSA9IHRvcDtcclxuXHRcdFx0XHRcdFx0dG9wID0geUxpbWl0O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRvcCA9IGJ0bTtcclxuXHRcdFx0XHRcdFx0YnRtID0geUxpbWl0O1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJhckhndCA9IGJ0bSAtIHRvcDtcclxuXHJcblx0XHRcdFx0XHRyZWN0KGJhbmQsIGxmdCAtIHN0cm9rZVdpZHRoIC8gMiwgdG9wLCBiYXJXaWQgKyBzdHJva2VXaWR0aCwgbWF4KDAsIGJhckhndCksIDAsIDApOyAgLy8gcmFkaXVzIGhlcmU/XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoc3Ryb2tlV2lkdGggPiAwKVxyXG5cdFx0XHRcdF9wYXRocy5zdHJva2UgPSBtdWx0aVBhdGggPyBzdHJva2VQYXRocyA6IHN0cm9rZTtcclxuXHJcblx0XHRcdF9wYXRocy5maWxsID0gbXVsdGlQYXRoID8gZmlsbFBhdGhzIDogc3Ryb2tlO1xyXG5cclxuXHRcdFx0cmV0dXJuIF9wYXRocztcclxuXHRcdH0pO1xyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNwbGluZUludGVycChpbnRlcnAsIG9wdHMpIHtcclxuXHRjb25zdCBhbGlnbkdhcHMgPSBpZk51bGwob3B0cz8uYWxpZ25HYXBzLCAwKTtcclxuXHJcblx0cmV0dXJuICh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEpID0+IHtcclxuXHRcdHJldHVybiBvcmllbnQodSwgc2VyaWVzSWR4LCAoc2VyaWVzLCBkYXRhWCwgZGF0YVksIHNjYWxlWCwgc2NhbGVZLCB2YWxUb1Bvc1gsIHZhbFRvUG9zWSwgeE9mZiwgeU9mZiwgeERpbSwgeURpbSkgPT4ge1xyXG5cdFx0XHRsZXQgcHhSb3VuZCA9IHNlcmllcy5weFJvdW5kO1xyXG5cclxuXHRcdFx0bGV0IHBpeGVsRm9yWCA9IHZhbCA9PiBweFJvdW5kKHZhbFRvUG9zWCh2YWwsIHNjYWxlWCwgeERpbSwgeE9mZikpO1xyXG5cdFx0XHRsZXQgcGl4ZWxGb3JZID0gdmFsID0+IHB4Um91bmQodmFsVG9Qb3NZKHZhbCwgc2NhbGVZLCB5RGltLCB5T2ZmKSk7XHJcblxyXG5cdFx0XHRsZXQgbW92ZVRvLCBiZXppZXJDdXJ2ZVRvLCBsaW5lVG87XHJcblxyXG5cdFx0XHRpZiAoc2NhbGVYLm9yaSA9PSAwKSB7XHJcblx0XHRcdFx0bW92ZVRvID0gbW92ZVRvSDtcclxuXHRcdFx0XHRsaW5lVG8gPSBsaW5lVG9IO1xyXG5cdFx0XHRcdGJlemllckN1cnZlVG8gPSBiZXppZXJDdXJ2ZVRvSDtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRtb3ZlVG8gPSBtb3ZlVG9WO1xyXG5cdFx0XHRcdGxpbmVUbyA9IGxpbmVUb1Y7XHJcblx0XHRcdFx0YmV6aWVyQ3VydmVUbyA9IGJlemllckN1cnZlVG9WO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBkaXIgPSBzY2FsZVguZGlyICogKHNjYWxlWC5vcmkgPT0gMCA/IDEgOiAtMSk7XHJcblxyXG5cdFx0XHRpZHgwID0gbm9uTnVsbElkeChkYXRhWSwgaWR4MCwgaWR4MSwgIDEpO1xyXG5cdFx0XHRpZHgxID0gbm9uTnVsbElkeChkYXRhWSwgaWR4MCwgaWR4MSwgLTEpO1xyXG5cclxuXHRcdFx0bGV0IGZpcnN0WFBvcyA9IHBpeGVsRm9yWChkYXRhWFtkaXIgPT0gMSA/IGlkeDAgOiBpZHgxXSk7XHJcblx0XHRcdGxldCBwcmV2WFBvcyA9IGZpcnN0WFBvcztcclxuXHJcblx0XHRcdGxldCB4Q29vcmRzID0gW107XHJcblx0XHRcdGxldCB5Q29vcmRzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gZGlyID09IDEgPyBpZHgwIDogaWR4MTsgaSA+PSBpZHgwICYmIGkgPD0gaWR4MTsgaSArPSBkaXIpIHtcclxuXHRcdFx0XHRsZXQgeVZhbCA9IGRhdGFZW2ldO1xyXG5cclxuXHRcdFx0XHRpZiAoeVZhbCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRsZXQgeFZhbCA9IGRhdGFYW2ldO1xyXG5cdFx0XHRcdFx0bGV0IHhQb3MgPSBwaXhlbEZvclgoeFZhbCk7XHJcblxyXG5cdFx0XHRcdFx0eENvb3Jkcy5wdXNoKHByZXZYUG9zID0geFBvcyk7XHJcblx0XHRcdFx0XHR5Q29vcmRzLnB1c2gocGl4ZWxGb3JZKGRhdGFZW2ldKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBfcGF0aHMgPSB7c3Ryb2tlOiBpbnRlcnAoeENvb3JkcywgeUNvb3JkcywgbW92ZVRvLCBsaW5lVG8sIGJlemllckN1cnZlVG8sIHB4Um91bmQpLCBmaWxsOiBudWxsLCBjbGlwOiBudWxsLCBiYW5kOiBudWxsLCBnYXBzOiBudWxsLCBmbGFnczogQkFORF9DTElQX0ZJTEx9O1xyXG5cdFx0XHRjb25zdCBzdHJva2UgPSBfcGF0aHMuc3Ryb2tlO1xyXG5cclxuXHRcdFx0bGV0IFsgYmFuZEZpbGxEaXIsIGJhbmRDbGlwRGlyIF0gPSBiYW5kRmlsbENsaXBEaXJzKHUsIHNlcmllc0lkeCk7XHJcblxyXG5cdFx0XHRpZiAoc2VyaWVzLmZpbGwgIT0gbnVsbCB8fCBiYW5kRmlsbERpciAhPSAwKSB7XHJcblx0XHRcdFx0bGV0IGZpbGwgPSBfcGF0aHMuZmlsbCA9IG5ldyBQYXRoMkQoc3Ryb2tlKTtcclxuXHJcblx0XHRcdFx0bGV0IGZpbGxUbyA9IHNlcmllcy5maWxsVG8odSwgc2VyaWVzSWR4LCBzZXJpZXMubWluLCBzZXJpZXMubWF4LCBiYW5kRmlsbERpcik7XHJcblx0XHRcdFx0bGV0IGZpbGxUb1kgPSBwaXhlbEZvclkoZmlsbFRvKTtcclxuXHJcblx0XHRcdFx0bGluZVRvKGZpbGwsIHByZXZYUG9zLCBmaWxsVG9ZKTtcclxuXHRcdFx0XHRsaW5lVG8oZmlsbCwgZmlyc3RYUG9zLCBmaWxsVG9ZKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCFzZXJpZXMuc3BhbkdhcHMpIHtcclxuXHRcdFx0Ly9cdGNvbnNvbGUudGltZSgnZ2FwcycpO1xyXG5cdFx0XHRcdGxldCBnYXBzID0gW107XHJcblxyXG5cdFx0XHRcdGdhcHMucHVzaCguLi5maW5kR2FwcyhkYXRhWCwgZGF0YVksIGlkeDAsIGlkeDEsIGRpciwgcGl4ZWxGb3JYLCBhbGlnbkdhcHMpKTtcclxuXHJcblx0XHRcdC8vXHRjb25zb2xlLnRpbWVFbmQoJ2dhcHMnKTtcclxuXHJcblx0XHRcdC8vXHRjb25zb2xlLmxvZygnZ2FwcycsIEpTT04uc3RyaW5naWZ5KGdhcHMpKTtcclxuXHJcblx0XHRcdFx0X3BhdGhzLmdhcHMgPSBnYXBzID0gc2VyaWVzLmdhcHModSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBnYXBzKTtcclxuXHJcblx0XHRcdFx0X3BhdGhzLmNsaXAgPSBjbGlwR2FwcyhnYXBzLCBzY2FsZVgub3JpLCB4T2ZmLCB5T2ZmLCB4RGltLCB5RGltKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGJhbmRDbGlwRGlyICE9IDApIHtcclxuXHRcdFx0XHRfcGF0aHMuYmFuZCA9IGJhbmRDbGlwRGlyID09IDIgPyBbXHJcblx0XHRcdFx0XHRjbGlwQmFuZExpbmUodSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBzdHJva2UsIC0xKSxcclxuXHRcdFx0XHRcdGNsaXBCYW5kTGluZSh1LCBzZXJpZXNJZHgsIGlkeDAsIGlkeDEsIHN0cm9rZSwgIDEpLFxyXG5cdFx0XHRcdF0gOiBjbGlwQmFuZExpbmUodSwgc2VyaWVzSWR4LCBpZHgwLCBpZHgxLCBzdHJva2UsIGJhbmRDbGlwRGlyKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIF9wYXRocztcclxuXHJcblx0XHRcdC8vICBpZiBGRUFUX1BBVEhTOiBmYWxzZSBpbiByb2xsdXAuY29uZmlnLmpzXHJcblx0XHRcdC8vXHR1LmN0eC5zYXZlKCk7XHJcblx0XHRcdC8vXHR1LmN0eC5iZWdpblBhdGgoKTtcclxuXHRcdFx0Ly9cdHUuY3R4LnJlY3QodS5iYm94LmxlZnQsIHUuYmJveC50b3AsIHUuYmJveC53aWR0aCwgdS5iYm94LmhlaWdodCk7XHJcblx0XHRcdC8vXHR1LmN0eC5jbGlwKCk7XHJcblx0XHRcdC8vXHR1LmN0eC5zdHJva2VTdHlsZSA9IHUuc2VyaWVzW3NpZHhdLnN0cm9rZTtcclxuXHRcdFx0Ly9cdHUuY3R4LnN0cm9rZShzdHJva2UpO1xyXG5cdFx0XHQvL1x0dS5jdHguZmlsbFN0eWxlID0gdS5zZXJpZXNbc2lkeF0uZmlsbDtcclxuXHRcdFx0Ly9cdHUuY3R4LmZpbGwoZmlsbCk7XHJcblx0XHRcdC8vXHR1LmN0eC5yZXN0b3JlKCk7XHJcblx0XHRcdC8vXHRyZXR1cm4gbnVsbDtcclxuXHRcdH0pO1xyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vbm90b25lQ3ViaWMob3B0cykge1xyXG5cdHJldHVybiBzcGxpbmVJbnRlcnAoX21vbm90b25lQ3ViaWMsIG9wdHMpO1xyXG59XHJcblxyXG4vLyBNb25vdG9uZSBDdWJpYyBTcGxpbmUgaW50ZXJwb2xhdGlvbiwgYWRhcHRlZCBmcm9tIHRoZSBDaGFydGlzdC5qcyBpbXBsZW1lbnRhdGlvbjpcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpb25rdW56L2NoYXJ0aXN0LWpzL2Jsb2IvZTdlNzgyMDFiZmZlOTYwOTkxNWU1ZTUzY2ZhZmEyOWE1ZDZjNDlmOS9zcmMvc2NyaXB0cy9pbnRlcnBvbGF0aW9uLmpzI0wyNDAtTDM2OVxyXG5mdW5jdGlvbiBfbW9ub3RvbmVDdWJpYyh4cywgeXMsIG1vdmVUbywgbGluZVRvLCBiZXppZXJDdXJ2ZVRvLCBweFJvdW5kKSB7XHJcblx0Y29uc3QgbiA9IHhzLmxlbmd0aDtcclxuXHJcblx0aWYgKG4gPCAyKVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdGNvbnN0IHBhdGggPSBuZXcgUGF0aDJEKCk7XHJcblxyXG5cdG1vdmVUbyhwYXRoLCB4c1swXSwgeXNbMF0pO1xyXG5cclxuXHRpZiAobiA9PSAyKVxyXG5cdFx0bGluZVRvKHBhdGgsIHhzWzFdLCB5c1sxXSk7XHJcblx0ZWxzZSB7XHJcblx0XHRsZXQgbXMgID0gQXJyYXkobiksXHJcblx0XHRcdGRzICA9IEFycmF5KG4gLSAxKSxcclxuXHRcdFx0ZHlzID0gQXJyYXkobiAtIDEpLFxyXG5cdFx0XHRkeHMgPSBBcnJheShuIC0gMSk7XHJcblxyXG5cdFx0Ly8gY2FsYyBkZWx0YXMgYW5kIGRlcml2YXRpdmVcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xyXG5cdFx0XHRkeXNbaV0gPSB5c1tpICsgMV0gLSB5c1tpXTtcclxuXHRcdFx0ZHhzW2ldID0geHNbaSArIDFdIC0geHNbaV07XHJcblx0XHRcdGRzW2ldICA9IGR5c1tpXSAvIGR4c1tpXTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBkZXRlcm1pbmUgZGVzaXJlZCBzbG9wZSAobSkgYXQgZWFjaCBwb2ludCB1c2luZyBGcml0c2NoLUNhcmxzb24gbWV0aG9kXHJcblx0XHQvLyBodHRwOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNDUyMTgvaW1wbGVtZW50YXRpb24tb2YtbW9ub3RvbmUtY3ViaWMtaW50ZXJwb2xhdGlvblxyXG5cdFx0bXNbMF0gPSBkc1swXTtcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMTsgaSA8IG4gLSAxOyBpKyspIHtcclxuXHRcdFx0aWYgKGRzW2ldID09PSAwIHx8IGRzW2kgLSAxXSA9PT0gMCB8fCAoZHNbaSAtIDFdID4gMCkgIT09IChkc1tpXSA+IDApKVxyXG5cdFx0XHRcdG1zW2ldID0gMDtcclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0bXNbaV0gPSAzICogKGR4c1tpIC0gMV0gKyBkeHNbaV0pIC8gKFxyXG5cdFx0XHRcdFx0KDIgKiBkeHNbaV0gKyBkeHNbaSAtIDFdKSAvIGRzW2kgLSAxXSArXHJcblx0XHRcdFx0XHQoZHhzW2ldICsgMiAqIGR4c1tpIC0gMV0pIC8gZHNbaV1cclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRpZiAoIWlzRmluaXRlKG1zW2ldKSlcclxuXHRcdFx0XHRcdG1zW2ldID0gMDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1zW24gLSAxXSA9IGRzW24gLSAyXTtcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcclxuXHRcdFx0YmV6aWVyQ3VydmVUbyhcclxuXHRcdFx0XHRwYXRoLFxyXG5cdFx0XHRcdHhzW2ldICsgZHhzW2ldIC8gMyxcclxuXHRcdFx0XHR5c1tpXSArIG1zW2ldICogZHhzW2ldIC8gMyxcclxuXHRcdFx0XHR4c1tpICsgMV0gLSBkeHNbaV0gLyAzLFxyXG5cdFx0XHRcdHlzW2kgKyAxXSAtIG1zW2kgKyAxXSAqIGR4c1tpXSAvIDMsXHJcblx0XHRcdFx0eHNbaSArIDFdLFxyXG5cdFx0XHRcdHlzW2kgKyAxXSxcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBwYXRoO1xyXG59XHJcblxyXG5jb25zdCBjdXJzb3JQbG90cyA9IG5ldyBTZXQoKTtcclxuXHJcbmZ1bmN0aW9uIGludmFsaWRhdGVSZWN0cygpIHtcclxuXHRmb3IgKGxldCB1IG9mIGN1cnNvclBsb3RzKVxyXG5cdFx0dS5zeW5jUmVjdCh0cnVlKTtcclxufVxyXG5cclxuaWYgKGRvbUVudikge1xyXG5cdG9uKHJlc2l6ZSwgd2luLCBpbnZhbGlkYXRlUmVjdHMpO1xyXG5cdG9uKHNjcm9sbCwgd2luLCBpbnZhbGlkYXRlUmVjdHMsIHRydWUpO1xyXG5cdG9uKGRwcHhjaGFuZ2UsIHdpbiwgKCkgPT4geyB1UGxvdC5weFJhdGlvID0gcHhSYXRpbzsgfSk7XHJcbn1cclxuXHJcbmNvbnN0IGxpbmVhclBhdGggPSBsaW5lYXIoKSA7XHJcbmNvbnN0IHBvaW50c1BhdGggPSBwb2ludHMoKSA7XHJcblxyXG5mdW5jdGlvbiBzZXREZWZhdWx0cyhkLCB4bywgeW8sIGluaXRZKSB7XHJcblx0bGV0IGQyID0gaW5pdFkgPyBbZFswXSwgZFsxXV0uY29uY2F0KGQuc2xpY2UoMikpIDogW2RbMF1dLmNvbmNhdChkLnNsaWNlKDEpKTtcclxuXHRyZXR1cm4gZDIubWFwKChvLCBpKSA9PiBzZXREZWZhdWx0KG8sIGksIHhvLCB5bykpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXREZWZhdWx0czIoZCwgeHlvKSB7XHJcblx0cmV0dXJuIGQubWFwKChvLCBpKSA9PiBpID09IDAgPyBudWxsIDogYXNzaWduKHt9LCB4eW8sIG8pKTsgIC8vIHRvZG86IGFzc2lnbigpIHdpbGwgbm90IG1lcmdlIGZhY2V0IGFycmF5c1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXREZWZhdWx0KG8sIGksIHhvLCB5bykge1xyXG5cdHJldHVybiBhc3NpZ24oe30sIChpID09IDAgPyB4byA6IHlvKSwgbyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNuYXBOdW1YKHNlbGYsIGRhdGFNaW4sIGRhdGFNYXgpIHtcclxuXHRyZXR1cm4gZGF0YU1pbiA9PSBudWxsID8gbnVsbE51bGxUdXBsZSA6IFtkYXRhTWluLCBkYXRhTWF4XTtcclxufVxyXG5cclxuY29uc3Qgc25hcFRpbWVYID0gc25hcE51bVg7XHJcblxyXG4vLyB0aGlzIGVuc3VyZXMgdGhhdCBub24tdGVtcG9yYWwvbnVtZXJpYyB5LWF4ZXMgZ2V0IG11bHRpcGxlLXNuYXBwZWQgcGFkZGluZyBhZGRlZCBhYm92ZS9iZWxvd1xyXG4vLyBUT0RPOiBhbHNvIGFjY291bnQgZm9yIGluY3JzIHdoZW4gc25hcHBpbmcgdG8gZW5zdXJlIHRvcCBvZiBheGlzIGdldHMgYSB0aWNrICYgdmFsdWVcclxuZnVuY3Rpb24gc25hcE51bVkoc2VsZiwgZGF0YU1pbiwgZGF0YU1heCkge1xyXG5cdHJldHVybiBkYXRhTWluID09IG51bGwgPyBudWxsTnVsbFR1cGxlIDogcmFuZ2VOdW0oZGF0YU1pbiwgZGF0YU1heCwgcmFuZ2VQYWQsIHRydWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzbmFwTG9nWShzZWxmLCBkYXRhTWluLCBkYXRhTWF4LCBzY2FsZSkge1xyXG5cdHJldHVybiBkYXRhTWluID09IG51bGwgPyBudWxsTnVsbFR1cGxlIDogcmFuZ2VMb2coZGF0YU1pbiwgZGF0YU1heCwgc2VsZi5zY2FsZXNbc2NhbGVdLmxvZywgZmFsc2UpO1xyXG59XHJcblxyXG5jb25zdCBzbmFwTG9nWCA9IHNuYXBMb2dZO1xyXG5cclxuZnVuY3Rpb24gc25hcEFzaW5oWShzZWxmLCBkYXRhTWluLCBkYXRhTWF4LCBzY2FsZSkge1xyXG5cdHJldHVybiBkYXRhTWluID09IG51bGwgPyBudWxsTnVsbFR1cGxlIDogcmFuZ2VBc2luaChkYXRhTWluLCBkYXRhTWF4LCBzZWxmLnNjYWxlc1tzY2FsZV0ubG9nLCBmYWxzZSk7XHJcbn1cclxuXHJcbmNvbnN0IHNuYXBBc2luaFggPSBzbmFwQXNpbmhZO1xyXG5cclxuLy8gZGltIGlzIGxvZ2ljYWwgKGdldENsaWVudEJvdW5kaW5nUmVjdCkgcGl4ZWxzLCBub3QgY2FudmFzIHBpeGVsc1xyXG5mdW5jdGlvbiBmaW5kSW5jcihtaW5WYWwsIG1heFZhbCwgaW5jcnMsIGRpbSwgbWluU3BhY2UpIHtcclxuXHRsZXQgaW50RGlnaXRzID0gbWF4KG51bUludERpZ2l0cyhtaW5WYWwpLCBudW1JbnREaWdpdHMobWF4VmFsKSk7XHJcblxyXG5cdGxldCBkZWx0YSA9IG1heFZhbCAtIG1pblZhbDtcclxuXHJcblx0bGV0IGluY3JJZHggPSBjbG9zZXN0SWR4KChtaW5TcGFjZSAvIGRpbSkgKiBkZWx0YSwgaW5jcnMpO1xyXG5cclxuXHRkbyB7XHJcblx0XHRsZXQgZm91bmRJbmNyID0gaW5jcnNbaW5jcklkeF07XHJcblx0XHRsZXQgZm91bmRTcGFjZSA9IGRpbSAqIGZvdW5kSW5jciAvIGRlbHRhO1xyXG5cclxuXHRcdGlmIChmb3VuZFNwYWNlID49IG1pblNwYWNlICYmIGludERpZ2l0cyArIChmb3VuZEluY3IgPCA1ID8gZml4ZWREZWMuZ2V0KGZvdW5kSW5jcikgOiAwKSA8PSAxNylcclxuXHRcdFx0cmV0dXJuIFtmb3VuZEluY3IsIGZvdW5kU3BhY2VdO1xyXG5cdH0gd2hpbGUgKCsraW5jcklkeCA8IGluY3JzLmxlbmd0aCk7XHJcblxyXG5cdHJldHVybiBbMCwgMF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHB4UmF0aW9Gb250KGZvbnQpIHtcclxuXHRsZXQgZm9udFNpemUsIGZvbnRTaXplQ3NzO1xyXG5cdGZvbnQgPSBmb250LnJlcGxhY2UoLyhcXGQrKXB4LywgKG0sIHAxKSA9PiAoZm9udFNpemUgPSByb3VuZCgoZm9udFNpemVDc3MgPSArcDEpICogcHhSYXRpbykpICsgJ3B4Jyk7XHJcblx0cmV0dXJuIFtmb250LCBmb250U2l6ZSwgZm9udFNpemVDc3NdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzeW5jRm9udFNpemUoYXhpcykge1xyXG5cdGlmIChheGlzLnNob3cpIHtcclxuXHRcdFtheGlzLmZvbnQsIGF4aXMubGFiZWxGb250XS5mb3JFYWNoKGYgPT4ge1xyXG5cdFx0XHRsZXQgc2l6ZSA9IHJvdW5kRGVjKGZbMl0gKiBweFJhdGlvLCAxKTtcclxuXHRcdFx0ZlswXSA9IGZbMF0ucmVwbGFjZSgvWzAtOS5dK3B4Lywgc2l6ZSArICdweCcpO1xyXG5cdFx0XHRmWzFdID0gc2l6ZTtcclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdVBsb3Qob3B0cywgZGF0YSwgdGhlbikge1xyXG5cdGNvbnN0IHNlbGYgPSB7XHJcblx0XHRtb2RlOiBpZk51bGwob3B0cy5tb2RlLCAxKSxcclxuXHR9O1xyXG5cclxuXHRjb25zdCBtb2RlID0gc2VsZi5tb2RlO1xyXG5cclxuXHQvLyBUT0RPOiBjYWNoZSBkZW5vbXMgJiBtaW5zIHNjYWxlLmNhY2hlID0ge3IsIG1pbiwgfVxyXG5cdGZ1bmN0aW9uIGdldFZhbFBjdCh2YWwsIHNjYWxlKSB7XHJcblx0XHRsZXQgX3ZhbCA9IChcclxuXHRcdFx0c2NhbGUuZGlzdHIgPT0gMyA/IGxvZzEwKHZhbCA+IDAgPyB2YWwgOiBzY2FsZS5jbGFtcChzZWxmLCB2YWwsIHNjYWxlLm1pbiwgc2NhbGUubWF4LCBzY2FsZS5rZXkpKSA6XHJcblx0XHRcdHNjYWxlLmRpc3RyID09IDQgPyBhc2luaCh2YWwsIHNjYWxlLmFzaW5oKSA6XHJcblx0XHRcdHZhbFxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gKF92YWwgLSBzY2FsZS5fbWluKSAvIChzY2FsZS5fbWF4IC0gc2NhbGUuX21pbik7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRIUG9zKHZhbCwgc2NhbGUsIGRpbSwgb2ZmKSB7XHJcblx0XHRsZXQgcGN0ID0gZ2V0VmFsUGN0KHZhbCwgc2NhbGUpO1xyXG5cdFx0cmV0dXJuIG9mZiArIGRpbSAqIChzY2FsZS5kaXIgPT0gLTEgPyAoMSAtIHBjdCkgOiBwY3QpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0VlBvcyh2YWwsIHNjYWxlLCBkaW0sIG9mZikge1xyXG5cdFx0bGV0IHBjdCA9IGdldFZhbFBjdCh2YWwsIHNjYWxlKTtcclxuXHRcdHJldHVybiBvZmYgKyBkaW0gKiAoc2NhbGUuZGlyID09IC0xID8gcGN0IDogKDEgLSBwY3QpKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFBvcyh2YWwsIHNjYWxlLCBkaW0sIG9mZikge1xyXG5cdFx0cmV0dXJuIHNjYWxlLm9yaSA9PSAwID8gZ2V0SFBvcyh2YWwsIHNjYWxlLCBkaW0sIG9mZikgOiBnZXRWUG9zKHZhbCwgc2NhbGUsIGRpbSwgb2ZmKTtcclxuXHR9XHJcblxyXG5cdHNlbGYudmFsVG9Qb3NIID0gZ2V0SFBvcztcclxuXHRzZWxmLnZhbFRvUG9zViA9IGdldFZQb3M7XHJcblxyXG5cdGxldCByZWFkeSA9IGZhbHNlO1xyXG5cdHNlbGYuc3RhdHVzID0gMDtcclxuXHJcblx0Y29uc3Qgcm9vdCA9IHNlbGYucm9vdCA9IHBsYWNlRGl2KFVQTE9UKTtcclxuXHJcblx0aWYgKG9wdHMuaWQgIT0gbnVsbClcclxuXHRcdHJvb3QuaWQgPSBvcHRzLmlkO1xyXG5cclxuXHRhZGRDbGFzcyhyb290LCBvcHRzLmNsYXNzKTtcclxuXHJcblx0aWYgKG9wdHMudGl0bGUpIHtcclxuXHRcdGxldCB0aXRsZSA9IHBsYWNlRGl2KFRJVExFLCByb290KTtcclxuXHRcdHRpdGxlLnRleHRDb250ZW50ID0gb3B0cy50aXRsZTtcclxuXHR9XHJcblxyXG5cdGNvbnN0IGNhbiA9IHBsYWNlVGFnKFwiY2FudmFzXCIpO1xyXG5cdGNvbnN0IGN0eCA9IHNlbGYuY3R4ID0gY2FuLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcblx0Y29uc3Qgd3JhcCA9IHBsYWNlRGl2KFdSQVAsIHJvb3QpO1xyXG5cclxuXHRvbihcImNsaWNrXCIsIHdyYXAsIGUgPT4ge1xyXG5cdFx0aWYgKGUudGFyZ2V0ID09PSBvdmVyKSB7XHJcblx0XHRcdGxldCBkaWREcmFnID0gbW91c2VMZWZ0MSAhPSBtb3VzZUxlZnQwIHx8IG1vdXNlVG9wMSAhPSBtb3VzZVRvcDA7XHJcblx0XHRcdGRpZERyYWcgJiYgZHJhZy5jbGljayhzZWxmLCBlKTtcclxuXHRcdH1cclxuXHR9LCB0cnVlKTtcclxuXHJcblx0Y29uc3QgdW5kZXIgPSBzZWxmLnVuZGVyID0gcGxhY2VEaXYoVU5ERVIsIHdyYXApO1xyXG5cdHdyYXAuYXBwZW5kQ2hpbGQoY2FuKTtcclxuXHRjb25zdCBvdmVyID0gc2VsZi5vdmVyID0gcGxhY2VEaXYoT1ZFUiwgd3JhcCk7XHJcblxyXG5cdG9wdHMgPSBjb3B5KG9wdHMpO1xyXG5cclxuXHRjb25zdCBweEFsaWduID0gK2lmTnVsbChvcHRzLnB4QWxpZ24sIDEpO1xyXG5cclxuXHRjb25zdCBweFJvdW5kID0gcHhSb3VuZEdlbihweEFsaWduKTtcclxuXHJcblx0KG9wdHMucGx1Z2lucyB8fCBbXSkuZm9yRWFjaChwID0+IHtcclxuXHRcdGlmIChwLm9wdHMpXHJcblx0XHRcdG9wdHMgPSBwLm9wdHMoc2VsZiwgb3B0cykgfHwgb3B0cztcclxuXHR9KTtcclxuXHJcblx0Y29uc3QgbXMgPSBvcHRzLm1zIHx8IDFlLTM7XHJcblxyXG5cdGNvbnN0IHNlcmllcyAgPSBzZWxmLnNlcmllcyA9IG1vZGUgPT0gMSA/XHJcblx0XHRzZXREZWZhdWx0cyhvcHRzLnNlcmllcyB8fCBbXSwgeFNlcmllc09wdHMsIHlTZXJpZXNPcHRzLCBmYWxzZSkgOlxyXG5cdFx0c2V0RGVmYXVsdHMyKG9wdHMuc2VyaWVzIHx8IFtudWxsXSwgeHlTZXJpZXNPcHRzKTtcclxuXHRjb25zdCBheGVzICAgID0gc2VsZi5heGVzICAgPSBzZXREZWZhdWx0cyhvcHRzLmF4ZXMgICB8fCBbXSwgeEF4aXNPcHRzLCAgIHlBeGlzT3B0cywgICAgdHJ1ZSk7XHJcblx0Y29uc3Qgc2NhbGVzICA9IHNlbGYuc2NhbGVzID0ge307XHJcblx0Y29uc3QgYmFuZHMgICA9IHNlbGYuYmFuZHMgID0gb3B0cy5iYW5kcyB8fCBbXTtcclxuXHJcblx0YmFuZHMuZm9yRWFjaChiID0+IHtcclxuXHRcdGIuZmlsbCA9IGZuT3JTZWxmKGIuZmlsbCB8fCBudWxsKTtcclxuXHRcdGIuZGlyID0gaWZOdWxsKGIuZGlyLCAtMSk7XHJcblx0fSk7XHJcblxyXG5cdGNvbnN0IHhTY2FsZUtleSA9IG1vZGUgPT0gMiA/IHNlcmllc1sxXS5mYWNldHNbMF0uc2NhbGUgOiBzZXJpZXNbMF0uc2NhbGU7XHJcblxyXG5cdGNvbnN0IGRyYXdPcmRlck1hcCA9IHtcclxuXHRcdGF4ZXM6IGRyYXdBeGVzR3JpZCxcclxuXHRcdHNlcmllczogZHJhd1NlcmllcyxcclxuXHR9O1xyXG5cclxuXHRjb25zdCBkcmF3T3JkZXIgPSAob3B0cy5kcmF3T3JkZXIgfHwgW1wiYXhlc1wiLCBcInNlcmllc1wiXSkubWFwKGtleSA9PiBkcmF3T3JkZXJNYXBba2V5XSk7XHJcblxyXG5cdGZ1bmN0aW9uIGluaXRTY2FsZShzY2FsZUtleSkge1xyXG5cdFx0bGV0IHNjID0gc2NhbGVzW3NjYWxlS2V5XTtcclxuXHJcblx0XHRpZiAoc2MgPT0gbnVsbCkge1xyXG5cdFx0XHRsZXQgc2NhbGVPcHRzID0gKG9wdHMuc2NhbGVzIHx8IEVNUFRZX09CSilbc2NhbGVLZXldIHx8IEVNUFRZX09CSjtcclxuXHJcblx0XHRcdGlmIChzY2FsZU9wdHMuZnJvbSAhPSBudWxsKSB7XHJcblx0XHRcdFx0Ly8gZW5zdXJlIHBhcmVudCBpcyBpbml0aWFsaXplZFxyXG5cdFx0XHRcdGluaXRTY2FsZShzY2FsZU9wdHMuZnJvbSk7XHJcblx0XHRcdFx0Ly8gZGVwZW5kZW50IHNjYWxlcyBpbmhlcml0XHJcblx0XHRcdFx0c2NhbGVzW3NjYWxlS2V5XSA9IGFzc2lnbih7fSwgc2NhbGVzW3NjYWxlT3B0cy5mcm9tXSwgc2NhbGVPcHRzLCB7a2V5OiBzY2FsZUtleX0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHNjID0gc2NhbGVzW3NjYWxlS2V5XSA9IGFzc2lnbih7fSwgKHNjYWxlS2V5ID09IHhTY2FsZUtleSA/IHhTY2FsZU9wdHMgOiB5U2NhbGVPcHRzKSwgc2NhbGVPcHRzKTtcclxuXHJcblx0XHRcdFx0c2Mua2V5ID0gc2NhbGVLZXk7XHJcblxyXG5cdFx0XHRcdGxldCBpc1RpbWUgPSBzYy50aW1lO1xyXG5cclxuXHRcdFx0XHRsZXQgcm4gPSBzYy5yYW5nZTtcclxuXHJcblx0XHRcdFx0bGV0IHJhbmdlSXNBcnIgPSBpc0Fycihybik7XHJcblxyXG5cdFx0XHRcdGlmIChzY2FsZUtleSAhPSB4U2NhbGVLZXkgfHwgKG1vZGUgPT0gMiAmJiAhaXNUaW1lKSkge1xyXG5cdFx0XHRcdFx0Ly8gaWYgcmFuZ2UgYXJyYXkgaGFzIG51bGwgbGltaXRzLCBpdCBzaG91bGQgYmUgYXV0b1xyXG5cdFx0XHRcdFx0aWYgKHJhbmdlSXNBcnIgJiYgKHJuWzBdID09IG51bGwgfHwgcm5bMV0gPT0gbnVsbCkpIHtcclxuXHRcdFx0XHRcdFx0cm4gPSB7XHJcblx0XHRcdFx0XHRcdFx0bWluOiByblswXSA9PSBudWxsID8gYXV0b1JhbmdlUGFydCA6IHtcclxuXHRcdFx0XHRcdFx0XHRcdG1vZGU6IDEsXHJcblx0XHRcdFx0XHRcdFx0XHRoYXJkOiByblswXSxcclxuXHRcdFx0XHRcdFx0XHRcdHNvZnQ6IHJuWzBdLFxyXG5cdFx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdFx0bWF4OiByblsxXSA9PSBudWxsID8gYXV0b1JhbmdlUGFydCA6IHtcclxuXHRcdFx0XHRcdFx0XHRcdG1vZGU6IDEsXHJcblx0XHRcdFx0XHRcdFx0XHRoYXJkOiByblsxXSxcclxuXHRcdFx0XHRcdFx0XHRcdHNvZnQ6IHJuWzFdLFxyXG5cdFx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRcdHJhbmdlSXNBcnIgPSBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIXJhbmdlSXNBcnIgJiYgaXNPYmoocm4pKSB7XHJcblx0XHRcdFx0XHRcdGxldCBjZmcgPSBybjtcclxuXHRcdFx0XHRcdFx0Ly8gdGhpcyBpcyBzaW1pbGFyIHRvIHNuYXBOdW1ZXHJcblx0XHRcdFx0XHRcdHJuID0gKHNlbGYsIGRhdGFNaW4sIGRhdGFNYXgpID0+IGRhdGFNaW4gPT0gbnVsbCA/IG51bGxOdWxsVHVwbGUgOiByYW5nZU51bShkYXRhTWluLCBkYXRhTWF4LCBjZmcpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c2MucmFuZ2UgPSBmbk9yU2VsZihybiB8fCAoaXNUaW1lID8gc25hcFRpbWVYIDogc2NhbGVLZXkgPT0geFNjYWxlS2V5ID9cclxuXHRcdFx0XHRcdChzYy5kaXN0ciA9PSAzID8gc25hcExvZ1ggOiBzYy5kaXN0ciA9PSA0ID8gc25hcEFzaW5oWCA6IHNuYXBOdW1YKSA6XHJcblx0XHRcdFx0XHQoc2MuZGlzdHIgPT0gMyA/IHNuYXBMb2dZIDogc2MuZGlzdHIgPT0gNCA/IHNuYXBBc2luaFkgOiBzbmFwTnVtWSlcclxuXHRcdFx0XHQpKTtcclxuXHJcblx0XHRcdFx0c2MuYXV0byA9IGZuT3JTZWxmKHJhbmdlSXNBcnIgPyBmYWxzZSA6IHNjLmF1dG8pO1xyXG5cclxuXHRcdFx0XHRzYy5jbGFtcCA9IGZuT3JTZWxmKHNjLmNsYW1wIHx8IGNsYW1wU2NhbGUpO1xyXG5cclxuXHRcdFx0XHQvLyBjYWNoZXMgZm9yIGV4cGVuc2l2ZSBvcHMgbGlrZSBhc2luaCgpICYgbG9nKClcclxuXHRcdFx0XHRzYy5fbWluID0gc2MuX21heCA9IG51bGw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGluaXRTY2FsZShcInhcIik7XHJcblx0aW5pdFNjYWxlKFwieVwiKTtcclxuXHJcblx0Ly8gVE9ETzogaW5pdCBzY2FsZXMgZnJvbSBmYWNldHMgaW4gbW9kZTogMlxyXG5cdGlmIChtb2RlID09IDEpIHtcclxuXHRcdHNlcmllcy5mb3JFYWNoKHMgPT4ge1xyXG5cdFx0XHRpbml0U2NhbGUocy5zY2FsZSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGF4ZXMuZm9yRWFjaChhID0+IHtcclxuXHRcdGluaXRTY2FsZShhLnNjYWxlKTtcclxuXHR9KTtcclxuXHJcblx0Zm9yIChsZXQgayBpbiBvcHRzLnNjYWxlcylcclxuXHRcdGluaXRTY2FsZShrKTtcclxuXHJcblx0Y29uc3Qgc2NhbGVYID0gc2NhbGVzW3hTY2FsZUtleV07XHJcblxyXG5cdGNvbnN0IHhTY2FsZURpc3RyID0gc2NhbGVYLmRpc3RyO1xyXG5cclxuXHRsZXQgdmFsVG9Qb3NYLCB2YWxUb1Bvc1k7XHJcblxyXG5cdGlmIChzY2FsZVgub3JpID09IDApIHtcclxuXHRcdGFkZENsYXNzKHJvb3QsIE9SSV9IWik7XHJcblx0XHR2YWxUb1Bvc1ggPSBnZXRIUG9zO1xyXG5cdFx0dmFsVG9Qb3NZID0gZ2V0VlBvcztcclxuXHRcdC8qXHJcblx0XHR1cGRPcmlEaW1zID0gKCkgPT4ge1xyXG5cdFx0XHR4RGltQ2FuID0gcGxvdFdpZDtcclxuXHRcdFx0eE9mZkNhbiA9IHBsb3RMZnQ7XHJcblx0XHRcdHlEaW1DYW4gPSBwbG90SGd0O1xyXG5cdFx0XHR5T2ZmQ2FuID0gcGxvdFRvcDtcclxuXHJcblx0XHRcdHhEaW1Dc3MgPSBwbG90V2lkQ3NzO1xyXG5cdFx0XHR4T2ZmQ3NzID0gcGxvdExmdENzcztcclxuXHRcdFx0eURpbUNzcyA9IHBsb3RIZ3RDc3M7XHJcblx0XHRcdHlPZmZDc3MgPSBwbG90VG9wQ3NzO1xyXG5cdFx0fTtcclxuXHRcdCovXHJcblx0fVxyXG5cdGVsc2Uge1xyXG5cdFx0YWRkQ2xhc3Mocm9vdCwgT1JJX1ZUKTtcclxuXHRcdHZhbFRvUG9zWCA9IGdldFZQb3M7XHJcblx0XHR2YWxUb1Bvc1kgPSBnZXRIUG9zO1xyXG5cdFx0LypcclxuXHRcdHVwZE9yaURpbXMgPSAoKSA9PiB7XHJcblx0XHRcdHhEaW1DYW4gPSBwbG90SGd0O1xyXG5cdFx0XHR4T2ZmQ2FuID0gcGxvdFRvcDtcclxuXHRcdFx0eURpbUNhbiA9IHBsb3RXaWQ7XHJcblx0XHRcdHlPZmZDYW4gPSBwbG90TGZ0O1xyXG5cclxuXHRcdFx0eERpbUNzcyA9IHBsb3RIZ3RDc3M7XHJcblx0XHRcdHhPZmZDc3MgPSBwbG90VG9wQ3NzO1xyXG5cdFx0XHR5RGltQ3NzID0gcGxvdFdpZENzcztcclxuXHRcdFx0eU9mZkNzcyA9IHBsb3RMZnRDc3M7XHJcblx0XHR9O1xyXG5cdFx0Ki9cclxuXHR9XHJcblxyXG5cdGNvbnN0IHBlbmRTY2FsZXMgPSB7fTtcclxuXHJcblx0Ly8gZXhwbGljaXRseS1zZXQgaW5pdGlhbCBzY2FsZXNcclxuXHRmb3IgKGxldCBrIGluIHNjYWxlcykge1xyXG5cdFx0bGV0IHNjID0gc2NhbGVzW2tdO1xyXG5cclxuXHRcdGlmIChzYy5taW4gIT0gbnVsbCB8fCBzYy5tYXggIT0gbnVsbCkge1xyXG5cdFx0XHRwZW5kU2NhbGVzW2tdID0ge21pbjogc2MubWluLCBtYXg6IHNjLm1heH07XHJcblx0XHRcdHNjLm1pbiA9IHNjLm1heCA9IG51bGw7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuLy9cdHNlbGYudHogPSBvcHRzLnR6IHx8IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZTtcclxuXHRjb25zdCBfdHpEYXRlICA9IChvcHRzLnR6RGF0ZSB8fCAodHMgPT4gbmV3IERhdGUocm91bmQodHMgLyBtcykpKSk7XHJcblx0Y29uc3QgX2ZtdERhdGUgPSAob3B0cy5mbXREYXRlIHx8IGZtdERhdGUpO1xyXG5cclxuXHRjb25zdCBfdGltZUF4aXNTcGxpdHMgPSAobXMgPT0gMSA/IHRpbWVBeGlzU3BsaXRzTXMoX3R6RGF0ZSkgOiB0aW1lQXhpc1NwbGl0c1MoX3R6RGF0ZSkpO1xyXG5cdGNvbnN0IF90aW1lQXhpc1ZhbHMgICA9IHRpbWVBeGlzVmFscyhfdHpEYXRlLCB0aW1lQXhpc1N0YW1wcygobXMgPT0gMSA/IF90aW1lQXhpc1N0YW1wc01zIDogX3RpbWVBeGlzU3RhbXBzUyksIF9mbXREYXRlKSk7XHJcblx0Y29uc3QgX3RpbWVTZXJpZXNWYWwgID0gdGltZVNlcmllc1ZhbChfdHpEYXRlLCB0aW1lU2VyaWVzU3RhbXAoX3RpbWVTZXJpZXNTdGFtcCwgX2ZtdERhdGUpKTtcclxuXHJcblx0Y29uc3QgYWN0aXZlSWR4cyA9IFtdO1xyXG5cclxuXHRjb25zdCBsZWdlbmQgICAgID0gKHNlbGYubGVnZW5kID0gYXNzaWduKHt9LCBsZWdlbmRPcHRzLCBvcHRzLmxlZ2VuZCkpO1xyXG5cdGNvbnN0IHNob3dMZWdlbmQgPSBsZWdlbmQuc2hvdztcclxuXHRjb25zdCBtYXJrZXJzICAgID0gbGVnZW5kLm1hcmtlcnM7XHJcblxyXG5cdHtcclxuXHRcdGxlZ2VuZC5pZHhzID0gYWN0aXZlSWR4cztcclxuXHJcblx0XHRtYXJrZXJzLndpZHRoICA9IGZuT3JTZWxmKG1hcmtlcnMud2lkdGgpO1xyXG5cdFx0bWFya2Vycy5kYXNoICAgPSBmbk9yU2VsZihtYXJrZXJzLmRhc2gpO1xyXG5cdFx0bWFya2Vycy5zdHJva2UgPSBmbk9yU2VsZihtYXJrZXJzLnN0cm9rZSk7XHJcblx0XHRtYXJrZXJzLmZpbGwgICA9IGZuT3JTZWxmKG1hcmtlcnMuZmlsbCk7XHJcblx0fVxyXG5cclxuXHRsZXQgbGVnZW5kVGFibGU7XHJcblx0bGV0IGxlZ2VuZEhlYWQ7XHJcblx0bGV0IGxlZ2VuZEJvZHk7XHJcblx0bGV0IGxlZ2VuZFJvd3MgPSBbXTtcclxuXHRsZXQgbGVnZW5kQ2VsbHMgPSBbXTtcclxuXHRsZXQgbGVnZW5kQ29scztcclxuXHRsZXQgbXVsdGlWYWxMZWdlbmQgPSBmYWxzZTtcclxuXHRsZXQgTlVMTF9MRUdFTkRfVkFMVUVTID0ge307XHJcblxyXG5cdGlmIChsZWdlbmQubGl2ZSkge1xyXG5cdFx0Y29uc3QgZ2V0TXVsdGlWYWxzID0gc2VyaWVzWzFdID8gc2VyaWVzWzFdLnZhbHVlcyA6IG51bGw7XHJcblx0XHRtdWx0aVZhbExlZ2VuZCA9IGdldE11bHRpVmFscyAhPSBudWxsO1xyXG5cdFx0bGVnZW5kQ29scyA9IG11bHRpVmFsTGVnZW5kID8gZ2V0TXVsdGlWYWxzKHNlbGYsIDEsIDApIDoge186IDB9O1xyXG5cclxuXHRcdGZvciAobGV0IGsgaW4gbGVnZW5kQ29scylcclxuXHRcdFx0TlVMTF9MRUdFTkRfVkFMVUVTW2tdID0gTEVHRU5EX0RJU1A7XHJcblx0fVxyXG5cclxuXHRpZiAoc2hvd0xlZ2VuZCkge1xyXG5cdFx0bGVnZW5kVGFibGUgPSBwbGFjZVRhZyhcInRhYmxlXCIsIExFR0VORCwgcm9vdCk7XHJcblx0XHRsZWdlbmRCb2R5ID0gcGxhY2VUYWcoXCJ0Ym9keVwiLCBudWxsLCBsZWdlbmRUYWJsZSk7XHJcblxyXG5cdFx0Ly8gYWxsb3dzIGxlZ2VuZCB0byBiZSBtb3ZlZCBvdXQgb2Ygcm9vdFxyXG5cdFx0bGVnZW5kLm1vdW50KHNlbGYsIGxlZ2VuZFRhYmxlKTtcclxuXHJcblx0XHRpZiAobXVsdGlWYWxMZWdlbmQpIHtcclxuXHRcdFx0bGVnZW5kSGVhZCA9IHBsYWNlVGFnKFwidGhlYWRcIiwgbnVsbCwgbGVnZW5kVGFibGUsIGxlZ2VuZEJvZHkpO1xyXG5cclxuXHRcdFx0bGV0IGhlYWQgPSBwbGFjZVRhZyhcInRyXCIsIG51bGwsIGxlZ2VuZEhlYWQpO1xyXG5cdFx0XHRwbGFjZVRhZyhcInRoXCIsIG51bGwsIGhlYWQpO1xyXG5cclxuXHRcdFx0Zm9yICh2YXIga2V5IGluIGxlZ2VuZENvbHMpXHJcblx0XHRcdFx0cGxhY2VUYWcoXCJ0aFwiLCBMRUdFTkRfTEFCRUwsIGhlYWQpLnRleHRDb250ZW50ID0ga2V5O1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGFkZENsYXNzKGxlZ2VuZFRhYmxlLCBMRUdFTkRfSU5MSU5FKTtcclxuXHRcdFx0bGVnZW5kLmxpdmUgJiYgYWRkQ2xhc3MobGVnZW5kVGFibGUsIExFR0VORF9MSVZFKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGNvbnN0IHNvbiAgPSB7c2hvdzogdHJ1ZX07XHJcblx0Y29uc3Qgc29mZiA9IHtzaG93OiBmYWxzZX07XHJcblxyXG5cdGZ1bmN0aW9uIGluaXRMZWdlbmRSb3cocywgaSkge1xyXG5cdFx0aWYgKGkgPT0gMCAmJiAobXVsdGlWYWxMZWdlbmQgfHwgIWxlZ2VuZC5saXZlIHx8IG1vZGUgPT0gMikpXHJcblx0XHRcdHJldHVybiBudWxsTnVsbFR1cGxlO1xyXG5cclxuXHRcdGxldCBjZWxscyA9IFtdO1xyXG5cclxuXHRcdGxldCByb3cgPSBwbGFjZVRhZyhcInRyXCIsIExFR0VORF9TRVJJRVMsIGxlZ2VuZEJvZHksIGxlZ2VuZEJvZHkuY2hpbGROb2Rlc1tpXSk7XHJcblxyXG5cdFx0YWRkQ2xhc3Mocm93LCBzLmNsYXNzKTtcclxuXHJcblx0XHRpZiAoIXMuc2hvdylcclxuXHRcdFx0YWRkQ2xhc3Mocm93LCBPRkYpO1xyXG5cclxuXHRcdGxldCBsYWJlbCA9IHBsYWNlVGFnKFwidGhcIiwgbnVsbCwgcm93KTtcclxuXHJcblx0XHRpZiAobWFya2Vycy5zaG93KSB7XHJcblx0XHRcdGxldCBpbmRpYyA9IHBsYWNlRGl2KExFR0VORF9NQVJLRVIsIGxhYmVsKTtcclxuXHJcblx0XHRcdGlmIChpID4gMCkge1xyXG5cdFx0XHRcdGxldCB3aWR0aCAgPSBtYXJrZXJzLndpZHRoKHNlbGYsIGkpO1xyXG5cclxuXHRcdFx0XHRpZiAod2lkdGgpXHJcblx0XHRcdFx0XHRpbmRpYy5zdHlsZS5ib3JkZXIgPSB3aWR0aCArIFwicHggXCIgKyBtYXJrZXJzLmRhc2goc2VsZiwgaSkgKyBcIiBcIiArIG1hcmtlcnMuc3Ryb2tlKHNlbGYsIGkpO1xyXG5cclxuXHRcdFx0XHRpbmRpYy5zdHlsZS5iYWNrZ3JvdW5kID0gbWFya2Vycy5maWxsKHNlbGYsIGkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHRleHQgPSBwbGFjZURpdihMRUdFTkRfTEFCRUwsIGxhYmVsKTtcclxuXHRcdHRleHQudGV4dENvbnRlbnQgPSBzLmxhYmVsO1xyXG5cclxuXHRcdGlmIChpID4gMCkge1xyXG5cdFx0XHRpZiAoIW1hcmtlcnMuc2hvdylcclxuXHRcdFx0XHR0ZXh0LnN0eWxlLmNvbG9yID0gcy53aWR0aCA+IDAgPyBtYXJrZXJzLnN0cm9rZShzZWxmLCBpKSA6IG1hcmtlcnMuZmlsbChzZWxmLCBpKTtcclxuXHJcblx0XHRcdG9uTW91c2UoXCJjbGlja1wiLCBsYWJlbCwgZSA9PiB7XHJcblx0XHRcdFx0aWYgKGN1cnNvci5fbG9jaylcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0c2V0Q3Vyc29yRXZlbnQoZSk7XHJcblxyXG5cdFx0XHRcdGxldCBzZXJpZXNJZHggPSBzZXJpZXMuaW5kZXhPZihzKTtcclxuXHJcblx0XHRcdFx0aWYgKChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSAhPSBsZWdlbmQuaXNvbGF0ZSkge1xyXG5cdFx0XHRcdFx0Ly8gaWYgYW55IG90aGVyIHNlcmllcyBpcyBzaG93biwgaXNvbGF0ZSB0aGlzIG9uZS4gZWxzZSBzaG93IGFsbFxyXG5cdFx0XHRcdFx0bGV0IGlzb2xhdGUgPSBzZXJpZXMuc29tZSgocywgaSkgPT4gaSA+IDAgJiYgaSAhPSBzZXJpZXNJZHggJiYgcy5zaG93KTtcclxuXHJcblx0XHRcdFx0XHRzZXJpZXMuZm9yRWFjaCgocywgaSkgPT4ge1xyXG5cdFx0XHRcdFx0XHRpID4gMCAmJiBzZXRTZXJpZXMoaSwgaXNvbGF0ZSA/IChpID09IHNlcmllc0lkeCA/IHNvbiA6IHNvZmYpIDogc29uLCB0cnVlLCBzeW5jT3B0cy5zZXRTZXJpZXMpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdHNldFNlcmllcyhzZXJpZXNJZHgsIHtzaG93OiAhcy5zaG93fSwgdHJ1ZSwgc3luY09wdHMuc2V0U2VyaWVzKTtcclxuXHRcdFx0fSwgZmFsc2UpO1xyXG5cclxuXHRcdFx0aWYgKGN1cnNvckZvY3VzKSB7XHJcblx0XHRcdFx0b25Nb3VzZShtb3VzZWVudGVyLCBsYWJlbCwgZSA9PiB7XHJcblx0XHRcdFx0XHRpZiAoY3Vyc29yLl9sb2NrKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0c2V0Q3Vyc29yRXZlbnQoZSk7XHJcblxyXG5cdFx0XHRcdFx0c2V0U2VyaWVzKHNlcmllcy5pbmRleE9mKHMpLCBGT0NVU19UUlVFLCB0cnVlLCBzeW5jT3B0cy5zZXRTZXJpZXMpO1xyXG5cdFx0XHRcdH0sIGZhbHNlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGtleSBpbiBsZWdlbmRDb2xzKSB7XHJcblx0XHRcdGxldCB2ID0gcGxhY2VUYWcoXCJ0ZFwiLCBMRUdFTkRfVkFMVUUsIHJvdyk7XHJcblx0XHRcdHYudGV4dENvbnRlbnQgPSBcIi0tXCI7XHJcblx0XHRcdGNlbGxzLnB1c2godik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFtyb3csIGNlbGxzXTtcclxuXHR9XHJcblxyXG5cdGNvbnN0IG1vdXNlTGlzdGVuZXJzID0gbmV3IE1hcCgpO1xyXG5cclxuXHRmdW5jdGlvbiBvbk1vdXNlKGV2LCB0YXJnLCBmbiwgb25seVRhcmcgPSB0cnVlKSB7XHJcblx0XHRjb25zdCB0YXJnTGlzdGVuZXJzID0gbW91c2VMaXN0ZW5lcnMuZ2V0KHRhcmcpIHx8IHt9O1xyXG5cdFx0Y29uc3QgbGlzdGVuZXIgPSBjdXJzb3IuYmluZFtldl0oc2VsZiwgdGFyZywgZm4sIG9ubHlUYXJnKTtcclxuXHJcblx0XHRpZiAobGlzdGVuZXIpIHtcclxuXHRcdFx0b24oZXYsIHRhcmcsIHRhcmdMaXN0ZW5lcnNbZXZdID0gbGlzdGVuZXIpO1xyXG5cdFx0XHRtb3VzZUxpc3RlbmVycy5zZXQodGFyZywgdGFyZ0xpc3RlbmVycyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvZmZNb3VzZShldiwgdGFyZywgZm4pIHtcclxuXHRcdGNvbnN0IHRhcmdMaXN0ZW5lcnMgPSBtb3VzZUxpc3RlbmVycy5nZXQodGFyZykgfHwge307XHJcblxyXG5cdFx0Zm9yIChsZXQgayBpbiB0YXJnTGlzdGVuZXJzKSB7XHJcblx0XHRcdGlmIChldiA9PSBudWxsIHx8IGsgPT0gZXYpIHtcclxuXHRcdFx0XHRvZmYoaywgdGFyZywgdGFyZ0xpc3RlbmVyc1trXSk7XHJcblx0XHRcdFx0ZGVsZXRlIHRhcmdMaXN0ZW5lcnNba107XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZXYgPT0gbnVsbClcclxuXHRcdFx0bW91c2VMaXN0ZW5lcnMuZGVsZXRlKHRhcmcpO1xyXG5cdH1cclxuXHJcblx0bGV0IGZ1bGxXaWRDc3MgPSAwO1xyXG5cdGxldCBmdWxsSGd0Q3NzID0gMDtcclxuXHJcblx0bGV0IHBsb3RXaWRDc3MgPSAwO1xyXG5cdGxldCBwbG90SGd0Q3NzID0gMDtcclxuXHJcblx0Ly8gcGxvdCBtYXJnaW5zIHRvIGFjY291bnQgZm9yIGF4ZXNcclxuXHRsZXQgcGxvdExmdENzcyA9IDA7XHJcblx0bGV0IHBsb3RUb3BDc3MgPSAwO1xyXG5cclxuXHRsZXQgcGxvdExmdCA9IDA7XHJcblx0bGV0IHBsb3RUb3AgPSAwO1xyXG5cdGxldCBwbG90V2lkID0gMDtcclxuXHRsZXQgcGxvdEhndCA9IDA7XHJcblxyXG5cdHNlbGYuYmJveCA9IHt9O1xyXG5cclxuXHRsZXQgc2hvdWxkU2V0U2NhbGVzID0gZmFsc2U7XHJcblx0bGV0IHNob3VsZFNldFNpemUgPSBmYWxzZTtcclxuXHRsZXQgc2hvdWxkQ29udmVyZ2VTaXplID0gZmFsc2U7XHJcblx0bGV0IHNob3VsZFNldEN1cnNvciA9IGZhbHNlO1xyXG5cdGxldCBzaG91bGRTZXRTZWxlY3QgPSBmYWxzZTtcclxuXHRsZXQgc2hvdWxkU2V0TGVnZW5kID0gZmFsc2U7XHJcblxyXG5cdGZ1bmN0aW9uIF9zZXRTaXplKHdpZHRoLCBoZWlnaHQsIGZvcmNlKSB7XHJcblx0XHRpZiAoZm9yY2UgfHwgKHdpZHRoICE9IHNlbGYud2lkdGggfHwgaGVpZ2h0ICE9IHNlbGYuaGVpZ2h0KSlcclxuXHRcdFx0Y2FsY1NpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG5cdFx0cmVzZXRZU2VyaWVzKGZhbHNlKTtcclxuXHJcblx0XHRzaG91bGRDb252ZXJnZVNpemUgPSB0cnVlO1xyXG5cdFx0c2hvdWxkU2V0U2l6ZSA9IHRydWU7XHJcblxyXG5cdFx0aWYgKGN1cnNvci5sZWZ0ID49IDApXHJcblx0XHRcdHNob3VsZFNldEN1cnNvciA9IHNob3VsZFNldExlZ2VuZCA9IHRydWU7XHJcblxyXG5cdFx0Y29tbWl0KCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjYWxjU2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcblx0Ly9cdGxvZyhcImNhbGNTaXplKClcIiwgYXJndW1lbnRzKTtcclxuXHJcblx0XHRzZWxmLndpZHRoICA9IGZ1bGxXaWRDc3MgPSBwbG90V2lkQ3NzID0gd2lkdGg7XHJcblx0XHRzZWxmLmhlaWdodCA9IGZ1bGxIZ3RDc3MgPSBwbG90SGd0Q3NzID0gaGVpZ2h0O1xyXG5cdFx0cGxvdExmdENzcyAgPSBwbG90VG9wQ3NzID0gMDtcclxuXHJcblx0XHRjYWxjUGxvdFJlY3QoKTtcclxuXHRcdGNhbGNBeGVzUmVjdHMoKTtcclxuXHJcblx0XHRsZXQgYmIgPSBzZWxmLmJib3g7XHJcblxyXG5cdFx0cGxvdExmdCA9IGJiLmxlZnQgICA9IGluY3JSb3VuZChwbG90TGZ0Q3NzICogcHhSYXRpbywgMC41KTtcclxuXHRcdHBsb3RUb3AgPSBiYi50b3AgICAgPSBpbmNyUm91bmQocGxvdFRvcENzcyAqIHB4UmF0aW8sIDAuNSk7XHJcblx0XHRwbG90V2lkID0gYmIud2lkdGggID0gaW5jclJvdW5kKHBsb3RXaWRDc3MgKiBweFJhdGlvLCAwLjUpO1xyXG5cdFx0cGxvdEhndCA9IGJiLmhlaWdodCA9IGluY3JSb3VuZChwbG90SGd0Q3NzICogcHhSYXRpbywgMC41KTtcclxuXHJcblx0Ly9cdHVwZE9yaURpbXMoKTtcclxuXHR9XHJcblxyXG5cdC8vIGVuc3VyZXMgc2l6ZSBjYWxjIGNvbnZlcmdlbmNlXHJcblx0Y29uc3QgQ1lDTEVfTElNSVQgPSAzO1xyXG5cclxuXHRmdW5jdGlvbiBjb252ZXJnZVNpemUoKSB7XHJcblx0XHRsZXQgY29udmVyZ2VkID0gZmFsc2U7XHJcblxyXG5cdFx0bGV0IGN5Y2xlTnVtID0gMDtcclxuXHJcblx0XHR3aGlsZSAoIWNvbnZlcmdlZCkge1xyXG5cdFx0XHRjeWNsZU51bSsrO1xyXG5cclxuXHRcdFx0bGV0IGF4ZXNDb252ZXJnZWQgPSBheGVzQ2FsYyhjeWNsZU51bSk7XHJcblx0XHRcdGxldCBwYWRkaW5nQ29udmVyZ2VkID0gcGFkZGluZ0NhbGMoY3ljbGVOdW0pO1xyXG5cclxuXHRcdFx0Y29udmVyZ2VkID0gY3ljbGVOdW0gPT0gQ1lDTEVfTElNSVQgfHwgKGF4ZXNDb252ZXJnZWQgJiYgcGFkZGluZ0NvbnZlcmdlZCk7XHJcblxyXG5cdFx0XHRpZiAoIWNvbnZlcmdlZCkge1xyXG5cdFx0XHRcdGNhbGNTaXplKHNlbGYud2lkdGgsIHNlbGYuaGVpZ2h0KTtcclxuXHRcdFx0XHRzaG91bGRTZXRTaXplID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0U2l6ZSh7d2lkdGgsIGhlaWdodH0pIHtcclxuXHRcdF9zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cdH1cclxuXHJcblx0c2VsZi5zZXRTaXplID0gc2V0U2l6ZTtcclxuXHJcblx0Ly8gYWNjdW11bGF0ZSBheGlzIG9mZnNldHMsIHJlZHVjZSBjYW52YXMgd2lkdGhcclxuXHRmdW5jdGlvbiBjYWxjUGxvdFJlY3QoKSB7XHJcblx0XHQvLyBlYXNlbWVudHMgZm9yIGVkZ2UgbGFiZWxzXHJcblx0XHRsZXQgaGFzVG9wQXhpcyA9IGZhbHNlO1xyXG5cdFx0bGV0IGhhc0J0bUF4aXMgPSBmYWxzZTtcclxuXHRcdGxldCBoYXNSZ3RBeGlzID0gZmFsc2U7XHJcblx0XHRsZXQgaGFzTGZ0QXhpcyA9IGZhbHNlO1xyXG5cclxuXHRcdGF4ZXMuZm9yRWFjaCgoYXhpcywgaSkgPT4ge1xyXG5cdFx0XHRpZiAoYXhpcy5zaG93ICYmIGF4aXMuX3Nob3cpIHtcclxuXHRcdFx0XHRsZXQge3NpZGUsIF9zaXplfSA9IGF4aXM7XHJcblx0XHRcdFx0bGV0IGlzVnQgPSBzaWRlICUgMjtcclxuXHRcdFx0XHRsZXQgbGFiZWxTaXplID0gYXhpcy5sYWJlbCAhPSBudWxsID8gYXhpcy5sYWJlbFNpemUgOiAwO1xyXG5cclxuXHRcdFx0XHRsZXQgZnVsbFNpemUgPSBfc2l6ZSArIGxhYmVsU2l6ZTtcclxuXHJcblx0XHRcdFx0aWYgKGZ1bGxTaXplID4gMCkge1xyXG5cdFx0XHRcdFx0aWYgKGlzVnQpIHtcclxuXHRcdFx0XHRcdFx0cGxvdFdpZENzcyAtPSBmdWxsU2l6ZTtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChzaWRlID09IDMpIHtcclxuXHRcdFx0XHRcdFx0XHRwbG90TGZ0Q3NzICs9IGZ1bGxTaXplO1xyXG5cdFx0XHRcdFx0XHRcdGhhc0xmdEF4aXMgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0XHRoYXNSZ3RBeGlzID0gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRwbG90SGd0Q3NzIC09IGZ1bGxTaXplO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKHNpZGUgPT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdHBsb3RUb3BDc3MgKz0gZnVsbFNpemU7XHJcblx0XHRcdFx0XHRcdFx0aGFzVG9wQXhpcyA9IHRydWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRcdGhhc0J0bUF4aXMgPSB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0c2lkZXNXaXRoQXhlc1swXSA9IGhhc1RvcEF4aXM7XHJcblx0XHRzaWRlc1dpdGhBeGVzWzFdID0gaGFzUmd0QXhpcztcclxuXHRcdHNpZGVzV2l0aEF4ZXNbMl0gPSBoYXNCdG1BeGlzO1xyXG5cdFx0c2lkZXNXaXRoQXhlc1szXSA9IGhhc0xmdEF4aXM7XHJcblxyXG5cdFx0Ly8gaHogcGFkZGluZ1xyXG5cdFx0cGxvdFdpZENzcyAtPSBfcGFkZGluZ1sxXSArIF9wYWRkaW5nWzNdO1xyXG5cdFx0cGxvdExmdENzcyArPSBfcGFkZGluZ1szXTtcclxuXHJcblx0XHQvLyB2dCBwYWRkaW5nXHJcblx0XHRwbG90SGd0Q3NzIC09IF9wYWRkaW5nWzJdICsgX3BhZGRpbmdbMF07XHJcblx0XHRwbG90VG9wQ3NzICs9IF9wYWRkaW5nWzBdO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY2FsY0F4ZXNSZWN0cygpIHtcclxuXHRcdC8vIHdpbGwgYWNjdW0gK1xyXG5cdFx0bGV0IG9mZjEgPSBwbG90TGZ0Q3NzICsgcGxvdFdpZENzcztcclxuXHRcdGxldCBvZmYyID0gcGxvdFRvcENzcyArIHBsb3RIZ3RDc3M7XHJcblx0XHQvLyB3aWxsIGFjY3VtIC1cclxuXHRcdGxldCBvZmYzID0gcGxvdExmdENzcztcclxuXHRcdGxldCBvZmYwID0gcGxvdFRvcENzcztcclxuXHJcblx0XHRmdW5jdGlvbiBpbmNyT2Zmc2V0KHNpZGUsIHNpemUpIHtcclxuXHRcdFx0c3dpdGNoIChzaWRlKSB7XHJcblx0XHRcdFx0Y2FzZSAxOiBvZmYxICs9IHNpemU7IHJldHVybiBvZmYxIC0gc2l6ZTtcclxuXHRcdFx0XHRjYXNlIDI6IG9mZjIgKz0gc2l6ZTsgcmV0dXJuIG9mZjIgLSBzaXplO1xyXG5cdFx0XHRcdGNhc2UgMzogb2ZmMyAtPSBzaXplOyByZXR1cm4gb2ZmMyArIHNpemU7XHJcblx0XHRcdFx0Y2FzZSAwOiBvZmYwIC09IHNpemU7IHJldHVybiBvZmYwICsgc2l6ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGF4ZXMuZm9yRWFjaCgoYXhpcywgaSkgPT4ge1xyXG5cdFx0XHRpZiAoYXhpcy5zaG93ICYmIGF4aXMuX3Nob3cpIHtcclxuXHRcdFx0XHRsZXQgc2lkZSA9IGF4aXMuc2lkZTtcclxuXHJcblx0XHRcdFx0YXhpcy5fcG9zID0gaW5jck9mZnNldChzaWRlLCBheGlzLl9zaXplKTtcclxuXHJcblx0XHRcdFx0aWYgKGF4aXMubGFiZWwgIT0gbnVsbClcclxuXHRcdFx0XHRcdGF4aXMuX2xwb3MgPSBpbmNyT2Zmc2V0KHNpZGUsIGF4aXMubGFiZWxTaXplKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRjb25zdCBjdXJzb3IgPSBzZWxmLmN1cnNvciA9IGFzc2lnbih7fSwgY3Vyc29yT3B0cywge2RyYWc6IHt5OiBtb2RlID09IDJ9fSwgb3B0cy5jdXJzb3IpO1xyXG5cdGNvbnN0IHNldEN1cnNvckV2ZW50ID0gZSA9PiB7IGN1cnNvci5ldmVudCA9IGU7IH07XHJcblxyXG5cdGN1cnNvci5pZHhzID0gYWN0aXZlSWR4cztcclxuXHJcblx0Y3Vyc29yLl9sb2NrID0gZmFsc2U7XHJcblxyXG5cdGxldCBwb2ludHMgPSBjdXJzb3IucG9pbnRzO1xyXG5cclxuXHRwb2ludHMuc2hvdyAgID0gZm5PclNlbGYocG9pbnRzLnNob3cpO1xyXG5cdHBvaW50cy5zaXplICAgPSBmbk9yU2VsZihwb2ludHMuc2l6ZSk7XHJcblx0cG9pbnRzLnN0cm9rZSA9IGZuT3JTZWxmKHBvaW50cy5zdHJva2UpO1xyXG5cdHBvaW50cy53aWR0aCAgPSBmbk9yU2VsZihwb2ludHMud2lkdGgpO1xyXG5cdHBvaW50cy5maWxsICAgPSBmbk9yU2VsZihwb2ludHMuZmlsbCk7XHJcblxyXG5cdGNvbnN0IGZvY3VzID0gc2VsZi5mb2N1cyA9IGFzc2lnbih7fSwgb3B0cy5mb2N1cyB8fCB7YWxwaGE6IDAuM30sIGN1cnNvci5mb2N1cyk7XHJcblxyXG5cdGNvbnN0IGN1cnNvckZvY3VzID0gZm9jdXMucHJveCA+PSAwO1xyXG5cclxuXHQvLyBzZXJpZXMtaW50ZXJzZWN0aW9uIG1hcmtlcnNcclxuXHRsZXQgY3Vyc29yUHRzID0gW251bGxdO1xyXG5cclxuXHRmdW5jdGlvbiBpbml0Q3Vyc29yUHQocywgc2kpIHtcclxuXHRcdGlmIChzaSA+IDApIHtcclxuXHRcdFx0bGV0IHB0ID0gY3Vyc29yLnBvaW50cy5zaG93KHNlbGYsIHNpKTtcclxuXHJcblx0XHRcdGlmIChwdCkge1xyXG5cdFx0XHRcdGFkZENsYXNzKHB0LCBDVVJTT1JfUFQpO1xyXG5cdFx0XHRcdGFkZENsYXNzKHB0LCBzLmNsYXNzKTtcclxuXHRcdFx0XHRlbFRyYW5zKHB0LCAtMTAsIC0xMCwgcGxvdFdpZENzcywgcGxvdEhndENzcyk7XHJcblx0XHRcdFx0b3Zlci5pbnNlcnRCZWZvcmUocHQsIGN1cnNvclB0c1tzaV0pO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gcHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGluaXRTZXJpZXMocywgaSkge1xyXG5cdFx0aWYgKG1vZGUgPT0gMSB8fCBpID4gMCkge1xyXG5cdFx0XHRsZXQgaXNUaW1lID0gbW9kZSA9PSAxICYmIHNjYWxlc1tzLnNjYWxlXS50aW1lO1xyXG5cclxuXHRcdFx0bGV0IHN2ID0gcy52YWx1ZTtcclxuXHRcdFx0cy52YWx1ZSA9IGlzVGltZSA/IChpc1N0cihzdikgPyB0aW1lU2VyaWVzVmFsKF90ekRhdGUsIHRpbWVTZXJpZXNTdGFtcChzdiwgX2ZtdERhdGUpKSA6IHN2IHx8IF90aW1lU2VyaWVzVmFsKSA6IHN2IHx8IG51bVNlcmllc1ZhbDtcclxuXHRcdFx0cy5sYWJlbCA9IHMubGFiZWwgfHwgKGlzVGltZSA/IHRpbWVTZXJpZXNMYWJlbCA6IG51bVNlcmllc0xhYmVsKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaSA+IDApIHtcclxuXHRcdFx0cy53aWR0aCAgPSBzLndpZHRoID09IG51bGwgPyAxIDogcy53aWR0aDtcclxuXHRcdFx0cy5wYXRocyAgPSBzLnBhdGhzIHx8IGxpbmVhclBhdGggfHwgcmV0TnVsbDtcclxuXHRcdFx0cy5maWxsVG8gPSBmbk9yU2VsZihzLmZpbGxUbyB8fCBzZXJpZXNGaWxsVG8pO1xyXG5cdFx0XHRzLnB4QWxpZ24gPSAraWZOdWxsKHMucHhBbGlnbiwgcHhBbGlnbik7XHJcblx0XHRcdHMucHhSb3VuZCA9IHB4Um91bmRHZW4ocy5weEFsaWduKTtcclxuXHJcblx0XHRcdHMuc3Ryb2tlID0gZm5PclNlbGYocy5zdHJva2UgfHwgbnVsbCk7XHJcblx0XHRcdHMuZmlsbCAgID0gZm5PclNlbGYocy5maWxsIHx8IG51bGwpO1xyXG5cdFx0XHRzLl9zdHJva2UgPSBzLl9maWxsID0gcy5fcGF0aHMgPSBzLl9mb2N1cyA9IG51bGw7XHJcblxyXG5cdFx0XHRsZXQgX3B0RGlhID0gcHREaWEobWF4KDEsIHMud2lkdGgpLCAxKTtcclxuXHRcdFx0bGV0IHBvaW50cyA9IHMucG9pbnRzID0gYXNzaWduKHt9LCB7XHJcblx0XHRcdFx0c2l6ZTogX3B0RGlhLFxyXG5cdFx0XHRcdHdpZHRoOiBtYXgoMSwgX3B0RGlhICogLjIpLFxyXG5cdFx0XHRcdHN0cm9rZTogcy5zdHJva2UsXHJcblx0XHRcdFx0c3BhY2U6IF9wdERpYSAqIDIsXHJcblx0XHRcdFx0cGF0aHM6IHBvaW50c1BhdGgsXHJcblx0XHRcdFx0X3N0cm9rZTogbnVsbCxcclxuXHRcdFx0XHRfZmlsbDogbnVsbCxcclxuXHRcdFx0fSwgcy5wb2ludHMpO1xyXG5cdFx0XHRwb2ludHMuc2hvdyAgID0gZm5PclNlbGYocG9pbnRzLnNob3cpO1xyXG5cdFx0XHRwb2ludHMuZmlsdGVyID0gZm5PclNlbGYocG9pbnRzLmZpbHRlcik7XHJcblx0XHRcdHBvaW50cy5maWxsICAgPSBmbk9yU2VsZihwb2ludHMuZmlsbCk7XHJcblx0XHRcdHBvaW50cy5zdHJva2UgPSBmbk9yU2VsZihwb2ludHMuc3Ryb2tlKTtcclxuXHRcdFx0cG9pbnRzLnBhdGhzICA9IGZuT3JTZWxmKHBvaW50cy5wYXRocyk7XHJcblx0XHRcdHBvaW50cy5weEFsaWduID0gcy5weEFsaWduO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzaG93TGVnZW5kKSB7XHJcblx0XHRcdGxldCByb3dDZWxscyA9IGluaXRMZWdlbmRSb3cocywgaSk7XHJcblx0XHRcdGxlZ2VuZFJvd3Muc3BsaWNlKGksIDAsIHJvd0NlbGxzWzBdKTtcclxuXHRcdFx0bGVnZW5kQ2VsbHMuc3BsaWNlKGksIDAsIHJvd0NlbGxzWzFdKTtcclxuXHRcdFx0bGVnZW5kLnZhbHVlcy5wdXNoKG51bGwpO1x0Ly8gTlVMTF9MRUdFTkRfVkFMUyBub3QgeWV0IGF2aWwgaGVyZSA6KFxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjdXJzb3Iuc2hvdykge1xyXG5cdFx0XHRhY3RpdmVJZHhzLnNwbGljZShpLCAwLCBudWxsKTtcclxuXHJcblx0XHRcdGxldCBwdCA9IGluaXRDdXJzb3JQdChzLCBpKTtcclxuXHRcdFx0cHQgJiYgY3Vyc29yUHRzLnNwbGljZShpLCAwLCBwdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZmlyZShcImFkZFNlcmllc1wiLCBpKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFkZFNlcmllcyhvcHRzLCBzaSkge1xyXG5cdFx0c2kgPSBzaSA9PSBudWxsID8gc2VyaWVzLmxlbmd0aCA6IHNpO1xyXG5cclxuXHRcdG9wdHMgPSBtb2RlID09IDEgPyBzZXREZWZhdWx0KG9wdHMsIHNpLCB4U2VyaWVzT3B0cywgeVNlcmllc09wdHMpIDogc2V0RGVmYXVsdChvcHRzLCBzaSwgbnVsbCwgeHlTZXJpZXNPcHRzKTtcclxuXHJcblx0XHRzZXJpZXMuc3BsaWNlKHNpLCAwLCBvcHRzKTtcclxuXHRcdGluaXRTZXJpZXMoc2VyaWVzW3NpXSwgc2kpO1xyXG5cdH1cclxuXHJcblx0c2VsZi5hZGRTZXJpZXMgPSBhZGRTZXJpZXM7XHJcblxyXG5cdGZ1bmN0aW9uIGRlbFNlcmllcyhpKSB7XHJcblx0XHRzZXJpZXMuc3BsaWNlKGksIDEpO1xyXG5cclxuXHRcdGlmIChzaG93TGVnZW5kKSB7XHJcblx0XHRcdGxlZ2VuZC52YWx1ZXMuc3BsaWNlKGksIDEpO1xyXG5cclxuXHRcdFx0bGVnZW5kQ2VsbHMuc3BsaWNlKGksIDEpO1xyXG5cdFx0XHRsZXQgdHIgPSBsZWdlbmRSb3dzLnNwbGljZShpLCAxKVswXTtcclxuXHRcdFx0b2ZmTW91c2UobnVsbCwgdHIuZmlyc3RDaGlsZCk7XHJcblx0XHRcdHRyLnJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjdXJzb3Iuc2hvdykge1xyXG5cdFx0XHRhY3RpdmVJZHhzLnNwbGljZShpLCAxKTtcclxuXHJcblx0XHRcdGN1cnNvclB0cy5sZW5ndGggPiAxICYmIGN1cnNvclB0cy5zcGxpY2UoaSwgMSlbMF0ucmVtb3ZlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVE9ETzogZGUtaW5pdCBuby1sb25nZXItbmVlZGVkIHNjYWxlcz9cclxuXHJcblx0XHRmaXJlKFwiZGVsU2VyaWVzXCIsIGkpO1xyXG5cdH1cclxuXHJcblx0c2VsZi5kZWxTZXJpZXMgPSBkZWxTZXJpZXM7XHJcblxyXG5cdGNvbnN0IHNpZGVzV2l0aEF4ZXMgPSBbZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2VdO1xyXG5cclxuXHRmdW5jdGlvbiBpbml0QXhpcyhheGlzLCBpKSB7XHJcblx0XHRheGlzLl9zaG93ID0gYXhpcy5zaG93O1xyXG5cclxuXHRcdGlmIChheGlzLnNob3cpIHtcclxuXHRcdFx0bGV0IGlzVnQgPSBheGlzLnNpZGUgJSAyO1xyXG5cclxuXHRcdFx0bGV0IHNjID0gc2NhbGVzW2F4aXMuc2NhbGVdO1xyXG5cclxuXHRcdFx0Ly8gdGhpcyBjYW4gb2NjdXIgaWYgYWxsIHNlcmllcyBzcGVjaWZ5IG5vbi1kZWZhdWx0IHNjYWxlc1xyXG5cdFx0XHRpZiAoc2MgPT0gbnVsbCkge1xyXG5cdFx0XHRcdGF4aXMuc2NhbGUgPSBpc1Z0ID8gc2VyaWVzWzFdLnNjYWxlIDogeFNjYWxlS2V5O1xyXG5cdFx0XHRcdHNjID0gc2NhbGVzW2F4aXMuc2NhbGVdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBhbHNvIHNldCBkZWZhdWx0cyBmb3IgaW5jcnMgJiB2YWx1ZXMgYmFzZWQgb24gYXhpcyBkaXN0clxyXG5cdFx0XHRsZXQgaXNUaW1lID0gc2MudGltZTtcclxuXHJcblx0XHRcdGF4aXMuc2l6ZSAgID0gZm5PclNlbGYoYXhpcy5zaXplKTtcclxuXHRcdFx0YXhpcy5zcGFjZSAgPSBmbk9yU2VsZihheGlzLnNwYWNlKTtcclxuXHRcdFx0YXhpcy5yb3RhdGUgPSBmbk9yU2VsZihheGlzLnJvdGF0ZSk7XHJcblxyXG5cdFx0XHRpZiAoaXNBcnIoYXhpcy5pbmNycykpIHtcclxuXHRcdFx0XHRheGlzLmluY3JzLmZvckVhY2goaW5jciA9PiB7XHJcblx0XHRcdFx0XHQhZml4ZWREZWMuaGFzKGluY3IpICYmIGZpeGVkRGVjLnNldChpbmNyLCBndWVzc0RlYyhpbmNyKSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGF4aXMuaW5jcnMgID0gZm5PclNlbGYoYXhpcy5pbmNycyAgfHwgKCAgICAgICAgICBzYy5kaXN0ciA9PSAyID8gd2hvbGVJbmNycyA6IChpc1RpbWUgPyAobXMgPT0gMSA/IHRpbWVJbmNyc01zIDogdGltZUluY3JzUykgOiBudW1JbmNycykpKTtcclxuXHRcdFx0YXhpcy5zcGxpdHMgPSBmbk9yU2VsZihheGlzLnNwbGl0cyB8fCAoaXNUaW1lICYmIHNjLmRpc3RyID09IDEgPyBfdGltZUF4aXNTcGxpdHMgOiBzYy5kaXN0ciA9PSAzID8gbG9nQXhpc1NwbGl0cyA6IHNjLmRpc3RyID09IDQgPyBhc2luaEF4aXNTcGxpdHMgOiBudW1BeGlzU3BsaXRzKSk7XHJcblxyXG5cdFx0XHRheGlzLnN0cm9rZSAgICAgICAgPSBmbk9yU2VsZihheGlzLnN0cm9rZSk7XHJcblx0XHRcdGF4aXMuZ3JpZC5zdHJva2UgICA9IGZuT3JTZWxmKGF4aXMuZ3JpZC5zdHJva2UpO1xyXG5cdFx0XHRheGlzLnRpY2tzLnN0cm9rZSAgPSBmbk9yU2VsZihheGlzLnRpY2tzLnN0cm9rZSk7XHJcblx0XHRcdGF4aXMuYm9yZGVyLnN0cm9rZSA9IGZuT3JTZWxmKGF4aXMuYm9yZGVyLnN0cm9rZSk7XHJcblxyXG5cdFx0XHRsZXQgYXYgPSBheGlzLnZhbHVlcztcclxuXHJcblx0XHRcdGF4aXMudmFsdWVzID0gKFxyXG5cdFx0XHRcdC8vIHN0YXRpYyBhcnJheSBvZiB0aWNrIHZhbHVlc1xyXG5cdFx0XHRcdGlzQXJyKGF2KSAmJiAhaXNBcnIoYXZbMF0pID8gZm5PclNlbGYoYXYpIDpcclxuXHRcdFx0XHQvLyB0ZW1wb3JhbFxyXG5cdFx0XHRcdGlzVGltZSA/IChcclxuXHRcdFx0XHRcdC8vIGNvbmZpZyBhcnJheSBvZiBmbXREYXRlIHN0cmluZyB0cGxzXHJcblx0XHRcdFx0XHRpc0FycihhdikgP1xyXG5cdFx0XHRcdFx0XHR0aW1lQXhpc1ZhbHMoX3R6RGF0ZSwgdGltZUF4aXNTdGFtcHMoYXYsIF9mbXREYXRlKSkgOlxyXG5cdFx0XHRcdFx0Ly8gZm10RGF0ZSBzdHJpbmcgdHBsXHJcblx0XHRcdFx0XHRpc1N0cihhdikgP1xyXG5cdFx0XHRcdFx0XHR0aW1lQXhpc1ZhbChfdHpEYXRlLCBhdikgOlxyXG5cdFx0XHRcdFx0YXYgfHwgX3RpbWVBeGlzVmFsc1xyXG5cdFx0XHRcdCkgOiBhdiB8fCBudW1BeGlzVmFsc1xyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0YXhpcy5maWx0ZXIgPSBmbk9yU2VsZihheGlzLmZpbHRlciB8fCAoICAgICAgICAgIHNjLmRpc3RyID49IDMgJiYgc2MubG9nID09IDEwID8gbG9nMTBBeGlzVmFsc0ZpbHQgOiBzYy5kaXN0ciA9PSAzICYmIHNjLmxvZyA9PSAyID8gbG9nMkF4aXNWYWxzRmlsdCA6IHJldEFyZzEpKTtcclxuXHJcblx0XHRcdGF4aXMuZm9udCAgICAgID0gcHhSYXRpb0ZvbnQoYXhpcy5mb250KTtcclxuXHRcdFx0YXhpcy5sYWJlbEZvbnQgPSBweFJhdGlvRm9udChheGlzLmxhYmVsRm9udCk7XHJcblxyXG5cdFx0XHRheGlzLl9zaXplICAgPSBheGlzLnNpemUoc2VsZiwgbnVsbCwgaSwgMCk7XHJcblxyXG5cdFx0XHRheGlzLl9zcGFjZSAgPVxyXG5cdFx0XHRheGlzLl9yb3RhdGUgPVxyXG5cdFx0XHRheGlzLl9pbmNycyAgPVxyXG5cdFx0XHRheGlzLl9mb3VuZCAgPVx0Ly8gZm91bmRJbmNyU3BhY2VcclxuXHRcdFx0YXhpcy5fc3BsaXRzID1cclxuXHRcdFx0YXhpcy5fdmFsdWVzID0gbnVsbDtcclxuXHJcblx0XHRcdGlmIChheGlzLl9zaXplID4gMCkge1xyXG5cdFx0XHRcdHNpZGVzV2l0aEF4ZXNbaV0gPSB0cnVlO1xyXG5cdFx0XHRcdGF4aXMuX2VsID0gcGxhY2VEaXYoQVhJUywgd3JhcCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGRlYnVnXHJcblx0XHQvL1x0YXhpcy5fZWwuc3R5bGUuYmFja2dyb3VuZCA9IFwiI1wiICArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoxNjc3NzIxNSkudG9TdHJpbmcoMTYpICsgJzgwJztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGF1dG9QYWRTaWRlKHNlbGYsIHNpZGUsIHNpZGVzV2l0aEF4ZXMsIGN5Y2xlTnVtKSB7XHJcblx0XHRsZXQgW2hhc1RvcEF4aXMsIGhhc1JndEF4aXMsIGhhc0J0bUF4aXMsIGhhc0xmdEF4aXNdID0gc2lkZXNXaXRoQXhlcztcclxuXHJcblx0XHRsZXQgb3JpID0gc2lkZSAlIDI7XHJcblx0XHRsZXQgc2l6ZSA9IDA7XHJcblxyXG5cdFx0aWYgKG9yaSA9PSAwICYmIChoYXNMZnRBeGlzIHx8IGhhc1JndEF4aXMpKVxyXG5cdFx0XHRzaXplID0gKHNpZGUgPT0gMCAmJiAhaGFzVG9wQXhpcyB8fCBzaWRlID09IDIgJiYgIWhhc0J0bUF4aXMgPyByb3VuZCh4QXhpc09wdHMuc2l6ZSAvIDMpIDogMCk7XHJcblx0XHRpZiAob3JpID09IDEgJiYgKGhhc1RvcEF4aXMgfHwgaGFzQnRtQXhpcykpXHJcblx0XHRcdHNpemUgPSAoc2lkZSA9PSAxICYmICFoYXNSZ3RBeGlzIHx8IHNpZGUgPT0gMyAmJiAhaGFzTGZ0QXhpcyA/IHJvdW5kKHlBeGlzT3B0cy5zaXplIC8gMikgOiAwKTtcclxuXHJcblx0XHRyZXR1cm4gc2l6ZTtcclxuXHR9XHJcblxyXG5cdGNvbnN0IHBhZGRpbmcgPSBzZWxmLnBhZGRpbmcgPSAob3B0cy5wYWRkaW5nIHx8IFthdXRvUGFkU2lkZSxhdXRvUGFkU2lkZSxhdXRvUGFkU2lkZSxhdXRvUGFkU2lkZV0pLm1hcChwID0+IGZuT3JTZWxmKGlmTnVsbChwLCBhdXRvUGFkU2lkZSkpKTtcclxuXHRjb25zdCBfcGFkZGluZyA9IHNlbGYuX3BhZGRpbmcgPSBwYWRkaW5nLm1hcCgocCwgaSkgPT4gcChzZWxmLCBpLCBzaWRlc1dpdGhBeGVzLCAwKSk7XHJcblxyXG5cdGxldCBkYXRhTGVuO1xyXG5cclxuXHQvLyByZW5kZXJlZCBkYXRhIHdpbmRvd1xyXG5cdGxldCBpMCA9IG51bGw7XHJcblx0bGV0IGkxID0gbnVsbDtcclxuXHRjb25zdCBpZHhzID0gbW9kZSA9PSAxID8gc2VyaWVzWzBdLmlkeHMgOiBudWxsO1xyXG5cclxuXHRsZXQgZGF0YTAgPSBudWxsO1xyXG5cclxuXHRsZXQgdmlhQXV0b1NjYWxlWCA9IGZhbHNlO1xyXG5cclxuXHRmdW5jdGlvbiBzZXREYXRhKF9kYXRhLCBfcmVzZXRTY2FsZXMpIHtcclxuXHRcdGRhdGEgPSBfZGF0YSA9PSBudWxsID8gW10gOiBjb3B5KF9kYXRhLCBmYXN0SXNPYmopO1xyXG5cclxuXHRcdGlmIChtb2RlID09IDIpIHtcclxuXHRcdFx0ZGF0YUxlbiA9IDA7XHJcblx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgc2VyaWVzLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdGRhdGFMZW4gKz0gZGF0YVtpXVswXS5sZW5ndGg7XHJcblx0XHRcdHNlbGYuZGF0YSA9IGRhdGEgPSBfZGF0YTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRpZiAoZGF0YVswXSA9PSBudWxsKVxyXG5cdFx0XHRcdGRhdGFbMF0gPSBbXTtcclxuXHJcblx0XHRcdHNlbGYuZGF0YSA9IGRhdGEuc2xpY2UoKTtcclxuXHJcblx0XHRcdGRhdGEwID0gZGF0YVswXTtcclxuXHRcdFx0ZGF0YUxlbiA9IGRhdGEwLmxlbmd0aDtcclxuXHJcblx0XHRcdGlmICh4U2NhbGVEaXN0ciA9PSAyKSB7XHJcblx0XHRcdFx0ZGF0YVswXSA9IEFycmF5KGRhdGFMZW4pO1xyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUxlbjsgaSsrKVxyXG5cdFx0XHRcdFx0ZGF0YVswXVtpXSA9IGk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRzZWxmLl9kYXRhID0gZGF0YTtcclxuXHJcblx0XHRyZXNldFlTZXJpZXModHJ1ZSk7XHJcblxyXG5cdFx0ZmlyZShcInNldERhdGFcIik7XHJcblxyXG5cdFx0Ly8gZm9yY2VzIHggYXhpcyB0aWNrIHZhbHVlcyB0byByZS1nZW5lcmF0ZSB3aGVuIG5laXRoZXIgeCBzY2FsZSBub3IgeSBzY2FsZSBjaGFuZ2VzXHJcblx0XHQvLyBpbiBvcmRpbmFsIG1vZGUsIHNjYWxlIHJhbmdlIGlzIGJ5IGluZGV4LCBzbyB3aWxsIG5vdCBjaGFuZ2UgaWYgbmV3IGRhdGEgaGFzIHNhbWUgbGVuZ3RoLCBidXQgdGljayB2YWx1ZXMgYXJlIGZyb20gZGF0YVxyXG5cdFx0aWYgKHhTY2FsZURpc3RyID09IDIpIHtcclxuXHRcdFx0c2hvdWxkQ29udmVyZ2VTaXplID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8qIG9yIHNvbWV3aGF0IGNoZWFwZXIsIGFuZCB1Z2xpZXI6XHJcblx0XHRcdGlmIChyZWFkeSkge1xyXG5cdFx0XHRcdC8vIGxvZ2ljIGV4dHJhY3RlZCBmcm9tIGF4ZXNDYWxjKClcclxuXHRcdFx0XHRsZXQgaSA9IDA7XHJcblx0XHRcdFx0bGV0IGF4aXMgPSBheGVzW2ldO1xyXG5cdFx0XHRcdGxldCBfc3BsaXRzID0gYXhpcy5fc3BsaXRzLm1hcChpID0+IGRhdGEwW2ldKTtcclxuXHRcdFx0XHRsZXQgW19pbmNyLCBfc3BhY2VdID0gYXhpcy5fZm91bmQ7XHJcblx0XHRcdFx0bGV0IGluY3IgPSBkYXRhMFtfc3BsaXRzWzFdXSAtIGRhdGEwW19zcGxpdHNbMF1dO1xyXG5cdFx0XHRcdGF4aXMuX3ZhbHVlcyA9IGF4aXMudmFsdWVzKHNlbGYsIGF4aXMuZmlsdGVyKHNlbGYsIF9zcGxpdHMsIGksIF9zcGFjZSwgaW5jciksIGksIF9zcGFjZSwgaW5jcik7XHJcblx0XHRcdH1cclxuXHRcdFx0Ki9cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoX3Jlc2V0U2NhbGVzICE9PSBmYWxzZSkge1xyXG5cdFx0XHRsZXQgeHNjID0gc2NhbGVYO1xyXG5cclxuXHRcdFx0aWYgKHhzYy5hdXRvKHNlbGYsIHZpYUF1dG9TY2FsZVgpKVxyXG5cdFx0XHRcdGF1dG9TY2FsZVgoKTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdF9zZXRTY2FsZSh4U2NhbGVLZXksIHhzYy5taW4sIHhzYy5tYXgpO1xyXG5cclxuXHRcdFx0c2hvdWxkU2V0Q3Vyc29yID0gc2hvdWxkU2V0Q3Vyc29yIHx8IGN1cnNvci5sZWZ0ID49IDA7XHJcblx0XHRcdHNob3VsZFNldExlZ2VuZCA9IHRydWU7XHJcblx0XHRcdGNvbW1pdCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0c2VsZi5zZXREYXRhID0gc2V0RGF0YTtcclxuXHJcblx0ZnVuY3Rpb24gYXV0b1NjYWxlWCgpIHtcclxuXHRcdHZpYUF1dG9TY2FsZVggPSB0cnVlO1xyXG5cclxuXHRcdGxldCBfbWluLCBfbWF4O1xyXG5cclxuXHRcdGlmIChtb2RlID09IDEpIHtcclxuXHRcdFx0aWYgKGRhdGFMZW4gPiAwKSB7XHJcblx0XHRcdFx0aTAgPSBpZHhzWzBdID0gMDtcclxuXHRcdFx0XHRpMSA9IGlkeHNbMV0gPSBkYXRhTGVuIC0gMTtcclxuXHJcblx0XHRcdFx0X21pbiA9IGRhdGFbMF1baTBdO1xyXG5cdFx0XHRcdF9tYXggPSBkYXRhWzBdW2kxXTtcclxuXHJcblx0XHRcdFx0aWYgKHhTY2FsZURpc3RyID09IDIpIHtcclxuXHRcdFx0XHRcdF9taW4gPSBpMDtcclxuXHRcdFx0XHRcdF9tYXggPSBpMTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAoX21pbiA9PSBfbWF4KSB7XHJcblx0XHRcdFx0XHRpZiAoeFNjYWxlRGlzdHIgPT0gMylcclxuXHRcdFx0XHRcdFx0W19taW4sIF9tYXhdID0gcmFuZ2VMb2coX21pbiwgX21pbiwgc2NhbGVYLmxvZywgZmFsc2UpO1xyXG5cdFx0XHRcdFx0ZWxzZSBpZiAoeFNjYWxlRGlzdHIgPT0gNClcclxuXHRcdFx0XHRcdFx0W19taW4sIF9tYXhdID0gcmFuZ2VBc2luaChfbWluLCBfbWluLCBzY2FsZVgubG9nLCBmYWxzZSk7XHJcblx0XHRcdFx0XHRlbHNlIGlmIChzY2FsZVgudGltZSlcclxuXHRcdFx0XHRcdFx0X21heCA9IF9taW4gKyByb3VuZCg4NjQwMCAvIG1zKTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0W19taW4sIF9tYXhdID0gcmFuZ2VOdW0oX21pbiwgX21heCwgcmFuZ2VQYWQsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRpMCA9IGlkeHNbMF0gPSBfbWluID0gbnVsbDtcclxuXHRcdFx0XHRpMSA9IGlkeHNbMV0gPSBfbWF4ID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdF9zZXRTY2FsZSh4U2NhbGVLZXksIF9taW4sIF9tYXgpO1xyXG5cdH1cclxuXHJcblx0bGV0IGN0eFN0cm9rZSwgY3R4RmlsbCwgY3R4V2lkdGgsIGN0eERhc2gsIGN0eEpvaW4sIGN0eENhcCwgY3R4Rm9udCwgY3R4QWxpZ24sIGN0eEJhc2VsaW5lO1xyXG5cdGxldCBjdHhBbHBoYTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0Q3R4U3R5bGUoc3Ryb2tlLCB3aWR0aCwgZGFzaCwgY2FwLCBmaWxsLCBqb2luKSB7XHJcblx0XHRzdHJva2UgPz89IHRyYW5zcGFyZW50O1xyXG5cdFx0ZGFzaCAgID8/PSBFTVBUWV9BUlI7XHJcblx0XHRjYXAgICAgPz89IFwiYnV0dFwiOyAvLyAo4oC/fOKAvylcclxuXHRcdGZpbGwgICA/Pz0gdHJhbnNwYXJlbnQ7XHJcblx0XHRqb2luICAgPz89IFwicm91bmRcIjtcclxuXHJcblx0XHRpZiAoc3Ryb2tlICE9IGN0eFN0cm9rZSlcclxuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY3R4U3Ryb2tlID0gc3Ryb2tlO1xyXG5cdFx0aWYgKGZpbGwgIT0gY3R4RmlsbClcclxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGN0eEZpbGwgPSBmaWxsO1xyXG5cdFx0aWYgKHdpZHRoICE9IGN0eFdpZHRoKVxyXG5cdFx0XHRjdHgubGluZVdpZHRoID0gY3R4V2lkdGggPSB3aWR0aDtcclxuXHRcdGlmIChqb2luICE9IGN0eEpvaW4pXHJcblx0XHRcdGN0eC5saW5lSm9pbiA9IGN0eEpvaW4gPSBqb2luO1xyXG5cdFx0aWYgKGNhcCAhPSBjdHhDYXApXHJcblx0XHRcdGN0eC5saW5lQ2FwID0gY3R4Q2FwID0gY2FwO1xyXG5cdFx0aWYgKGRhc2ggIT0gY3R4RGFzaClcclxuXHRcdFx0Y3R4LnNldExpbmVEYXNoKGN0eERhc2ggPSBkYXNoKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldEZvbnRTdHlsZShmb250LCBmaWxsLCBhbGlnbiwgYmFzZWxpbmUpIHtcclxuXHRcdGlmIChmaWxsICE9IGN0eEZpbGwpXHJcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBjdHhGaWxsID0gZmlsbDtcclxuXHRcdGlmIChmb250ICE9IGN0eEZvbnQpXHJcblx0XHRcdGN0eC5mb250ID0gY3R4Rm9udCA9IGZvbnQ7XHJcblx0XHRpZiAoYWxpZ24gIT0gY3R4QWxpZ24pXHJcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSBjdHhBbGlnbiA9IGFsaWduO1xyXG5cdFx0aWYgKGJhc2VsaW5lICE9IGN0eEJhc2VsaW5lKVxyXG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gY3R4QmFzZWxpbmUgPSBiYXNlbGluZTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFjY1NjYWxlKHdzYywgcHNjLCBmYWNldCwgZGF0YSwgc29ydGVkID0gMCkge1xyXG5cdFx0aWYgKGRhdGEubGVuZ3RoID4gMCAmJiB3c2MuYXV0byhzZWxmLCB2aWFBdXRvU2NhbGVYKSAmJiAocHNjID09IG51bGwgfHwgcHNjLm1pbiA9PSBudWxsKSkge1xyXG5cdFx0XHRsZXQgX2kwID0gaWZOdWxsKGkwLCAwKTtcclxuXHRcdFx0bGV0IF9pMSA9IGlmTnVsbChpMSwgZGF0YS5sZW5ndGggLSAxKTtcclxuXHJcblx0XHRcdC8vIG9ubHkgcnVuIGdldE1pbk1heCgpIGZvciBpbnZhbGlkYXRlZCBzZXJpZXMgZGF0YSwgZWxzZSByZXVzZVxyXG5cdFx0XHRsZXQgbWluTWF4ID0gZmFjZXQubWluID09IG51bGwgPyAod3NjLmRpc3RyID09IDMgPyBnZXRNaW5NYXhMb2coZGF0YSwgX2kwLCBfaTEpIDogZ2V0TWluTWF4KGRhdGEsIF9pMCwgX2kxLCBzb3J0ZWQpKSA6IFtmYWNldC5taW4sIGZhY2V0Lm1heF07XHJcblxyXG5cdFx0XHQvLyBpbml0aWFsIG1pbi9tYXhcclxuXHRcdFx0d3NjLm1pbiA9IG1pbih3c2MubWluLCBmYWNldC5taW4gPSBtaW5NYXhbMF0pO1xyXG5cdFx0XHR3c2MubWF4ID0gbWF4KHdzYy5tYXgsIGZhY2V0Lm1heCA9IG1pbk1heFsxXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRTY2FsZXMoKSB7XHJcblx0Ly9cdGxvZyhcInNldFNjYWxlcygpXCIsIGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0Ly8gd2lwIHNjYWxlc1xyXG5cdFx0bGV0IHdpcFNjYWxlcyA9IGNvcHkoc2NhbGVzLCBmYXN0SXNPYmopO1xyXG5cclxuXHRcdGZvciAobGV0IGsgaW4gd2lwU2NhbGVzKSB7XHJcblx0XHRcdGxldCB3c2MgPSB3aXBTY2FsZXNba107XHJcblx0XHRcdGxldCBwc2MgPSBwZW5kU2NhbGVzW2tdO1xyXG5cclxuXHRcdFx0aWYgKHBzYyAhPSBudWxsICYmIHBzYy5taW4gIT0gbnVsbCkge1xyXG5cdFx0XHRcdGFzc2lnbih3c2MsIHBzYyk7XHJcblxyXG5cdFx0XHRcdC8vIGV4cGxpY2l0bHkgc2V0dGluZyB0aGUgeC1zY2FsZSBpbnZhbGlkYXRlcyBldmVyeXRoaW5nIChhY3RzIGFzIHJlZHJhdylcclxuXHRcdFx0XHRpZiAoayA9PSB4U2NhbGVLZXkpXHJcblx0XHRcdFx0XHRyZXNldFlTZXJpZXModHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoayAhPSB4U2NhbGVLZXkgfHwgbW9kZSA9PSAyKSB7XHJcblx0XHRcdFx0aWYgKGRhdGFMZW4gPT0gMCAmJiB3c2MuZnJvbSA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRsZXQgbWluTWF4ID0gd3NjLnJhbmdlKHNlbGYsIG51bGwsIG51bGwsIGspO1xyXG5cdFx0XHRcdFx0d3NjLm1pbiA9IG1pbk1heFswXTtcclxuXHRcdFx0XHRcdHdzYy5tYXggPSBtaW5NYXhbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0d3NjLm1pbiA9IGluZjtcclxuXHRcdFx0XHRcdHdzYy5tYXggPSAtaW5mO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChkYXRhTGVuID4gMCkge1xyXG5cdFx0XHQvLyBwcmUtcmFuZ2UgeS1zY2FsZXMgZnJvbSB5IHNlcmllcycgZGF0YSB2YWx1ZXNcclxuXHRcdFx0c2VyaWVzLmZvckVhY2goKHMsIGkpID0+IHtcclxuXHRcdFx0XHRpZiAobW9kZSA9PSAxKSB7XHJcblx0XHRcdFx0XHRsZXQgayA9IHMuc2NhbGU7XHJcblx0XHRcdFx0XHRsZXQgd3NjID0gd2lwU2NhbGVzW2tdO1xyXG5cdFx0XHRcdFx0bGV0IHBzYyA9IHBlbmRTY2FsZXNba107XHJcblxyXG5cdFx0XHRcdFx0aWYgKGkgPT0gMCkge1xyXG5cdFx0XHRcdFx0XHRsZXQgbWluTWF4ID0gd3NjLnJhbmdlKHNlbGYsIHdzYy5taW4sIHdzYy5tYXgsIGspO1xyXG5cclxuXHRcdFx0XHRcdFx0d3NjLm1pbiA9IG1pbk1heFswXTtcclxuXHRcdFx0XHRcdFx0d3NjLm1heCA9IG1pbk1heFsxXTtcclxuXHJcblx0XHRcdFx0XHRcdGkwID0gY2xvc2VzdElkeCh3c2MubWluLCBkYXRhWzBdKTtcclxuXHRcdFx0XHRcdFx0aTEgPSBjbG9zZXN0SWR4KHdzYy5tYXgsIGRhdGFbMF0pO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gZG9uJ3QgdHJ5IHRvIGNvbnRyYWN0IHNhbWUgb3IgYWRqYWNlbnQgaWR4c1xyXG5cdFx0XHRcdFx0XHRpZiAoaTEgLSBpMCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBjbG9zZXN0IGluZGljZXMgY2FuIGJlIG91dHNpZGUgb2Ygdmlld1xyXG5cdFx0XHRcdFx0XHRcdGlmIChkYXRhWzBdW2kwXSA8IHdzYy5taW4pXHJcblx0XHRcdFx0XHRcdFx0XHRpMCsrO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChkYXRhWzBdW2kxXSA+IHdzYy5tYXgpXHJcblx0XHRcdFx0XHRcdFx0XHRpMS0tO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRzLm1pbiA9IGRhdGEwW2kwXTtcclxuXHRcdFx0XHRcdFx0cy5tYXggPSBkYXRhMFtpMV07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIGlmIChzLnNob3cgJiYgcy5hdXRvKVxyXG5cdFx0XHRcdFx0XHRhY2NTY2FsZSh3c2MsIHBzYywgcywgZGF0YVtpXSwgcy5zb3J0ZWQpO1xyXG5cclxuXHRcdFx0XHRcdHMuaWR4c1swXSA9IGkwO1xyXG5cdFx0XHRcdFx0cy5pZHhzWzFdID0gaTE7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKGkgPiAwKSB7XHJcblx0XHRcdFx0XHRcdGlmIChzLnNob3cgJiYgcy5hdXRvKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogb25seSBoYW5kbGVzLCBhc3N1bWVzIGFuZCByZXF1aXJlcyBmYWNldHNbMF0gLyAneCcgc2NhbGUsIGFuZCBmYWNldHNbMV0gLyAneScgc2NhbGVcclxuXHRcdFx0XHRcdFx0XHRsZXQgWyB4RmFjZXQsIHlGYWNldCBdID0gcy5mYWNldHM7XHJcblx0XHRcdFx0XHRcdFx0bGV0IHhTY2FsZUtleSA9IHhGYWNldC5zY2FsZTtcclxuXHRcdFx0XHRcdFx0XHRsZXQgeVNjYWxlS2V5ID0geUZhY2V0LnNjYWxlO1xyXG5cdFx0XHRcdFx0XHRcdGxldCBbIHhEYXRhLCB5RGF0YSBdID0gZGF0YVtpXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0YWNjU2NhbGUod2lwU2NhbGVzW3hTY2FsZUtleV0sIHBlbmRTY2FsZXNbeFNjYWxlS2V5XSwgeEZhY2V0LCB4RGF0YSwgeEZhY2V0LnNvcnRlZCk7XHJcblx0XHRcdFx0XHRcdFx0YWNjU2NhbGUod2lwU2NhbGVzW3lTY2FsZUtleV0sIHBlbmRTY2FsZXNbeVNjYWxlS2V5XSwgeUZhY2V0LCB5RGF0YSwgeUZhY2V0LnNvcnRlZCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIHRlbXBcclxuXHRcdFx0XHRcdFx0XHRzLm1pbiA9IHlGYWNldC5taW47XHJcblx0XHRcdFx0XHRcdFx0cy5tYXggPSB5RmFjZXQubWF4O1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdC8vIHJhbmdlIGluZGVwZW5kZW50IHNjYWxlc1xyXG5cdFx0XHRmb3IgKGxldCBrIGluIHdpcFNjYWxlcykge1xyXG5cdFx0XHRcdGxldCB3c2MgPSB3aXBTY2FsZXNba107XHJcblx0XHRcdFx0bGV0IHBzYyA9IHBlbmRTY2FsZXNba107XHJcblxyXG5cdFx0XHRcdGlmICh3c2MuZnJvbSA9PSBudWxsICYmIChwc2MgPT0gbnVsbCB8fCBwc2MubWluID09IG51bGwpKSB7XHJcblx0XHRcdFx0XHRsZXQgbWluTWF4ID0gd3NjLnJhbmdlKFxyXG5cdFx0XHRcdFx0XHRzZWxmLFxyXG5cdFx0XHRcdFx0XHR3c2MubWluID09ICBpbmYgPyBudWxsIDogd3NjLm1pbixcclxuXHRcdFx0XHRcdFx0d3NjLm1heCA9PSAtaW5mID8gbnVsbCA6IHdzYy5tYXgsXHJcblx0XHRcdFx0XHRcdGtcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHR3c2MubWluID0gbWluTWF4WzBdO1xyXG5cdFx0XHRcdFx0d3NjLm1heCA9IG1pbk1heFsxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyByYW5nZSBkZXBlbmRlbnQgc2NhbGVzXHJcblx0XHRmb3IgKGxldCBrIGluIHdpcFNjYWxlcykge1xyXG5cdFx0XHRsZXQgd3NjID0gd2lwU2NhbGVzW2tdO1xyXG5cclxuXHRcdFx0aWYgKHdzYy5mcm9tICE9IG51bGwpIHtcclxuXHRcdFx0XHRsZXQgYmFzZSA9IHdpcFNjYWxlc1t3c2MuZnJvbV07XHJcblxyXG5cdFx0XHRcdGlmIChiYXNlLm1pbiA9PSBudWxsKVxyXG5cdFx0XHRcdFx0d3NjLm1pbiA9IHdzYy5tYXggPSBudWxsO1xyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0bGV0IG1pbk1heCA9IHdzYy5yYW5nZShzZWxmLCBiYXNlLm1pbiwgYmFzZS5tYXgsIGspO1xyXG5cdFx0XHRcdFx0d3NjLm1pbiA9IG1pbk1heFswXTtcclxuXHRcdFx0XHRcdHdzYy5tYXggPSBtaW5NYXhbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGNoYW5nZWQgPSB7fTtcclxuXHRcdGxldCBhbnlDaGFuZ2VkID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yIChsZXQgayBpbiB3aXBTY2FsZXMpIHtcclxuXHRcdFx0bGV0IHdzYyA9IHdpcFNjYWxlc1trXTtcclxuXHRcdFx0bGV0IHNjID0gc2NhbGVzW2tdO1xyXG5cclxuXHRcdFx0aWYgKHNjLm1pbiAhPSB3c2MubWluIHx8IHNjLm1heCAhPSB3c2MubWF4KSB7XHJcblx0XHRcdFx0c2MubWluID0gd3NjLm1pbjtcclxuXHRcdFx0XHRzYy5tYXggPSB3c2MubWF4O1xyXG5cclxuXHRcdFx0XHRsZXQgZGlzdHIgPSBzYy5kaXN0cjtcclxuXHJcblx0XHRcdFx0c2MuX21pbiA9IGRpc3RyID09IDMgPyBsb2cxMChzYy5taW4pIDogZGlzdHIgPT0gNCA/IGFzaW5oKHNjLm1pbiwgc2MuYXNpbmgpIDogc2MubWluO1xyXG5cdFx0XHRcdHNjLl9tYXggPSBkaXN0ciA9PSAzID8gbG9nMTAoc2MubWF4KSA6IGRpc3RyID09IDQgPyBhc2luaChzYy5tYXgsIHNjLmFzaW5oKSA6IHNjLm1heDtcclxuXHJcblx0XHRcdFx0Y2hhbmdlZFtrXSA9IGFueUNoYW5nZWQgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGFueUNoYW5nZWQpIHtcclxuXHRcdFx0Ly8gaW52YWxpZGF0ZSBwYXRocyBvZiBhbGwgc2VyaWVzIG9uIGNoYW5nZWQgc2NhbGVzXHJcblx0XHRcdHNlcmllcy5mb3JFYWNoKChzLCBpKSA9PiB7XHJcblx0XHRcdFx0aWYgKG1vZGUgPT0gMikge1xyXG5cdFx0XHRcdFx0aWYgKGkgPiAwICYmIGNoYW5nZWQueSlcclxuXHRcdFx0XHRcdFx0cy5fcGF0aHMgPSBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdGlmIChjaGFuZ2VkW3Muc2NhbGVdKVxyXG5cdFx0XHRcdFx0XHRzLl9wYXRocyA9IG51bGw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGZvciAobGV0IGsgaW4gY2hhbmdlZCkge1xyXG5cdFx0XHRcdHNob3VsZENvbnZlcmdlU2l6ZSA9IHRydWU7XHJcblx0XHRcdFx0ZmlyZShcInNldFNjYWxlXCIsIGspO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoY3Vyc29yLnNob3cgJiYgY3Vyc29yLmxlZnQgPj0gMClcclxuXHRcdFx0XHRzaG91bGRTZXRDdXJzb3IgPSBzaG91bGRTZXRMZWdlbmQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGsgaW4gcGVuZFNjYWxlcylcclxuXHRcdFx0cGVuZFNjYWxlc1trXSA9IG51bGw7XHJcblx0fVxyXG5cclxuXHQvLyBncmFicyB0aGUgbmVhcmVzdCBpbmRpY2VzIHdpdGggeSBkYXRhIG91dHNpZGUgb2YgeC1zY2FsZSBsaW1pdHNcclxuXHRmdW5jdGlvbiBnZXRPdXRlcklkeHMoeWRhdGEpIHtcclxuXHRcdGxldCBfaTAgPSBjbGFtcChpMCAtIDEsIDAsIGRhdGFMZW4gLSAxKTtcclxuXHRcdGxldCBfaTEgPSBjbGFtcChpMSArIDEsIDAsIGRhdGFMZW4gLSAxKTtcclxuXHJcblx0XHR3aGlsZSAoeWRhdGFbX2kwXSA9PSBudWxsICYmIF9pMCA+IDApXHJcblx0XHRcdF9pMC0tO1xyXG5cclxuXHRcdHdoaWxlICh5ZGF0YVtfaTFdID09IG51bGwgJiYgX2kxIDwgZGF0YUxlbiAtIDEpXHJcblx0XHRcdF9pMSsrO1xyXG5cclxuXHRcdHJldHVybiBbX2kwLCBfaTFdO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZHJhd1NlcmllcygpIHtcclxuXHRcdGlmIChkYXRhTGVuID4gMCkge1xyXG5cdFx0XHRzZXJpZXMuZm9yRWFjaCgocywgaSkgPT4ge1xyXG5cdFx0XHRcdGlmIChpID4gMCAmJiBzLnNob3cgJiYgcy5fcGF0aHMgPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0bGV0IF9pZHhzID0gbW9kZSA9PSAyID8gWzAsIGRhdGFbaV1bMF0ubGVuZ3RoIC0gMV0gOiBnZXRPdXRlcklkeHMoZGF0YVtpXSk7XHJcblx0XHRcdFx0XHRzLl9wYXRocyA9IHMucGF0aHMoc2VsZiwgaSwgX2lkeHNbMF0sIF9pZHhzWzFdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0c2VyaWVzLmZvckVhY2goKHMsIGkpID0+IHtcclxuXHRcdFx0XHRpZiAoaSA+IDAgJiYgcy5zaG93KSB7XHJcblx0XHRcdFx0XHRpZiAoY3R4QWxwaGEgIT0gcy5hbHBoYSlcclxuXHRcdFx0XHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gY3R4QWxwaGEgPSBzLmFscGhhO1xyXG5cclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0Y2FjaGVTdHJva2VGaWxsKGksIGZhbHNlKTtcclxuXHRcdFx0XHRcdFx0cy5fcGF0aHMgJiYgZHJhd1BhdGgoaSwgZmFsc2UpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0Y2FjaGVTdHJva2VGaWxsKGksIHRydWUpO1xyXG5cclxuXHRcdFx0XHRcdFx0bGV0IF9nYXBzID0gcy5fcGF0aHMgPyBzLl9wYXRocy5nYXBzIDogbnVsbDtcclxuXHJcblx0XHRcdFx0XHRcdGxldCBzaG93ID0gcy5wb2ludHMuc2hvdyhzZWxmLCBpLCBpMCwgaTEsIF9nYXBzKTtcclxuXHRcdFx0XHRcdFx0bGV0IGlkeHMgPSBzLnBvaW50cy5maWx0ZXIoc2VsZiwgaSwgc2hvdywgX2dhcHMpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKHNob3cgfHwgaWR4cykge1xyXG5cdFx0XHRcdFx0XHRcdHMucG9pbnRzLl9wYXRocyA9IHMucG9pbnRzLnBhdGhzKHNlbGYsIGksIGkwLCBpMSwgaWR4cyk7XHJcblx0XHRcdFx0XHRcdFx0ZHJhd1BhdGgoaSwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoY3R4QWxwaGEgIT0gMSlcclxuXHRcdFx0XHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gY3R4QWxwaGEgPSAxO1xyXG5cclxuXHRcdFx0XHRcdGZpcmUoXCJkcmF3U2VyaWVzXCIsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjYWNoZVN0cm9rZUZpbGwoc2ksIF9wb2ludHMpIHtcclxuXHRcdGxldCBzID0gX3BvaW50cyA/IHNlcmllc1tzaV0ucG9pbnRzIDogc2VyaWVzW3NpXTtcclxuXHJcblx0XHRzLl9zdHJva2UgPSBzLnN0cm9rZShzZWxmLCBzaSk7XHJcblx0XHRzLl9maWxsICAgPSBzLmZpbGwoc2VsZiwgc2kpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZHJhd1BhdGgoc2ksIF9wb2ludHMpIHtcclxuXHRcdGxldCBzID0gX3BvaW50cyA/IHNlcmllc1tzaV0ucG9pbnRzIDogc2VyaWVzW3NpXTtcclxuXHJcblx0XHRsZXQgc3Ryb2tlU3R5bGUgPSBzLl9zdHJva2U7XHJcblx0XHRsZXQgZmlsbFN0eWxlICAgPSBzLl9maWxsO1xyXG5cclxuXHRcdGxldCB7IHN0cm9rZSwgZmlsbCwgY2xpcDogZ2Fwc0NsaXAsIGZsYWdzIH0gPSBzLl9wYXRocztcclxuXHRcdGxldCBib3VuZHNDbGlwID0gbnVsbDtcclxuXHRcdGxldCB3aWR0aCA9IHJvdW5kRGVjKHMud2lkdGggKiBweFJhdGlvLCAzKTtcclxuXHRcdGxldCBvZmZzZXQgPSAod2lkdGggJSAyKSAvIDI7XHJcblxyXG5cdFx0aWYgKF9wb2ludHMgJiYgZmlsbFN0eWxlID09IG51bGwpXHJcblx0XHRcdGZpbGxTdHlsZSA9IHdpZHRoID4gMCA/IFwiI2ZmZlwiIDogc3Ryb2tlU3R5bGU7XHJcblxyXG5cdFx0bGV0IF9weEFsaWduID0gcy5weEFsaWduID09IDEgJiYgb2Zmc2V0ID4gMDtcclxuXHJcblx0XHRfcHhBbGlnbiAmJiBjdHgudHJhbnNsYXRlKG9mZnNldCwgb2Zmc2V0KTtcclxuXHJcblx0XHRpZiAoIV9wb2ludHMpIHtcclxuXHRcdFx0bGV0IGxmdCA9IHBsb3RMZnQgLSB3aWR0aCAvIDIsXHJcblx0XHRcdFx0dG9wID0gcGxvdFRvcCAtIHdpZHRoIC8gMixcclxuXHRcdFx0XHR3aWQgPSBwbG90V2lkICsgd2lkdGgsXHJcblx0XHRcdFx0aGd0ID0gcGxvdEhndCArIHdpZHRoO1xyXG5cclxuXHRcdFx0Ym91bmRzQ2xpcCA9IG5ldyBQYXRoMkQoKTtcclxuXHRcdFx0Ym91bmRzQ2xpcC5yZWN0KGxmdCwgdG9wLCB3aWQsIGhndCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdGhlIHBvaW50cyBwYXRoYnVpbGRlcidzIGdhcHNDbGlwIGlzIGl0cyBib3VuZHNDbGlwLCBzaW5jZSBwb2ludHMgZG9udCBuZWVkIGdhcHMgY2xpcHBpbmcsIGFuZCBib3VuZHMgZGVwZW5kIG9uIHBvaW50IHNpemVcclxuXHRcdGlmIChfcG9pbnRzKVxyXG5cdFx0XHRzdHJva2VGaWxsKHN0cm9rZVN0eWxlLCB3aWR0aCwgcy5kYXNoLCBzLmNhcCwgZmlsbFN0eWxlLCBzdHJva2UsIGZpbGwsIGZsYWdzLCBnYXBzQ2xpcCk7XHJcblx0XHRlbHNlXHJcblx0XHRcdGZpbGxTdHJva2Uoc2ksIHN0cm9rZVN0eWxlLCB3aWR0aCwgcy5kYXNoLCBzLmNhcCwgZmlsbFN0eWxlLCBzdHJva2UsIGZpbGwsIGZsYWdzLCBib3VuZHNDbGlwLCBnYXBzQ2xpcCk7XHJcblxyXG5cdFx0X3B4QWxpZ24gJiYgY3R4LnRyYW5zbGF0ZSgtb2Zmc2V0LCAtb2Zmc2V0KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGZpbGxTdHJva2Uoc2ksIHN0cm9rZVN0eWxlLCBsaW5lV2lkdGgsIGxpbmVEYXNoLCBsaW5lQ2FwLCBmaWxsU3R5bGUsIHN0cm9rZVBhdGgsIGZpbGxQYXRoLCBmbGFncywgYm91bmRzQ2xpcCwgZ2Fwc0NsaXApIHtcclxuXHRcdGxldCBkaWRTdHJva2VGaWxsID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gZm9yIGFsbCBiYW5kcyB3aGVyZSB0aGlzIHNlcmllcyBpcyB0aGUgdG9wIGVkZ2UsIGNyZWF0ZSB1cHdhcmRzIGNsaXBzIHVzaW5nIHRoZSBib3R0b20gZWRnZXNcclxuXHRcdC8vIGFuZCBhcHBseSBjbGlwcyArIGZpbGwgd2l0aCBiYW5kIGZpbGwgb3IgZGZsdEZpbGxcclxuXHRcdGJhbmRzLmZvckVhY2goKGIsIGJpKSA9PiB7XHJcblx0XHRcdC8vIGlzVXBwZXJFZGdlP1xyXG5cdFx0XHRpZiAoYi5zZXJpZXNbMF0gPT0gc2kpIHtcclxuXHRcdFx0XHRsZXQgbG93ZXJFZGdlID0gc2VyaWVzW2Iuc2VyaWVzWzFdXTtcclxuXHRcdFx0XHRsZXQgbG93ZXJEYXRhID0gZGF0YVtiLnNlcmllc1sxXV07XHJcblxyXG5cdFx0XHRcdGxldCBiYW5kQ2xpcCA9IChsb3dlckVkZ2UuX3BhdGhzIHx8IEVNUFRZX09CSikuYmFuZDtcclxuXHJcblx0XHRcdFx0aWYgKGlzQXJyKGJhbmRDbGlwKSlcclxuXHRcdFx0XHRcdGJhbmRDbGlwID0gYi5kaXIgPT0gMSA/IGJhbmRDbGlwWzBdIDogYmFuZENsaXBbMV07XHJcblxyXG5cdFx0XHRcdGxldCBnYXBzQ2xpcDI7XHJcblxyXG5cdFx0XHRcdGxldCBfZmlsbFN0eWxlID0gbnVsbDtcclxuXHJcblx0XHRcdFx0Ly8gaGFzTG93ZXJFZGdlP1xyXG5cdFx0XHRcdGlmIChsb3dlckVkZ2Uuc2hvdyAmJiBiYW5kQ2xpcCAmJiBoYXNEYXRhKGxvd2VyRGF0YSwgaTAsIGkxKSkge1xyXG5cdFx0XHRcdFx0X2ZpbGxTdHlsZSA9IGIuZmlsbChzZWxmLCBiaSkgfHwgZmlsbFN0eWxlO1xyXG5cdFx0XHRcdFx0Z2Fwc0NsaXAyID0gbG93ZXJFZGdlLl9wYXRocy5jbGlwO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRiYW5kQ2xpcCA9IG51bGw7XHJcblxyXG5cdFx0XHRcdHN0cm9rZUZpbGwoc3Ryb2tlU3R5bGUsIGxpbmVXaWR0aCwgbGluZURhc2gsIGxpbmVDYXAsIF9maWxsU3R5bGUsIHN0cm9rZVBhdGgsIGZpbGxQYXRoLCBmbGFncywgYm91bmRzQ2xpcCwgZ2Fwc0NsaXAsIGdhcHNDbGlwMiwgYmFuZENsaXApO1xyXG5cclxuXHRcdFx0XHRkaWRTdHJva2VGaWxsID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKCFkaWRTdHJva2VGaWxsKVxyXG5cdFx0XHRzdHJva2VGaWxsKHN0cm9rZVN0eWxlLCBsaW5lV2lkdGgsIGxpbmVEYXNoLCBsaW5lQ2FwLCBmaWxsU3R5bGUsIHN0cm9rZVBhdGgsIGZpbGxQYXRoLCBmbGFncywgYm91bmRzQ2xpcCwgZ2Fwc0NsaXApO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgQ0xJUF9GSUxMX1NUUk9LRSA9IEJBTkRfQ0xJUF9GSUxMIHwgQkFORF9DTElQX1NUUk9LRTtcclxuXHJcblx0ZnVuY3Rpb24gc3Ryb2tlRmlsbChzdHJva2VTdHlsZSwgbGluZVdpZHRoLCBsaW5lRGFzaCwgbGluZUNhcCwgZmlsbFN0eWxlLCBzdHJva2VQYXRoLCBmaWxsUGF0aCwgZmxhZ3MsIGJvdW5kc0NsaXAsIGdhcHNDbGlwLCBnYXBzQ2xpcDIsIGJhbmRDbGlwKSB7XHJcblx0XHRzZXRDdHhTdHlsZShzdHJva2VTdHlsZSwgbGluZVdpZHRoLCBsaW5lRGFzaCwgbGluZUNhcCwgZmlsbFN0eWxlKTtcclxuXHJcblx0XHRpZiAoYm91bmRzQ2xpcCB8fCBnYXBzQ2xpcCB8fCBiYW5kQ2xpcCkge1xyXG5cdFx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0XHRib3VuZHNDbGlwICYmIGN0eC5jbGlwKGJvdW5kc0NsaXApO1xyXG5cdFx0XHRnYXBzQ2xpcCAmJiBjdHguY2xpcChnYXBzQ2xpcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGJhbmRDbGlwKSB7XHJcblx0XHRcdGlmICgoZmxhZ3MgJiBDTElQX0ZJTExfU1RST0tFKSA9PSBDTElQX0ZJTExfU1RST0tFKSB7XHJcblx0XHRcdFx0Y3R4LmNsaXAoYmFuZENsaXApO1xyXG5cdFx0XHRcdGdhcHNDbGlwMiAmJiBjdHguY2xpcChnYXBzQ2xpcDIpO1xyXG5cdFx0XHRcdGRvRmlsbChmaWxsU3R5bGUsIGZpbGxQYXRoKTtcclxuXHRcdFx0XHRkb1N0cm9rZShzdHJva2VTdHlsZSwgc3Ryb2tlUGF0aCwgbGluZVdpZHRoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChmbGFncyAmIEJBTkRfQ0xJUF9TVFJPS0UpIHtcclxuXHRcdFx0XHRkb0ZpbGwoZmlsbFN0eWxlLCBmaWxsUGF0aCk7XHJcblx0XHRcdFx0Y3R4LmNsaXAoYmFuZENsaXApO1xyXG5cdFx0XHRcdGRvU3Ryb2tlKHN0cm9rZVN0eWxlLCBzdHJva2VQYXRoLCBsaW5lV2lkdGgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKGZsYWdzICYgQkFORF9DTElQX0ZJTEwpIHtcclxuXHRcdFx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0XHRcdGN0eC5jbGlwKGJhbmRDbGlwKTtcclxuXHRcdFx0XHRnYXBzQ2xpcDIgJiYgY3R4LmNsaXAoZ2Fwc0NsaXAyKTtcclxuXHRcdFx0XHRkb0ZpbGwoZmlsbFN0eWxlLCBmaWxsUGF0aCk7XHJcblx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHRcdFx0XHRkb1N0cm9rZShzdHJva2VTdHlsZSwgc3Ryb2tlUGF0aCwgbGluZVdpZHRoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGRvRmlsbChmaWxsU3R5bGUsIGZpbGxQYXRoKTtcclxuXHRcdFx0ZG9TdHJva2Uoc3Ryb2tlU3R5bGUsIHN0cm9rZVBhdGgsIGxpbmVXaWR0aCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGJvdW5kc0NsaXAgfHwgZ2Fwc0NsaXAgfHwgYmFuZENsaXApXHJcblx0XHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkb1N0cm9rZShzdHJva2VTdHlsZSwgc3Ryb2tlUGF0aCwgbGluZVdpZHRoKSB7XHJcblx0XHRpZiAobGluZVdpZHRoID4gMCkge1xyXG5cdFx0XHRpZiAoc3Ryb2tlUGF0aCBpbnN0YW5jZW9mIE1hcCkge1xyXG5cdFx0XHRcdHN0cm9rZVBhdGguZm9yRWFjaCgoc3Ryb2tlUGF0aCwgc3Ryb2tlU3R5bGUpID0+IHtcclxuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGN0eFN0cm9rZSA9IHN0cm9rZVN0eWxlO1xyXG5cdFx0XHRcdFx0Y3R4LnN0cm9rZShzdHJva2VQYXRoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0c3Ryb2tlUGF0aCAhPSBudWxsICYmIHN0cm9rZVN0eWxlICYmIGN0eC5zdHJva2Uoc3Ryb2tlUGF0aCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkb0ZpbGwoZmlsbFN0eWxlLCBmaWxsUGF0aCkge1xyXG5cdFx0aWYgKGZpbGxQYXRoIGluc3RhbmNlb2YgTWFwKSB7XHJcblx0XHRcdGZpbGxQYXRoLmZvckVhY2goKGZpbGxQYXRoLCBmaWxsU3R5bGUpID0+IHtcclxuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gY3R4RmlsbCA9IGZpbGxTdHlsZTtcclxuXHRcdFx0XHRjdHguZmlsbChmaWxsUGF0aCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0XHRmaWxsUGF0aCAhPSBudWxsICYmIGZpbGxTdHlsZSAmJiBjdHguZmlsbChmaWxsUGF0aCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRJbmNyU3BhY2UoYXhpc0lkeCwgbWluLCBtYXgsIGZ1bGxEaW0pIHtcclxuXHRcdGxldCBheGlzID0gYXhlc1theGlzSWR4XTtcclxuXHJcblx0XHRsZXQgaW5jclNwYWNlO1xyXG5cclxuXHRcdGlmIChmdWxsRGltIDw9IDApXHJcblx0XHRcdGluY3JTcGFjZSA9IFswLCAwXTtcclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRsZXQgbWluU3BhY2UgPSBheGlzLl9zcGFjZSA9IGF4aXMuc3BhY2Uoc2VsZiwgYXhpc0lkeCwgbWluLCBtYXgsIGZ1bGxEaW0pO1xyXG5cdFx0XHRsZXQgaW5jcnMgICAgPSBheGlzLl9pbmNycyA9IGF4aXMuaW5jcnMoc2VsZiwgYXhpc0lkeCwgbWluLCBtYXgsIGZ1bGxEaW0sIG1pblNwYWNlKTtcclxuXHRcdFx0aW5jclNwYWNlICAgID0gZmluZEluY3IobWluLCBtYXgsIGluY3JzLCBmdWxsRGltLCBtaW5TcGFjZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIChheGlzLl9mb3VuZCA9IGluY3JTcGFjZSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkcmF3T3J0aG9MaW5lcyhvZmZzLCBmaWx0cywgb3JpLCBzaWRlLCBwb3MwLCBsZW4sIHdpZHRoLCBzdHJva2UsIGRhc2gsIGNhcCkge1xyXG5cdFx0bGV0IG9mZnNldCA9ICh3aWR0aCAlIDIpIC8gMjtcclxuXHJcblx0XHRweEFsaWduID09IDEgJiYgY3R4LnRyYW5zbGF0ZShvZmZzZXQsIG9mZnNldCk7XHJcblxyXG5cdFx0c2V0Q3R4U3R5bGUoc3Ryb2tlLCB3aWR0aCwgZGFzaCwgY2FwLCBzdHJva2UpO1xyXG5cclxuXHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHJcblx0XHRsZXQgeDAsIHkwLCB4MSwgeTEsIHBvczEgPSBwb3MwICsgKHNpZGUgPT0gMCB8fCBzaWRlID09IDMgPyAtbGVuIDogbGVuKTtcclxuXHJcblx0XHRpZiAob3JpID09IDApIHtcclxuXHRcdFx0eTAgPSBwb3MwO1xyXG5cdFx0XHR5MSA9IHBvczE7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0eDAgPSBwb3MwO1xyXG5cdFx0XHR4MSA9IHBvczE7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBvZmZzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmIChmaWx0c1tpXSAhPSBudWxsKSB7XHJcblx0XHRcdFx0aWYgKG9yaSA9PSAwKVxyXG5cdFx0XHRcdFx0eDAgPSB4MSA9IG9mZnNbaV07XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0eTAgPSB5MSA9IG9mZnNbaV07XHJcblxyXG5cdFx0XHRcdGN0eC5tb3ZlVG8oeDAsIHkwKTtcclxuXHRcdFx0XHRjdHgubGluZVRvKHgxLCB5MSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRjdHguc3Ryb2tlKCk7XHJcblxyXG5cdFx0cHhBbGlnbiA9PSAxICYmIGN0eC50cmFuc2xhdGUoLW9mZnNldCwgLW9mZnNldCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBheGVzQ2FsYyhjeWNsZU51bSkge1xyXG5cdC8vXHRsb2coXCJheGVzQ2FsYygpXCIsIGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0bGV0IGNvbnZlcmdlZCA9IHRydWU7XHJcblxyXG5cdFx0YXhlcy5mb3JFYWNoKChheGlzLCBpKSA9PiB7XHJcblx0XHRcdGlmICghYXhpcy5zaG93KVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdGxldCBzY2FsZSA9IHNjYWxlc1theGlzLnNjYWxlXTtcclxuXHJcblx0XHRcdGlmIChzY2FsZS5taW4gPT0gbnVsbCkge1xyXG5cdFx0XHRcdGlmIChheGlzLl9zaG93KSB7XHJcblx0XHRcdFx0XHRjb252ZXJnZWQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdGF4aXMuX3Nob3cgPSBmYWxzZTtcclxuXHRcdFx0XHRcdHJlc2V0WVNlcmllcyhmYWxzZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRpZiAoIWF4aXMuX3Nob3cpIHtcclxuXHRcdFx0XHRcdGNvbnZlcmdlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0YXhpcy5fc2hvdyA9IHRydWU7XHJcblx0XHRcdFx0XHRyZXNldFlTZXJpZXMoZmFsc2UpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IHNpZGUgPSBheGlzLnNpZGU7XHJcblx0XHRcdGxldCBvcmkgPSBzaWRlICUgMjtcclxuXHJcblx0XHRcdGxldCB7bWluLCBtYXh9ID0gc2NhbGU7XHRcdC8vIFx0XHQvLyBzaG91bGQgdGhpcyB0b2dnbGUgdGhlbSAuX3Nob3cgPSBmYWxzZVxyXG5cclxuXHRcdFx0bGV0IFtfaW5jciwgX3NwYWNlXSA9IGdldEluY3JTcGFjZShpLCBtaW4sIG1heCwgb3JpID09IDAgPyBwbG90V2lkQ3NzIDogcGxvdEhndENzcyk7XHJcblxyXG5cdFx0XHRpZiAoX3NwYWNlID09IDApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0Ly8gaWYgd2UncmUgdXNpbmcgaW5kZXggcG9zaXRpb25zLCBmb3JjZSBmaXJzdCB0aWNrIHRvIG1hdGNoIHBhc3NlZCBpbmRleFxyXG5cdFx0XHRsZXQgZm9yY2VNaW4gPSBzY2FsZS5kaXN0ciA9PSAyO1xyXG5cclxuXHRcdFx0bGV0IF9zcGxpdHMgPSBheGlzLl9zcGxpdHMgPSBheGlzLnNwbGl0cyhzZWxmLCBpLCBtaW4sIG1heCwgX2luY3IsIF9zcGFjZSwgZm9yY2VNaW4pO1xyXG5cclxuXHRcdFx0Ly8gdGljayBsYWJlbHNcclxuXHRcdFx0Ly8gQk9PIHRoaXMgYXNzdW1lcyBhIHNwZWNpZmljIGRhdGEvc2VyaWVzXHJcblx0XHRcdGxldCBzcGxpdHMgPSBzY2FsZS5kaXN0ciA9PSAyID8gX3NwbGl0cy5tYXAoaSA9PiBkYXRhMFtpXSkgOiBfc3BsaXRzO1xyXG5cdFx0XHRsZXQgaW5jciAgID0gc2NhbGUuZGlzdHIgPT0gMiA/IGRhdGEwW19zcGxpdHNbMV1dIC0gZGF0YTBbX3NwbGl0c1swXV0gOiBfaW5jcjtcclxuXHJcblx0XHRcdGxldCB2YWx1ZXMgPSBheGlzLl92YWx1ZXMgPSBheGlzLnZhbHVlcyhzZWxmLCBheGlzLmZpbHRlcihzZWxmLCBzcGxpdHMsIGksIF9zcGFjZSwgaW5jciksIGksIF9zcGFjZSwgaW5jcik7XHJcblxyXG5cdFx0XHQvLyByb3RhdGluZyBvZiBsYWJlbHMgb25seSBzdXBwb3J0ZWQgb24gYm90dG9tIHggYXhpc1xyXG5cdFx0XHRheGlzLl9yb3RhdGUgPSBzaWRlID09IDIgPyBheGlzLnJvdGF0ZShzZWxmLCB2YWx1ZXMsIGksIF9zcGFjZSkgOiAwO1xyXG5cclxuXHRcdFx0bGV0IG9sZFNpemUgPSBheGlzLl9zaXplO1xyXG5cclxuXHRcdFx0YXhpcy5fc2l6ZSA9IGNlaWwoYXhpcy5zaXplKHNlbGYsIHZhbHVlcywgaSwgY3ljbGVOdW0pKTtcclxuXHJcblx0XHRcdGlmIChvbGRTaXplICE9IG51bGwgJiYgYXhpcy5fc2l6ZSAhPSBvbGRTaXplKVx0XHRcdC8vIHJlYWR5ICYmID9cclxuXHRcdFx0XHRjb252ZXJnZWQgPSBmYWxzZTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBjb252ZXJnZWQ7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwYWRkaW5nQ2FsYyhjeWNsZU51bSkge1xyXG5cdFx0bGV0IGNvbnZlcmdlZCA9IHRydWU7XHJcblxyXG5cdFx0cGFkZGluZy5mb3JFYWNoKChwLCBpKSA9PiB7XHJcblx0XHRcdGxldCBfcCA9IHAoc2VsZiwgaSwgc2lkZXNXaXRoQXhlcywgY3ljbGVOdW0pO1xyXG5cclxuXHRcdFx0aWYgKF9wICE9IF9wYWRkaW5nW2ldKVxyXG5cdFx0XHRcdGNvbnZlcmdlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0X3BhZGRpbmdbaV0gPSBfcDtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBjb252ZXJnZWQ7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkcmF3QXhlc0dyaWQoKSB7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGF4aXMgPSBheGVzW2ldO1xyXG5cclxuXHRcdFx0aWYgKCFheGlzLnNob3cgfHwgIWF4aXMuX3Nob3cpXHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRsZXQgc2lkZSA9IGF4aXMuc2lkZTtcclxuXHRcdFx0bGV0IG9yaSA9IHNpZGUgJSAyO1xyXG5cclxuXHRcdFx0bGV0IHgsIHk7XHJcblxyXG5cdFx0XHRsZXQgZmlsbFN0eWxlID0gYXhpcy5zdHJva2Uoc2VsZiwgaSk7XHJcblxyXG5cdFx0XHRsZXQgc2hpZnREaXIgPSBzaWRlID09IDAgfHwgc2lkZSA9PSAzID8gLTEgOiAxO1xyXG5cclxuXHRcdFx0Ly8gYXhpcyBsYWJlbFxyXG5cdFx0XHRpZiAoYXhpcy5sYWJlbCkge1xyXG5cdFx0XHRcdGxldCBzaGlmdEFtdCA9IGF4aXMubGFiZWxHYXAgKiBzaGlmdERpcjtcclxuXHRcdFx0XHRsZXQgYmFzZUxwb3MgPSByb3VuZCgoYXhpcy5fbHBvcyArIHNoaWZ0QW10KSAqIHB4UmF0aW8pO1xyXG5cclxuXHRcdFx0XHRzZXRGb250U3R5bGUoYXhpcy5sYWJlbEZvbnRbMF0sIGZpbGxTdHlsZSwgXCJjZW50ZXJcIiwgc2lkZSA9PSAyID8gVE9QIDogQk9UVE9NKTtcclxuXHJcblx0XHRcdFx0Y3R4LnNhdmUoKTtcclxuXHJcblx0XHRcdFx0aWYgKG9yaSA9PSAxKSB7XHJcblx0XHRcdFx0XHR4ID0geSA9IDA7XHJcblxyXG5cdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZShcclxuXHRcdFx0XHRcdFx0YmFzZUxwb3MsXHJcblx0XHRcdFx0XHRcdHJvdW5kKHBsb3RUb3AgKyBwbG90SGd0IC8gMiksXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0Y3R4LnJvdGF0ZSgoc2lkZSA9PSAzID8gLVBJIDogUEkpIC8gMik7XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHggPSByb3VuZChwbG90TGZ0ICsgcGxvdFdpZCAvIDIpO1xyXG5cdFx0XHRcdFx0eSA9IGJhc2VMcG9zO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KGF4aXMubGFiZWwsIHgsIHkpO1xyXG5cclxuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgW19pbmNyLCBfc3BhY2VdID0gYXhpcy5fZm91bmQ7XHJcblxyXG5cdFx0XHRpZiAoX3NwYWNlID09IDApXHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRsZXQgc2NhbGUgPSBzY2FsZXNbYXhpcy5zY2FsZV07XHJcblxyXG5cdFx0XHRsZXQgcGxvdERpbSA9IG9yaSA9PSAwID8gcGxvdFdpZCA6IHBsb3RIZ3Q7XHJcblx0XHRcdGxldCBwbG90T2ZmID0gb3JpID09IDAgPyBwbG90TGZ0IDogcGxvdFRvcDtcclxuXHJcblx0XHRcdGxldCBheGlzR2FwID0gcm91bmQoYXhpcy5nYXAgKiBweFJhdGlvKTtcclxuXHJcblx0XHRcdGxldCBfc3BsaXRzID0gYXhpcy5fc3BsaXRzO1xyXG5cclxuXHRcdFx0Ly8gdGljayBsYWJlbHNcclxuXHRcdFx0Ly8gQk9PIHRoaXMgYXNzdW1lcyBhIHNwZWNpZmljIGRhdGEvc2VyaWVzXHJcblx0XHRcdGxldCBzcGxpdHMgPSBzY2FsZS5kaXN0ciA9PSAyID8gX3NwbGl0cy5tYXAoaSA9PiBkYXRhMFtpXSkgOiBfc3BsaXRzO1xyXG5cdFx0XHRsZXQgaW5jciAgID0gc2NhbGUuZGlzdHIgPT0gMiA/IGRhdGEwW19zcGxpdHNbMV1dIC0gZGF0YTBbX3NwbGl0c1swXV0gOiBfaW5jcjtcclxuXHJcblx0XHRcdGxldCB0aWNrcyA9IGF4aXMudGlja3M7XHJcblx0XHRcdGxldCBib3JkZXIgPSBheGlzLmJvcmRlcjtcclxuXHRcdFx0bGV0IHRpY2tTaXplID0gdGlja3Muc2hvdyA/IHJvdW5kKHRpY2tzLnNpemUgKiBweFJhdGlvKSA6IDA7XHJcblxyXG5cdFx0XHQvLyByb3RhdGluZyBvZiBsYWJlbHMgb25seSBzdXBwb3J0ZWQgb24gYm90dG9tIHggYXhpc1xyXG5cdFx0XHRsZXQgYW5nbGUgPSBheGlzLl9yb3RhdGUgKiAtUEkvMTgwO1xyXG5cclxuXHRcdFx0bGV0IGJhc2VQb3MgID0gcHhSb3VuZChheGlzLl9wb3MgKiBweFJhdGlvKTtcclxuXHRcdFx0bGV0IHNoaWZ0QW10ID0gKHRpY2tTaXplICsgYXhpc0dhcCkgKiBzaGlmdERpcjtcclxuXHRcdFx0bGV0IGZpbmFsUG9zID0gYmFzZVBvcyArIHNoaWZ0QW10O1xyXG5cdFx0XHQgICAgeSAgICAgICAgPSBvcmkgPT0gMCA/IGZpbmFsUG9zIDogMDtcclxuXHRcdFx0ICAgIHggICAgICAgID0gb3JpID09IDEgPyBmaW5hbFBvcyA6IDA7XHJcblxyXG5cdFx0XHRsZXQgZm9udCAgICAgICAgID0gYXhpcy5mb250WzBdO1xyXG5cdFx0XHRsZXQgdGV4dEFsaWduICAgID0gYXhpcy5hbGlnbiA9PSAxID8gTEVGVCA6XHJcblx0XHRcdCAgICAgICAgICAgICAgICAgICBheGlzLmFsaWduID09IDIgPyBSSUdIVCA6XHJcblx0XHRcdCAgICAgICAgICAgICAgICAgICBhbmdsZSA+IDAgPyBMRUZUIDpcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgIGFuZ2xlIDwgMCA/IFJJR0hUIDpcclxuXHRcdFx0ICAgICAgICAgICAgICAgICAgIG9yaSA9PSAwID8gXCJjZW50ZXJcIiA6IHNpZGUgPT0gMyA/IFJJR0hUIDogTEVGVDtcclxuXHRcdFx0bGV0IHRleHRCYXNlbGluZSA9IGFuZ2xlIHx8XHJcblx0XHRcdCAgICAgICAgICAgICAgICAgICBvcmkgPT0gMSA/IFwibWlkZGxlXCIgOiBzaWRlID09IDIgPyBUT1AgICA6IEJPVFRPTTtcclxuXHJcblx0XHRcdHNldEZvbnRTdHlsZShmb250LCBmaWxsU3R5bGUsIHRleHRBbGlnbiwgdGV4dEJhc2VsaW5lKTtcclxuXHJcblx0XHRcdGxldCBsaW5lSGVpZ2h0ID0gYXhpcy5mb250WzFdICogYXhpcy5saW5lR2FwO1xyXG5cclxuXHRcdFx0bGV0IGNhbk9mZnMgPSBfc3BsaXRzLm1hcCh2YWwgPT4gcHhSb3VuZChnZXRQb3ModmFsLCBzY2FsZSwgcGxvdERpbSwgcGxvdE9mZikpKTtcclxuXHJcblx0XHRcdGxldCBfdmFsdWVzID0gYXhpcy5fdmFsdWVzO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBfdmFsdWVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0bGV0IHZhbCA9IF92YWx1ZXNbaV07XHJcblxyXG5cdFx0XHRcdGlmICh2YWwgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0aWYgKG9yaSA9PSAwKVxyXG5cdFx0XHRcdFx0XHR4ID0gY2FuT2Zmc1tpXTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0eSA9IGNhbk9mZnNbaV07XHJcblxyXG5cdFx0XHRcdFx0dmFsID0gXCJcIiArIHZhbDtcclxuXHJcblx0XHRcdFx0XHRsZXQgX3BhcnRzID0gdmFsLmluZGV4T2YoXCJcXG5cIikgPT0gLTEgPyBbdmFsXSA6IHZhbC5zcGxpdCgvXFxuL2dtKTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IF9wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdFx0XHRsZXQgdGV4dCA9IF9wYXJ0c1tqXTtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChhbmdsZSkge1xyXG5cdFx0XHRcdFx0XHRcdGN0eC5zYXZlKCk7XHJcblx0XHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh4LCB5ICsgaiAqIGxpbmVIZWlnaHQpOyAvLyBjYW4gdGhpcyBiZSByZXBsYWNlZCB3aXRoIHBvc2l0aW9uIG1hdGg/XHJcblx0XHRcdFx0XHRcdFx0Y3R4LnJvdGF0ZShhbmdsZSk7IC8vIGNhbiB0aGlzIGJlIGRvbmUgb25jZT9cclxuXHRcdFx0XHRcdFx0XHRjdHguZmlsbFRleHQodGV4dCwgMCwgMCk7XHJcblx0XHRcdFx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHQsIHgsIHkgKyBqICogbGluZUhlaWdodCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0aWNrc1xyXG5cdFx0XHRpZiAodGlja3Muc2hvdykge1xyXG5cdFx0XHRcdGRyYXdPcnRob0xpbmVzKFxyXG5cdFx0XHRcdFx0Y2FuT2ZmcyxcclxuXHRcdFx0XHRcdHRpY2tzLmZpbHRlcihzZWxmLCBzcGxpdHMsIGksIF9zcGFjZSwgaW5jciksXHJcblx0XHRcdFx0XHRvcmksXHJcblx0XHRcdFx0XHRzaWRlLFxyXG5cdFx0XHRcdFx0YmFzZVBvcyxcclxuXHRcdFx0XHRcdHRpY2tTaXplLFxyXG5cdFx0XHRcdFx0cm91bmREZWModGlja3Mud2lkdGggKiBweFJhdGlvLCAzKSxcclxuXHRcdFx0XHRcdHRpY2tzLnN0cm9rZShzZWxmLCBpKSxcclxuXHRcdFx0XHRcdHRpY2tzLmRhc2gsXHJcblx0XHRcdFx0XHR0aWNrcy5jYXAsXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZ3JpZFxyXG5cdFx0XHRsZXQgZ3JpZCA9IGF4aXMuZ3JpZDtcclxuXHJcblx0XHRcdGlmIChncmlkLnNob3cpIHtcclxuXHRcdFx0XHRkcmF3T3J0aG9MaW5lcyhcclxuXHRcdFx0XHRcdGNhbk9mZnMsXHJcblx0XHRcdFx0XHRncmlkLmZpbHRlcihzZWxmLCBzcGxpdHMsIGksIF9zcGFjZSwgaW5jciksXHJcblx0XHRcdFx0XHRvcmksXHJcblx0XHRcdFx0XHRvcmkgPT0gMCA/IDIgOiAxLFxyXG5cdFx0XHRcdFx0b3JpID09IDAgPyBwbG90VG9wIDogcGxvdExmdCxcclxuXHRcdFx0XHRcdG9yaSA9PSAwID8gcGxvdEhndCA6IHBsb3RXaWQsXHJcblx0XHRcdFx0XHRyb3VuZERlYyhncmlkLndpZHRoICogcHhSYXRpbywgMyksXHJcblx0XHRcdFx0XHRncmlkLnN0cm9rZShzZWxmLCBpKSxcclxuXHRcdFx0XHRcdGdyaWQuZGFzaCxcclxuXHRcdFx0XHRcdGdyaWQuY2FwLFxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChib3JkZXIuc2hvdykge1xyXG5cdFx0XHRcdGRyYXdPcnRob0xpbmVzKFxyXG5cdFx0XHRcdFx0W2Jhc2VQb3NdLFxyXG5cdFx0XHRcdFx0WzFdLFxyXG5cdFx0XHRcdFx0b3JpID09IDAgPyAxIDogMCxcclxuXHRcdFx0XHRcdG9yaSA9PSAwID8gMSA6IDIsXHJcblx0XHRcdFx0XHRvcmkgPT0gMSA/IHBsb3RUb3AgOiBwbG90TGZ0LFxyXG5cdFx0XHRcdFx0b3JpID09IDEgPyBwbG90SGd0IDogcGxvdFdpZCxcclxuXHRcdFx0XHRcdHJvdW5kRGVjKGJvcmRlci53aWR0aCAqIHB4UmF0aW8sIDMpLFxyXG5cdFx0XHRcdFx0Ym9yZGVyLnN0cm9rZShzZWxmLCBpKSxcclxuXHRcdFx0XHRcdGJvcmRlci5kYXNoLFxyXG5cdFx0XHRcdFx0Ym9yZGVyLmNhcCxcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0ZmlyZShcImRyYXdBeGVzXCIpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVzZXRZU2VyaWVzKG1pbk1heCkge1xyXG5cdC8vXHRsb2coXCJyZXNldFlTZXJpZXMoKVwiLCBhcmd1bWVudHMpO1xyXG5cclxuXHRcdHNlcmllcy5mb3JFYWNoKChzLCBpKSA9PiB7XHJcblx0XHRcdGlmIChpID4gMCkge1xyXG5cdFx0XHRcdHMuX3BhdGhzID0gbnVsbDtcclxuXHJcblx0XHRcdFx0aWYgKG1pbk1heCkge1xyXG5cdFx0XHRcdFx0aWYgKG1vZGUgPT0gMSkge1xyXG5cdFx0XHRcdFx0XHRzLm1pbiA9IG51bGw7XHJcblx0XHRcdFx0XHRcdHMubWF4ID0gbnVsbDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRzLmZhY2V0cy5mb3JFYWNoKGYgPT4ge1xyXG5cdFx0XHRcdFx0XHRcdGYubWluID0gbnVsbDtcclxuXHRcdFx0XHRcdFx0XHRmLm1heCA9IG51bGw7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRsZXQgcXVldWVkQ29tbWl0ID0gZmFsc2U7XHJcblxyXG5cdGZ1bmN0aW9uIGNvbW1pdCgpIHtcclxuXHRcdGlmICghcXVldWVkQ29tbWl0KSB7XHJcblx0XHRcdG1pY3JvVGFzayhfY29tbWl0KTtcclxuXHRcdFx0cXVldWVkQ29tbWl0ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIF9jb21taXQoKSB7XHJcblx0Ly9cdGxvZyhcIl9jb21taXQoKVwiLCBhcmd1bWVudHMpO1xyXG5cclxuXHRcdGlmIChzaG91bGRTZXRTY2FsZXMpIHtcclxuXHRcdFx0c2V0U2NhbGVzKCk7XHJcblx0XHRcdHNob3VsZFNldFNjYWxlcyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzaG91bGRDb252ZXJnZVNpemUpIHtcclxuXHRcdFx0Y29udmVyZ2VTaXplKCk7XHJcblx0XHRcdHNob3VsZENvbnZlcmdlU2l6ZSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzaG91bGRTZXRTaXplKSB7XHJcblx0XHRcdHNldFN0eWxlUHgodW5kZXIsIExFRlQsICAgcGxvdExmdENzcyk7XHJcblx0XHRcdHNldFN0eWxlUHgodW5kZXIsIFRPUCwgICAgcGxvdFRvcENzcyk7XHJcblx0XHRcdHNldFN0eWxlUHgodW5kZXIsIFdJRFRILCAgcGxvdFdpZENzcyk7XHJcblx0XHRcdHNldFN0eWxlUHgodW5kZXIsIEhFSUdIVCwgcGxvdEhndENzcyk7XHJcblxyXG5cdFx0XHRzZXRTdHlsZVB4KG92ZXIsIExFRlQsICAgIHBsb3RMZnRDc3MpO1xyXG5cdFx0XHRzZXRTdHlsZVB4KG92ZXIsIFRPUCwgICAgIHBsb3RUb3BDc3MpO1xyXG5cdFx0XHRzZXRTdHlsZVB4KG92ZXIsIFdJRFRILCAgIHBsb3RXaWRDc3MpO1xyXG5cdFx0XHRzZXRTdHlsZVB4KG92ZXIsIEhFSUdIVCwgIHBsb3RIZ3RDc3MpO1xyXG5cclxuXHRcdFx0c2V0U3R5bGVQeCh3cmFwLCBXSURUSCwgICBmdWxsV2lkQ3NzKTtcclxuXHRcdFx0c2V0U3R5bGVQeCh3cmFwLCBIRUlHSFQsICBmdWxsSGd0Q3NzKTtcclxuXHJcblx0XHRcdC8vIE5PVEU6IG11dGF0aW5nIHRoaXMgZHVyaW5nIHByaW50IHByZXZpZXcgaW4gQ2hyb21lIGZvcmNlcyB0cmFuc3BhcmVudFxyXG5cdFx0XHQvLyBjYW52YXMgcGl4ZWxzIHRvIHdoaXRlLCBldmVuIHdoZW4gZm9sbG93ZWQgdXAgd2l0aCBjbGVhclJlY3QoKSBiZWxvd1xyXG5cdFx0XHRjYW4ud2lkdGggID0gcm91bmQoZnVsbFdpZENzcyAqIHB4UmF0aW8pO1xyXG5cdFx0XHRjYW4uaGVpZ2h0ID0gcm91bmQoZnVsbEhndENzcyAqIHB4UmF0aW8pO1xyXG5cclxuXHRcdFx0YXhlcy5mb3JFYWNoKCh7IF9lbCwgX3Nob3csIF9zaXplLCBfcG9zLCBzaWRlIH0pID0+IHtcclxuXHRcdFx0XHRpZiAoX2VsICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGlmIChfc2hvdykge1xyXG5cdFx0XHRcdFx0XHRsZXQgcG9zT2Zmc2V0ID0gKHNpZGUgPT09IDMgfHwgc2lkZSA9PT0gMCA/IF9zaXplIDogMCk7XHJcblx0XHRcdFx0XHRcdGxldCBpc1Z0ID0gc2lkZSAlIDIgPT0gMTtcclxuXHJcblx0XHRcdFx0XHRcdHNldFN0eWxlUHgoX2VsLCBpc1Z0ID8gXCJsZWZ0XCIgICA6IFwidG9wXCIsICAgIF9wb3MgLSBwb3NPZmZzZXQpO1xyXG5cdFx0XHRcdFx0XHRzZXRTdHlsZVB4KF9lbCwgaXNWdCA/IFwid2lkdGhcIiAgOiBcImhlaWdodFwiLCBfc2l6ZSk7XHJcblx0XHRcdFx0XHRcdHNldFN0eWxlUHgoX2VsLCBpc1Z0ID8gXCJ0b3BcIiAgICA6IFwibGVmdFwiLCAgIGlzVnQgPyBwbG90VG9wQ3NzIDogcGxvdExmdENzcyk7XHJcblx0XHRcdFx0XHRcdHNldFN0eWxlUHgoX2VsLCBpc1Z0ID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIiwgIGlzVnQgPyBwbG90SGd0Q3NzIDogcGxvdFdpZENzcyk7XHJcblxyXG5cdFx0XHRcdFx0XHRyZW1DbGFzcyhfZWwsIE9GRik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdGFkZENsYXNzKF9lbCwgT0ZGKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gaW52YWxpZGF0ZSBjdHggc3R5bGUgY2FjaGVcclxuXHRcdFx0Y3R4U3Ryb2tlID0gY3R4RmlsbCA9IGN0eFdpZHRoID0gY3R4Sm9pbiA9IGN0eENhcCA9IGN0eEZvbnQgPSBjdHhBbGlnbiA9IGN0eEJhc2VsaW5lID0gY3R4RGFzaCA9IG51bGw7XHJcblx0XHRcdGN0eEFscGhhID0gMTtcclxuXHJcblx0XHRcdHN5bmNSZWN0KHRydWUpO1xyXG5cclxuXHRcdFx0ZmlyZShcInNldFNpemVcIik7XHJcblxyXG5cdFx0XHRzaG91bGRTZXRTaXplID0gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGZ1bGxXaWRDc3MgPiAwICYmIGZ1bGxIZ3RDc3MgPiAwKSB7XHJcblx0XHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgY2FuLndpZHRoLCBjYW4uaGVpZ2h0KTtcclxuXHRcdFx0ZmlyZShcImRyYXdDbGVhclwiKTtcclxuXHRcdFx0ZHJhd09yZGVyLmZvckVhY2goZm4gPT4gZm4oKSk7XHJcblx0XHRcdGZpcmUoXCJkcmF3XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzZWxlY3Quc2hvdyAmJiBzaG91bGRTZXRTZWxlY3QpIHtcclxuXHRcdFx0c2V0U2VsZWN0KHNlbGVjdCk7XHJcblx0XHRcdHNob3VsZFNldFNlbGVjdCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjdXJzb3Iuc2hvdyAmJiBzaG91bGRTZXRDdXJzb3IpIHtcclxuXHRcdFx0dXBkYXRlQ3Vyc29yKG51bGwsIHRydWUsIGZhbHNlKTtcclxuXHRcdFx0c2hvdWxkU2V0Q3Vyc29yID0gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxlZ2VuZC5zaG93ICYmIGxlZ2VuZC5saXZlICYmIHNob3VsZFNldExlZ2VuZCkge1xyXG5cdFx0XHRzZXRMZWdlbmQoKTtcclxuXHRcdFx0c2hvdWxkU2V0TGVnZW5kID0gZmFsc2U7IC8vIHJlZHVuZGFudCBjdXJyZW50bHlcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXJlYWR5KSB7XHJcblx0XHRcdHJlYWR5ID0gdHJ1ZTtcclxuXHRcdFx0c2VsZi5zdGF0dXMgPSAxO1xyXG5cclxuXHRcdFx0ZmlyZShcInJlYWR5XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZpYUF1dG9TY2FsZVggPSBmYWxzZTtcclxuXHJcblx0XHRxdWV1ZWRDb21taXQgPSBmYWxzZTtcclxuXHR9XHJcblxyXG5cdHNlbGYucmVkcmF3ID0gKHJlYnVpbGRQYXRocywgcmVjYWxjQXhlcykgPT4ge1xyXG5cdFx0c2hvdWxkQ29udmVyZ2VTaXplID0gcmVjYWxjQXhlcyB8fCBmYWxzZTtcclxuXHJcblx0XHRpZiAocmVidWlsZFBhdGhzICE9PSBmYWxzZSlcclxuXHRcdFx0X3NldFNjYWxlKHhTY2FsZUtleSwgc2NhbGVYLm1pbiwgc2NhbGVYLm1heCk7XHJcblx0XHRlbHNlXHJcblx0XHRcdGNvbW1pdCgpO1xyXG5cdH07XHJcblxyXG5cdC8vIHJlZHJhdygpID0+IHNldFNjYWxlKCd4Jywgc2NhbGVzLngubWluLCBzY2FsZXMueC5tYXgpO1xyXG5cclxuXHQvLyBleHBsaWNpdCwgbmV2ZXIgcmUtcmFuZ2VkIChpcyB0aGlzIGFjdHVhbGx5IHRydWU/IGZvciB4IGFuZCB5KVxyXG5cdGZ1bmN0aW9uIHNldFNjYWxlKGtleSwgb3B0cykge1xyXG5cdFx0bGV0IHNjID0gc2NhbGVzW2tleV07XHJcblxyXG5cdFx0aWYgKHNjLmZyb20gPT0gbnVsbCkge1xyXG5cdFx0XHRpZiAoZGF0YUxlbiA9PSAwKSB7XHJcblx0XHRcdFx0bGV0IG1pbk1heCA9IHNjLnJhbmdlKHNlbGYsIG9wdHMubWluLCBvcHRzLm1heCwga2V5KTtcclxuXHRcdFx0XHRvcHRzLm1pbiA9IG1pbk1heFswXTtcclxuXHRcdFx0XHRvcHRzLm1heCA9IG1pbk1heFsxXTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKG9wdHMubWluID4gb3B0cy5tYXgpIHtcclxuXHRcdFx0XHRsZXQgX21pbiA9IG9wdHMubWluO1xyXG5cdFx0XHRcdG9wdHMubWluID0gb3B0cy5tYXg7XHJcblx0XHRcdFx0b3B0cy5tYXggPSBfbWluO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZGF0YUxlbiA+IDEgJiYgb3B0cy5taW4gIT0gbnVsbCAmJiBvcHRzLm1heCAhPSBudWxsICYmIG9wdHMubWF4IC0gb3B0cy5taW4gPCAxZS0xNilcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRpZiAoa2V5ID09IHhTY2FsZUtleSkge1xyXG5cdFx0XHRcdGlmIChzYy5kaXN0ciA9PSAyICYmIGRhdGFMZW4gPiAwKSB7XHJcblx0XHRcdFx0XHRvcHRzLm1pbiA9IGNsb3Nlc3RJZHgob3B0cy5taW4sIGRhdGFbMF0pO1xyXG5cdFx0XHRcdFx0b3B0cy5tYXggPSBjbG9zZXN0SWR4KG9wdHMubWF4LCBkYXRhWzBdKTtcclxuXHJcblx0XHRcdFx0XHRpZiAob3B0cy5taW4gPT0gb3B0cy5tYXgpXHJcblx0XHRcdFx0XHRcdG9wdHMubWF4Kys7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0Ly9cdGxvZyhcInNldFNjYWxlKClcIiwgYXJndW1lbnRzKTtcclxuXHJcblx0XHRcdHBlbmRTY2FsZXNba2V5XSA9IG9wdHM7XHJcblxyXG5cdFx0XHRzaG91bGRTZXRTY2FsZXMgPSB0cnVlO1xyXG5cdFx0XHRjb21taXQoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHNlbGYuc2V0U2NhbGUgPSBzZXRTY2FsZTtcclxuXHJcbi8vXHRJTlRFUkFDVElPTlxyXG5cclxuXHRsZXQgeEN1cnNvcjtcclxuXHRsZXQgeUN1cnNvcjtcclxuXHRsZXQgdkN1cnNvcjtcclxuXHRsZXQgaEN1cnNvcjtcclxuXHJcblx0Ly8gc3RhcnRpbmcgcG9zaXRpb24gYmVmb3JlIGN1cnNvci5tb3ZlXHJcblx0bGV0IHJhd01vdXNlTGVmdDA7XHJcblx0bGV0IHJhd01vdXNlVG9wMDtcclxuXHJcblx0Ly8gc3RhcnRpbmcgcG9zaXRpb25cclxuXHRsZXQgbW91c2VMZWZ0MDtcclxuXHRsZXQgbW91c2VUb3AwO1xyXG5cclxuXHQvLyBjdXJyZW50IHBvc2l0aW9uIGJlZm9yZSBjdXJzb3IubW92ZVxyXG5cdGxldCByYXdNb3VzZUxlZnQxO1xyXG5cdGxldCByYXdNb3VzZVRvcDE7XHJcblxyXG5cdC8vIGN1cnJlbnQgcG9zaXRpb25cclxuXHRsZXQgbW91c2VMZWZ0MTtcclxuXHRsZXQgbW91c2VUb3AxO1xyXG5cclxuXHRsZXQgZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHJcblx0Y29uc3QgZHJhZyA9IGN1cnNvci5kcmFnO1xyXG5cclxuXHRsZXQgZHJhZ1ggPSBkcmFnLng7XHJcblx0bGV0IGRyYWdZID0gZHJhZy55O1xyXG5cclxuXHRpZiAoY3Vyc29yLnNob3cpIHtcclxuXHRcdGlmIChjdXJzb3IueClcclxuXHRcdFx0eEN1cnNvciA9IHBsYWNlRGl2KENVUlNPUl9YLCBvdmVyKTtcclxuXHRcdGlmIChjdXJzb3IueSlcclxuXHRcdFx0eUN1cnNvciA9IHBsYWNlRGl2KENVUlNPUl9ZLCBvdmVyKTtcclxuXHJcblx0XHRpZiAoc2NhbGVYLm9yaSA9PSAwKSB7XHJcblx0XHRcdHZDdXJzb3IgPSB4Q3Vyc29yO1xyXG5cdFx0XHRoQ3Vyc29yID0geUN1cnNvcjtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR2Q3Vyc29yID0geUN1cnNvcjtcclxuXHRcdFx0aEN1cnNvciA9IHhDdXJzb3I7XHJcblx0XHR9XHJcblxyXG5cdFx0bW91c2VMZWZ0MSA9IGN1cnNvci5sZWZ0O1xyXG5cdFx0bW91c2VUb3AxID0gY3Vyc29yLnRvcDtcclxuXHR9XHJcblxyXG5cdGNvbnN0IHNlbGVjdCA9IHNlbGYuc2VsZWN0ID0gYXNzaWduKHtcclxuXHRcdHNob3c6ICAgdHJ1ZSxcclxuXHRcdG92ZXI6ICAgdHJ1ZSxcclxuXHRcdGxlZnQ6ICAgMCxcclxuXHRcdHdpZHRoOiAgMCxcclxuXHRcdHRvcDogICAgMCxcclxuXHRcdGhlaWdodDogMCxcclxuXHR9LCBvcHRzLnNlbGVjdCk7XHJcblxyXG5cdGNvbnN0IHNlbGVjdERpdiA9IHNlbGVjdC5zaG93ID8gcGxhY2VEaXYoU0VMRUNULCBzZWxlY3Qub3ZlciA/IG92ZXIgOiB1bmRlcikgOiBudWxsO1xyXG5cclxuXHRmdW5jdGlvbiBzZXRTZWxlY3Qob3B0cywgX2ZpcmUpIHtcclxuXHRcdGlmIChzZWxlY3Quc2hvdykge1xyXG5cdFx0XHRmb3IgKGxldCBwcm9wIGluIG9wdHMpIHtcclxuXHRcdFx0XHRzZWxlY3RbcHJvcF0gPSBvcHRzW3Byb3BdO1xyXG5cclxuXHRcdFx0XHRpZiAocHJvcCBpbiBfaGlkZVByb3BzKVxyXG5cdFx0XHRcdFx0c2V0U3R5bGVQeChzZWxlY3REaXYsIHByb3AsIG9wdHNbcHJvcF0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZmlyZSAhPT0gZmFsc2UgJiYgZmlyZShcInNldFNlbGVjdFwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHNlbGYuc2V0U2VsZWN0ID0gc2V0U2VsZWN0O1xyXG5cclxuXHRmdW5jdGlvbiB0b2dnbGVET00oaSwgb25PZmYpIHtcclxuXHRcdGxldCBzID0gc2VyaWVzW2ldO1xyXG5cdFx0bGV0IGxhYmVsID0gc2hvd0xlZ2VuZCA/IGxlZ2VuZFJvd3NbaV0gOiBudWxsO1xyXG5cclxuXHRcdGlmIChzLnNob3cpXHJcblx0XHRcdGxhYmVsICYmIHJlbUNsYXNzKGxhYmVsLCBPRkYpO1xyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGxhYmVsICYmIGFkZENsYXNzKGxhYmVsLCBPRkYpO1xyXG5cdFx0XHRjdXJzb3JQdHMubGVuZ3RoID4gMSAmJiBlbFRyYW5zKGN1cnNvclB0c1tpXSwgLTEwLCAtMTAsIHBsb3RXaWRDc3MsIHBsb3RIZ3RDc3MpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gX3NldFNjYWxlKGtleSwgbWluLCBtYXgpIHtcclxuXHRcdHNldFNjYWxlKGtleSwge21pbiwgbWF4fSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRTZXJpZXMoaSwgb3B0cywgX2ZpcmUsIF9wdWIpIHtcclxuXHQvL1x0bG9nKFwic2V0U2VyaWVzKClcIiwgYXJndW1lbnRzKTtcclxuXHJcblx0XHRpZiAob3B0cy5mb2N1cyAhPSBudWxsKVxyXG5cdFx0XHRzZXRGb2N1cyhpKTtcclxuXHJcblx0XHRpZiAob3B0cy5zaG93ICE9IG51bGwpIHtcclxuXHRcdFx0c2VyaWVzLmZvckVhY2goKHMsIHNpKSA9PiB7XHJcblx0XHRcdFx0aWYgKHNpID4gMCAmJiAoaSA9PSBzaSB8fCBpID09IG51bGwpKSB7XHJcblx0XHRcdFx0XHRzLnNob3cgPSBvcHRzLnNob3c7XHJcblx0XHRcdFx0XHR0b2dnbGVET00oc2ksIG9wdHMuc2hvdyk7XHJcblxyXG5cdFx0XHRcdFx0X3NldFNjYWxlKG1vZGUgPT0gMiA/IHMuZmFjZXRzWzFdLnNjYWxlIDogcy5zY2FsZSwgbnVsbCwgbnVsbCk7XHJcblx0XHRcdFx0XHRjb21taXQoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdF9maXJlICE9PSBmYWxzZSAmJiBmaXJlKFwic2V0U2VyaWVzXCIsIGksIG9wdHMpO1xyXG5cclxuXHRcdF9wdWIgJiYgcHViU3luYyhcInNldFNlcmllc1wiLCBzZWxmLCBpLCBvcHRzKTtcclxuXHR9XHJcblxyXG5cdHNlbGYuc2V0U2VyaWVzID0gc2V0U2VyaWVzO1xyXG5cclxuXHRmdW5jdGlvbiBzZXRCYW5kKGJpLCBvcHRzKSB7XHJcblx0XHRhc3NpZ24oYmFuZHNbYmldLCBvcHRzKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFkZEJhbmQob3B0cywgYmkpIHtcclxuXHRcdG9wdHMuZmlsbCA9IGZuT3JTZWxmKG9wdHMuZmlsbCB8fCBudWxsKTtcclxuXHRcdG9wdHMuZGlyID0gaWZOdWxsKG9wdHMuZGlyLCAtMSk7XHJcblx0XHRiaSA9IGJpID09IG51bGwgPyBiYW5kcy5sZW5ndGggOiBiaTtcclxuXHRcdGJhbmRzLnNwbGljZShiaSwgMCwgb3B0cyk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkZWxCYW5kKGJpKSB7XHJcblx0XHRpZiAoYmkgPT0gbnVsbClcclxuXHRcdFx0YmFuZHMubGVuZ3RoID0gMDtcclxuXHRcdGVsc2VcclxuXHRcdFx0YmFuZHMuc3BsaWNlKGJpLCAxKTtcclxuXHR9XHJcblxyXG5cdHNlbGYuYWRkQmFuZCA9IGFkZEJhbmQ7XHJcblx0c2VsZi5zZXRCYW5kID0gc2V0QmFuZDtcclxuXHRzZWxmLmRlbEJhbmQgPSBkZWxCYW5kO1xyXG5cclxuXHRmdW5jdGlvbiBzZXRBbHBoYShpLCB2YWx1ZSkge1xyXG5cdFx0c2VyaWVzW2ldLmFscGhhID0gdmFsdWU7XHJcblxyXG5cdFx0aWYgKGN1cnNvci5zaG93ICYmIGN1cnNvclB0c1tpXSlcclxuXHRcdFx0Y3Vyc29yUHRzW2ldLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHJcblx0XHRpZiAoc2hvd0xlZ2VuZCAmJiBsZWdlbmRSb3dzW2ldKVxyXG5cdFx0XHRsZWdlbmRSb3dzW2ldLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdC8vIHktZGlzdGFuY2VcclxuXHRsZXQgY2xvc2VzdERpc3Q7XHJcblx0bGV0IGNsb3Nlc3RTZXJpZXM7XHJcblx0bGV0IGZvY3VzZWRTZXJpZXM7XHJcblx0Y29uc3QgRk9DVVNfVFJVRSAgPSB7Zm9jdXM6IHRydWV9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXRGb2N1cyhpKSB7XHJcblx0XHRpZiAoaSAhPSBmb2N1c2VkU2VyaWVzKSB7XHJcblx0XHQvL1x0bG9nKFwic2V0Rm9jdXMoKVwiLCBhcmd1bWVudHMpO1xyXG5cclxuXHRcdFx0bGV0IGFsbEZvY3VzZWQgPSBpID09IG51bGw7XHJcblxyXG5cdFx0XHRsZXQgX3NldEFscGhhID0gZm9jdXMuYWxwaGEgIT0gMTtcclxuXHJcblx0XHRcdHNlcmllcy5mb3JFYWNoKChzLCBpMikgPT4ge1xyXG5cdFx0XHRcdGxldCBpc0ZvY3VzZWQgPSBhbGxGb2N1c2VkIHx8IGkyID09IDAgfHwgaTIgPT0gaTtcclxuXHRcdFx0XHRzLl9mb2N1cyA9IGFsbEZvY3VzZWQgPyBudWxsIDogaXNGb2N1c2VkO1xyXG5cdFx0XHRcdF9zZXRBbHBoYSAmJiBzZXRBbHBoYShpMiwgaXNGb2N1c2VkID8gMSA6IGZvY3VzLmFscGhhKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRmb2N1c2VkU2VyaWVzID0gaTtcclxuXHRcdFx0X3NldEFscGhhICYmIGNvbW1pdCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKHNob3dMZWdlbmQgJiYgY3Vyc29yRm9jdXMpIHtcclxuXHRcdG9uTW91c2UobW91c2VsZWF2ZSwgbGVnZW5kVGFibGUsIGUgPT4ge1xyXG5cdFx0XHRpZiAoY3Vyc29yLl9sb2NrKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdHNldEN1cnNvckV2ZW50KGUpO1xyXG5cclxuXHRcdFx0aWYgKGZvY3VzZWRTZXJpZXMgIT0gbnVsbClcclxuXHRcdFx0XHRzZXRTZXJpZXMobnVsbCwgRk9DVVNfVFJVRSwgdHJ1ZSwgc3luY09wdHMuc2V0U2VyaWVzKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcG9zVG9WYWwocG9zLCBzY2FsZSwgY2FuKSB7XHJcblx0XHRsZXQgc2MgPSBzY2FsZXNbc2NhbGVdO1xyXG5cclxuXHRcdGlmIChjYW4pXHJcblx0XHRcdHBvcyA9IHBvcyAvIHB4UmF0aW8gLSAoc2Mub3JpID09IDEgPyBwbG90VG9wQ3NzIDogcGxvdExmdENzcyk7XHJcblxyXG5cdFx0bGV0IGRpbSA9IHBsb3RXaWRDc3M7XHJcblxyXG5cdFx0aWYgKHNjLm9yaSA9PSAxKSB7XHJcblx0XHRcdGRpbSA9IHBsb3RIZ3RDc3M7XHJcblx0XHRcdHBvcyA9IGRpbSAtIHBvcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2MuZGlyID09IC0xKVxyXG5cdFx0XHRwb3MgPSBkaW0gLSBwb3M7XHJcblxyXG5cdFx0bGV0IF9taW4gPSBzYy5fbWluLFxyXG5cdFx0XHRfbWF4ID0gc2MuX21heCxcclxuXHRcdFx0cGN0ID0gcG9zIC8gZGltO1xyXG5cclxuXHRcdGxldCBzdiA9IF9taW4gKyAoX21heCAtIF9taW4pICogcGN0O1xyXG5cclxuXHRcdGxldCBkaXN0ciA9IHNjLmRpc3RyO1xyXG5cclxuXHRcdHJldHVybiAoXHJcblx0XHRcdGRpc3RyID09IDMgPyBwb3coMTAsIHN2KSA6XHJcblx0XHRcdGRpc3RyID09IDQgPyBzaW5oKHN2LCBzYy5hc2luaCkgOlxyXG5cdFx0XHRzdlxyXG5cdFx0KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNsb3Nlc3RJZHhGcm9tWHBvcyhwb3MsIGNhbikge1xyXG5cdFx0bGV0IHYgPSBwb3NUb1ZhbChwb3MsIHhTY2FsZUtleSwgY2FuKTtcclxuXHRcdHJldHVybiBjbG9zZXN0SWR4KHYsIGRhdGFbMF0sIGkwLCBpMSk7XHJcblx0fVxyXG5cclxuXHRzZWxmLnZhbFRvSWR4ID0gdmFsID0+IGNsb3Nlc3RJZHgodmFsLCBkYXRhWzBdKTtcclxuXHRzZWxmLnBvc1RvSWR4ID0gY2xvc2VzdElkeEZyb21YcG9zO1xyXG5cdHNlbGYucG9zVG9WYWwgPSBwb3NUb1ZhbDtcclxuXHRzZWxmLnZhbFRvUG9zID0gKHZhbCwgc2NhbGUsIGNhbikgPT4gKFxyXG5cdFx0c2NhbGVzW3NjYWxlXS5vcmkgPT0gMCA/XHJcblx0XHRnZXRIUG9zKHZhbCwgc2NhbGVzW3NjYWxlXSxcclxuXHRcdFx0Y2FuID8gcGxvdFdpZCA6IHBsb3RXaWRDc3MsXHJcblx0XHRcdGNhbiA/IHBsb3RMZnQgOiAwLFxyXG5cdFx0KSA6XHJcblx0XHRnZXRWUG9zKHZhbCwgc2NhbGVzW3NjYWxlXSxcclxuXHRcdFx0Y2FuID8gcGxvdEhndCA6IHBsb3RIZ3RDc3MsXHJcblx0XHRcdGNhbiA/IHBsb3RUb3AgOiAwLFxyXG5cdFx0KVxyXG5cdCk7XHJcblxyXG5cdC8vIGRlZmVycyBjYWxsaW5nIGV4cGVuc2l2ZSBmdW5jdGlvbnNcclxuXHRmdW5jdGlvbiBiYXRjaChmbikge1xyXG5cdFx0Zm4oc2VsZik7XHJcblx0XHRjb21taXQoKTtcclxuXHR9XHJcblxyXG5cdHNlbGYuYmF0Y2ggPSBiYXRjaDtcclxuXHJcblx0c2VsZi5zZXRDdXJzb3IgPSAob3B0cywgX2ZpcmUsIF9wdWIpID0+IHtcclxuXHRcdG1vdXNlTGVmdDEgPSBvcHRzLmxlZnQ7XHJcblx0XHRtb3VzZVRvcDEgPSBvcHRzLnRvcDtcclxuXHQvL1x0YXNzaWduKGN1cnNvciwgb3B0cyk7XHJcblx0XHR1cGRhdGVDdXJzb3IobnVsbCwgX2ZpcmUsIF9wdWIpO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldFNlbEgob2ZmLCBkaW0pIHtcclxuXHRcdHNldFN0eWxlUHgoc2VsZWN0RGl2LCBMRUZULCAgc2VsZWN0LmxlZnQgPSBvZmYpO1xyXG5cdFx0c2V0U3R5bGVQeChzZWxlY3REaXYsIFdJRFRILCBzZWxlY3Qud2lkdGggPSBkaW0pO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0U2VsVihvZmYsIGRpbSkge1xyXG5cdFx0c2V0U3R5bGVQeChzZWxlY3REaXYsIFRPUCwgICAgc2VsZWN0LnRvcCA9IG9mZik7XHJcblx0XHRzZXRTdHlsZVB4KHNlbGVjdERpdiwgSEVJR0hULCBzZWxlY3QuaGVpZ2h0ID0gZGltKTtcclxuXHR9XHJcblxyXG5cdGxldCBzZXRTZWxYID0gc2NhbGVYLm9yaSA9PSAwID8gc2V0U2VsSCA6IHNldFNlbFY7XHJcblx0bGV0IHNldFNlbFkgPSBzY2FsZVgub3JpID09IDEgPyBzZXRTZWxIIDogc2V0U2VsVjtcclxuXHJcblx0ZnVuY3Rpb24gc3luY0xlZ2VuZCgpIHtcclxuXHRcdGlmIChzaG93TGVnZW5kICYmIGxlZ2VuZC5saXZlKSB7XHJcblx0XHRcdGZvciAobGV0IGkgPSBtb2RlID09IDIgPyAxIDogMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmIChpID09IDAgJiYgbXVsdGlWYWxMZWdlbmQpXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0bGV0IHZhbHMgPSBsZWdlbmQudmFsdWVzW2ldO1xyXG5cclxuXHRcdFx0XHRsZXQgaiA9IDA7XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGsgaW4gdmFscylcclxuXHRcdFx0XHRcdGxlZ2VuZENlbGxzW2ldW2orK10uZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB2YWxzW2tdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRMZWdlbmQob3B0cywgX2ZpcmUpIHtcclxuXHRcdGlmIChvcHRzICE9IG51bGwpIHtcclxuXHRcdFx0aWYgKG9wdHMuaWR4cykge1xyXG5cdFx0XHRcdG9wdHMuaWR4cy5mb3JFYWNoKChkaWR4LCBzaWR4KSA9PiB7XHJcblx0XHRcdFx0XHRhY3RpdmVJZHhzW3NpZHhdID0gZGlkeDtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICghaXNVbmRlZihvcHRzLmlkeCkpXHJcblx0XHRcdFx0YWN0aXZlSWR4cy5maWxsKG9wdHMuaWR4KTtcclxuXHJcblx0XHRcdGxlZ2VuZC5pZHggPSBhY3RpdmVJZHhzWzBdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IHNpZHggPSAwOyBzaWR4IDwgc2VyaWVzLmxlbmd0aDsgc2lkeCsrKSB7XHJcblx0XHRcdGlmIChzaWR4ID4gMCB8fCBtb2RlID09IDEgJiYgIW11bHRpVmFsTGVnZW5kKVxyXG5cdFx0XHRcdHNldExlZ2VuZFZhbHVlcyhzaWR4LCBhY3RpdmVJZHhzW3NpZHhdKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2hvd0xlZ2VuZCAmJiBsZWdlbmQubGl2ZSlcclxuXHRcdFx0c3luY0xlZ2VuZCgpO1xyXG5cclxuXHRcdHNob3VsZFNldExlZ2VuZCA9IGZhbHNlO1xyXG5cclxuXHRcdF9maXJlICE9PSBmYWxzZSAmJiBmaXJlKFwic2V0TGVnZW5kXCIpO1xyXG5cdH1cclxuXHJcblx0c2VsZi5zZXRMZWdlbmQgPSBzZXRMZWdlbmQ7XHJcblxyXG5cdGZ1bmN0aW9uIHNldExlZ2VuZFZhbHVlcyhzaWR4LCBpZHgpIHtcclxuXHRcdGxldCBzID0gc2VyaWVzW3NpZHhdO1xyXG5cdFx0bGV0IHNyYyA9IHNpZHggPT0gMCAmJiB4U2NhbGVEaXN0ciA9PSAyID8gZGF0YTAgOiBkYXRhW3NpZHhdO1xyXG5cdFx0bGV0IHZhbDtcclxuXHJcblx0XHRpZiAobXVsdGlWYWxMZWdlbmQpXHJcblx0XHRcdHZhbCA9IHMudmFsdWVzKHNlbGYsIHNpZHgsIGlkeCkgPz8gTlVMTF9MRUdFTkRfVkFMVUVTO1xyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHZhbCA9IHMudmFsdWUoc2VsZiwgaWR4ID09IG51bGwgPyBudWxsIDogc3JjW2lkeF0sIHNpZHgsIGlkeCk7XHJcblx0XHRcdHZhbCA9IHZhbCA9PSBudWxsID8gTlVMTF9MRUdFTkRfVkFMVUVTIDoge186IHZhbH07XHJcblx0XHR9XHJcblxyXG5cdFx0bGVnZW5kLnZhbHVlc1tzaWR4XSA9IHZhbDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZUN1cnNvcihzcmMsIF9maXJlLCBfcHViKSB7XHJcblx0Ly9cdHRzID09IG51bGwgJiYgbG9nKFwidXBkYXRlQ3Vyc29yKClcIiwgYXJndW1lbnRzKTtcclxuXHJcblx0XHRyYXdNb3VzZUxlZnQxID0gbW91c2VMZWZ0MTtcclxuXHRcdHJhd01vdXNlVG9wMSA9IG1vdXNlVG9wMTtcclxuXHJcblx0XHRbbW91c2VMZWZ0MSwgbW91c2VUb3AxXSA9IGN1cnNvci5tb3ZlKHNlbGYsIG1vdXNlTGVmdDEsIG1vdXNlVG9wMSk7XHJcblxyXG5cdFx0aWYgKGN1cnNvci5zaG93KSB7XHJcblx0XHRcdHZDdXJzb3IgJiYgZWxUcmFucyh2Q3Vyc29yLCByb3VuZChtb3VzZUxlZnQxKSwgMCwgcGxvdFdpZENzcywgcGxvdEhndENzcyk7XHJcblx0XHRcdGhDdXJzb3IgJiYgZWxUcmFucyhoQ3Vyc29yLCAwLCByb3VuZChtb3VzZVRvcDEpLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgaWR4O1xyXG5cclxuXHRcdC8vIHdoZW4gem9vbWluZyB0byBhbiB4IHNjYWxlIHJhbmdlIGJldHdlZW4gZGF0YXBvaW50cyB0aGUgYmluYXJ5IHNlYXJjaFxyXG5cdFx0Ly8gZm9yIG5lYXJlc3QgbWluL21heCBpbmRpY2VzIHJlc3VsdHMgaW4gdGhpcyBjb25kaXRpb24uIGNoZWFwIGhhY2sgOkRcclxuXHRcdGxldCBub0RhdGFJblJhbmdlID0gaTAgPiBpMTsgLy8gd29ya3MgZm9yIG1vZGUgMSBvbmx5XHJcblxyXG5cdFx0Y2xvc2VzdERpc3QgPSBpbmY7XHJcblxyXG5cdFx0Ly8gVE9ETzogZXh0cmFjdFxyXG5cdFx0bGV0IHhEaW0gPSBzY2FsZVgub3JpID09IDAgPyBwbG90V2lkQ3NzIDogcGxvdEhndENzcztcclxuXHRcdGxldCB5RGltID0gc2NhbGVYLm9yaSA9PSAxID8gcGxvdFdpZENzcyA6IHBsb3RIZ3RDc3M7XHJcblxyXG5cdFx0Ly8gaWYgY3Vyc29yIGhpZGRlbiwgaGlkZSBwb2ludHMgJiBjbGVhciBsZWdlbmQgdmFsc1xyXG5cdFx0aWYgKG1vdXNlTGVmdDEgPCAwIHx8IGRhdGFMZW4gPT0gMCB8fCBub0RhdGFJblJhbmdlKSB7XHJcblx0XHRcdGlkeCA9IG51bGw7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNlcmllcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmIChpID4gMCkge1xyXG5cdFx0XHRcdFx0Y3Vyc29yUHRzLmxlbmd0aCA+IDEgJiYgZWxUcmFucyhjdXJzb3JQdHNbaV0sIC0xMCwgLTEwLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChjdXJzb3JGb2N1cylcclxuXHRcdFx0XHRzZXRTZXJpZXMobnVsbCwgRk9DVVNfVFJVRSwgdHJ1ZSwgc3JjID09IG51bGwgJiYgc3luY09wdHMuc2V0U2VyaWVzKTtcclxuXHJcblx0XHRcdGlmIChsZWdlbmQubGl2ZSkge1xyXG5cdFx0XHRcdGFjdGl2ZUlkeHMuZmlsbChpZHgpO1xyXG5cdFx0XHRcdHNob3VsZFNldExlZ2VuZCA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0Ly9cdGxldCBwY3RZID0gMSAtICh5IC8gcmVjdC5oZWlnaHQpO1xyXG5cclxuXHRcdFx0bGV0IG1vdXNlWFBvcywgdmFsQXRQb3NYLCB4UG9zO1xyXG5cclxuXHRcdFx0aWYgKG1vZGUgPT0gMSkge1xyXG5cdFx0XHRcdG1vdXNlWFBvcyA9IHNjYWxlWC5vcmkgPT0gMCA/IG1vdXNlTGVmdDEgOiBtb3VzZVRvcDE7XHJcblx0XHRcdFx0dmFsQXRQb3NYID0gcG9zVG9WYWwobW91c2VYUG9zLCB4U2NhbGVLZXkpO1xyXG5cdFx0XHRcdGlkeCA9IGNsb3Nlc3RJZHgodmFsQXRQb3NYLCBkYXRhWzBdLCBpMCwgaTEpO1xyXG5cdFx0XHRcdHhQb3MgPSB2YWxUb1Bvc1goZGF0YVswXVtpZHhdLCBzY2FsZVgsIHhEaW0sIDApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gbW9kZSA9PSAyID8gMSA6IDA7IGkgPCBzZXJpZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRsZXQgcyA9IHNlcmllc1tpXTtcclxuXHJcblx0XHRcdFx0bGV0IGlkeDEgID0gYWN0aXZlSWR4c1tpXTtcclxuXHRcdFx0XHRsZXQgeVZhbDEgPSBtb2RlID09IDEgPyBkYXRhW2ldW2lkeDFdIDogZGF0YVtpXVsxXVtpZHgxXTtcclxuXHJcblx0XHRcdFx0bGV0IGlkeDIgID0gY3Vyc29yLmRhdGFJZHgoc2VsZiwgaSwgaWR4LCB2YWxBdFBvc1gpO1xyXG5cdFx0XHRcdGxldCB5VmFsMiA9IG1vZGUgPT0gMSA/IGRhdGFbaV1baWR4Ml0gOiBkYXRhW2ldWzFdW2lkeDJdO1xyXG5cclxuXHRcdFx0XHRzaG91bGRTZXRMZWdlbmQgPSBzaG91bGRTZXRMZWdlbmQgfHwgeVZhbDIgIT0geVZhbDEgfHwgaWR4MiAhPSBpZHgxO1xyXG5cclxuXHRcdFx0XHRhY3RpdmVJZHhzW2ldID0gaWR4MjtcclxuXHJcblx0XHRcdFx0bGV0IHhQb3MyID0gaW5jclJvdW5kVXAoaWR4MiA9PSBpZHggPyB4UG9zIDogdmFsVG9Qb3NYKG1vZGUgPT0gMSA/IGRhdGFbMF1baWR4Ml0gOiBkYXRhW2ldWzBdW2lkeDJdLCBzY2FsZVgsIHhEaW0sIDApLCAxKTtcclxuXHJcblx0XHRcdFx0aWYgKGkgPiAwICYmIHMuc2hvdykge1xyXG5cdFx0XHRcdFx0bGV0IHlQb3MgPSB5VmFsMiA9PSBudWxsID8gLTEwIDogaW5jclJvdW5kVXAodmFsVG9Qb3NZKHlWYWwyLCBtb2RlID09IDEgPyBzY2FsZXNbcy5zY2FsZV0gOiBzY2FsZXNbcy5mYWNldHNbMV0uc2NhbGVdLCB5RGltLCAwKSwgMSk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKGN1cnNvckZvY3VzICYmIHlQb3MgPj0gMCAmJiBtb2RlID09IDEpIHtcclxuXHRcdFx0XHRcdFx0bGV0IGRpc3QgPSBhYnMoeVBvcyAtIG1vdXNlVG9wMSk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoZGlzdCA8IGNsb3Nlc3REaXN0KSB7XHJcblx0XHRcdFx0XHRcdFx0bGV0IGJpYXMgPSBmb2N1cy5iaWFzO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoYmlhcyAhPSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRsZXQgbW91c2VZUG9zID0gc2NhbGVYLm9yaSA9PSAxID8gbW91c2VMZWZ0MSA6IG1vdXNlVG9wMTtcclxuXHRcdFx0XHRcdFx0XHRcdGxldCBtb3VzZVlWYWwgPSBwb3NUb1ZhbChtb3VzZVlQb3MsIHMuc2NhbGUpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGxldCBzZXJpZXNZVmFsU2lnbiA9IHlWYWwyICAgICA+PSAwID8gMSA6IC0xO1xyXG5cdFx0XHRcdFx0XHRcdFx0bGV0IG1vdXNlWVZhbFNpZ24gID0gbW91c2VZVmFsID49IDAgPyAxIDogLTE7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2l0aCBhIGZvY3VzIGJpYXMsIHdlIHdpbGwgbmV2ZXIgY3Jvc3MgemVybyB3aGVuIHByb3ggdGVzdGluZ1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaXQncyBlaXRoZXIgY2xvc2VzdCB0b3dhcmRzIHplcm8sIG9yIGNsb3Nlc3QgYXdheSBmcm9tIHplcm9cclxuXHRcdFx0XHRcdFx0XHRcdGlmIChtb3VzZVlWYWxTaWduID09IHNlcmllc1lWYWxTaWduICYmIChcclxuXHRcdFx0XHRcdFx0XHRcdFx0bW91c2VZVmFsU2lnbiA9PSAxID9cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoYmlhcyA9PSAxID8geVZhbDIgPj0gbW91c2VZVmFsIDogeVZhbDIgPD0gbW91c2VZVmFsKSA6ICAvLyA+PSAwXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0KGJpYXMgPT0gMSA/IHlWYWwyIDw9IG1vdXNlWVZhbCA6IHlWYWwyID49IG1vdXNlWVZhbCkgICAgLy8gIDwgMFxyXG5cdFx0XHRcdFx0XHRcdFx0KSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdCA9IGRpc3Q7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3RTZXJpZXMgPSBpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0ID0gZGlzdDtcclxuXHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3RTZXJpZXMgPSBpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxldCBoUG9zLCB2UG9zO1xyXG5cclxuXHRcdFx0XHRcdGlmIChzY2FsZVgub3JpID09IDApIHtcclxuXHRcdFx0XHRcdFx0aFBvcyA9IHhQb3MyO1xyXG5cdFx0XHRcdFx0XHR2UG9zID0geVBvcztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRoUG9zID0geVBvcztcclxuXHRcdFx0XHRcdFx0dlBvcyA9IHhQb3MyO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChzaG91bGRTZXRMZWdlbmQgJiYgY3Vyc29yUHRzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0ZWxDb2xvcihjdXJzb3JQdHNbaV0sIGN1cnNvci5wb2ludHMuZmlsbChzZWxmLCBpKSwgY3Vyc29yLnBvaW50cy5zdHJva2Uoc2VsZiwgaSkpO1xyXG5cclxuXHRcdFx0XHRcdFx0bGV0IHB0V2lkLCBwdEhndCwgcHRMZnQsIHB0VG9wLFxyXG5cdFx0XHRcdFx0XHRcdGNlbnRlcmVkID0gdHJ1ZSxcclxuXHRcdFx0XHRcdFx0XHRnZXRCQm94ID0gY3Vyc29yLnBvaW50cy5iYm94O1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGdldEJCb3ggIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdGNlbnRlcmVkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGxldCBiYm94ID0gZ2V0QkJveChzZWxmLCBpKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0cHRMZnQgPSBiYm94LmxlZnQ7XHJcblx0XHRcdFx0XHRcdFx0cHRUb3AgPSBiYm94LnRvcDtcclxuXHRcdFx0XHRcdFx0XHRwdFdpZCA9IGJib3gud2lkdGg7XHJcblx0XHRcdFx0XHRcdFx0cHRIZ3QgPSBiYm94LmhlaWdodDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRwdExmdCA9IGhQb3M7XHJcblx0XHRcdFx0XHRcdFx0cHRUb3AgPSB2UG9zO1xyXG5cdFx0XHRcdFx0XHRcdHB0V2lkID0gcHRIZ3QgPSBjdXJzb3IucG9pbnRzLnNpemUoc2VsZiwgaSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGVsU2l6ZShjdXJzb3JQdHNbaV0sIHB0V2lkLCBwdEhndCwgY2VudGVyZWQpO1xyXG5cdFx0XHRcdFx0XHRlbFRyYW5zKGN1cnNvclB0c1tpXSwgcHRMZnQsIHB0VG9wLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRjdXJzb3IuaWR4ID0gaWR4O1xyXG5cdFx0Y3Vyc29yLmxlZnQgPSBtb3VzZUxlZnQxO1xyXG5cdFx0Y3Vyc29yLnRvcCA9IG1vdXNlVG9wMTtcclxuXHJcblx0XHRpZiAoc2hvdWxkU2V0TGVnZW5kKSB7XHJcblx0XHRcdGxlZ2VuZC5pZHggPSBpZHg7XHJcblx0XHRcdHNldExlZ2VuZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG5pdDogY3Vyc29yLmRyYWcuc2V0U2VsZWN0IGlzIGFzc3VtZWQgYWx3YXlzIHRydWVcclxuXHRcdGlmIChzZWxlY3Quc2hvdyAmJiBkcmFnZ2luZykge1xyXG5cdFx0XHRpZiAoc3JjICE9IG51bGwpIHtcclxuXHRcdFx0XHRsZXQgW3hLZXksIHlLZXldID0gc3luY09wdHMuc2NhbGVzO1xyXG5cdFx0XHRcdGxldCBbbWF0Y2hYS2V5cywgbWF0Y2hZS2V5c10gPSBzeW5jT3B0cy5tYXRjaDtcclxuXHRcdFx0XHRsZXQgW3hLZXlTcmMsIHlLZXlTcmNdID0gc3JjLmN1cnNvci5zeW5jLnNjYWxlcztcclxuXHJcblx0XHRcdFx0Ly8gbWF0Y2ggdGhlIGRyYWdYL2RyYWdZIGltcGxpY2l0bmVzcy9leHBsaWNpdG5lc3Mgb2Ygc3JjXHJcblx0XHRcdFx0bGV0IHNkcmFnID0gc3JjLmN1cnNvci5kcmFnO1xyXG5cdFx0XHRcdGRyYWdYID0gc2RyYWcuX3g7XHJcblx0XHRcdFx0ZHJhZ1kgPSBzZHJhZy5feTtcclxuXHJcblx0XHRcdFx0aWYgKGRyYWdYIHx8IGRyYWdZKSB7XHJcblx0XHRcdFx0XHRsZXQgeyBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgfSA9IHNyYy5zZWxlY3Q7XHJcblxyXG5cdFx0XHRcdFx0bGV0IHNvcmkgPSBzcmMuc2NhbGVzW3hLZXldLm9yaTtcclxuXHRcdFx0XHRcdGxldCBzUG9zVG9WYWwgPSBzcmMucG9zVG9WYWw7XHJcblxyXG5cdFx0XHRcdFx0bGV0IHNPZmYsIHNEaW0sIHNjLCBhLCBiO1xyXG5cclxuXHRcdFx0XHRcdGxldCBtYXRjaGluZ1ggPSB4S2V5ICE9IG51bGwgJiYgbWF0Y2hYS2V5cyh4S2V5LCB4S2V5U3JjKTtcclxuXHRcdFx0XHRcdGxldCBtYXRjaGluZ1kgPSB5S2V5ICE9IG51bGwgJiYgbWF0Y2hZS2V5cyh5S2V5LCB5S2V5U3JjKTtcclxuXHJcblx0XHRcdFx0XHRpZiAobWF0Y2hpbmdYICYmIGRyYWdYKSB7XHJcblx0XHRcdFx0XHRcdGlmIChzb3JpID09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRzT2ZmID0gbGVmdDtcclxuXHRcdFx0XHRcdFx0XHRzRGltID0gd2lkdGg7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0c09mZiA9IHRvcDtcclxuXHRcdFx0XHRcdFx0XHRzRGltID0gaGVpZ2h0O1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRzYyA9IHNjYWxlc1t4S2V5XTtcclxuXHJcblx0XHRcdFx0XHRcdGEgPSB2YWxUb1Bvc1goc1Bvc1RvVmFsKHNPZmYsIHhLZXlTcmMpLCAgICAgICAgc2MsIHhEaW0sIDApO1xyXG5cdFx0XHRcdFx0XHRiID0gdmFsVG9Qb3NYKHNQb3NUb1ZhbChzT2ZmICsgc0RpbSwgeEtleVNyYyksIHNjLCB4RGltLCAwKTtcclxuXHJcblx0XHRcdFx0XHRcdHNldFNlbFgobWluKGEsYiksIGFicyhiLWEpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0c2V0U2VsWCgwLCB4RGltKTtcclxuXHJcblx0XHRcdFx0XHRpZiAobWF0Y2hpbmdZICYmIGRyYWdZKSB7XHJcblx0XHRcdFx0XHRcdGlmIChzb3JpID09IDEpIHtcclxuXHRcdFx0XHRcdFx0XHRzT2ZmID0gbGVmdDtcclxuXHRcdFx0XHRcdFx0XHRzRGltID0gd2lkdGg7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0c09mZiA9IHRvcDtcclxuXHRcdFx0XHRcdFx0XHRzRGltID0gaGVpZ2h0O1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRzYyA9IHNjYWxlc1t5S2V5XTtcclxuXHJcblx0XHRcdFx0XHRcdGEgPSB2YWxUb1Bvc1koc1Bvc1RvVmFsKHNPZmYsIHlLZXlTcmMpLCAgICAgICAgc2MsIHlEaW0sIDApO1xyXG5cdFx0XHRcdFx0XHRiID0gdmFsVG9Qb3NZKHNQb3NUb1ZhbChzT2ZmICsgc0RpbSwgeUtleVNyYyksIHNjLCB5RGltLCAwKTtcclxuXHJcblx0XHRcdFx0XHRcdHNldFNlbFkobWluKGEsYiksIGFicyhiLWEpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0c2V0U2VsWSgwLCB5RGltKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0aGlkZVNlbGVjdCgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGxldCByYXdEWCA9IGFicyhyYXdNb3VzZUxlZnQxIC0gcmF3TW91c2VMZWZ0MCk7XHJcblx0XHRcdFx0bGV0IHJhd0RZID0gYWJzKHJhd01vdXNlVG9wMSAtIHJhd01vdXNlVG9wMCk7XHJcblxyXG5cdFx0XHRcdGlmIChzY2FsZVgub3JpID09IDEpIHtcclxuXHRcdFx0XHRcdGxldCBfcmF3RFggPSByYXdEWDtcclxuXHRcdFx0XHRcdHJhd0RYID0gcmF3RFk7XHJcblx0XHRcdFx0XHRyYXdEWSA9IF9yYXdEWDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGRyYWdYID0gZHJhZy54ICYmIHJhd0RYID49IGRyYWcuZGlzdDtcclxuXHRcdFx0XHRkcmFnWSA9IGRyYWcueSAmJiByYXdEWSA+PSBkcmFnLmRpc3Q7XHJcblxyXG5cdFx0XHRcdGxldCB1bmkgPSBkcmFnLnVuaTtcclxuXHJcblx0XHRcdFx0aWYgKHVuaSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHQvLyBvbmx5IGNhbGMgZHJhZyBzdGF0dXMgaWYgdGhleSBwYXNzIHRoZSBkaXN0IHRocmVzaFxyXG5cdFx0XHRcdFx0aWYgKGRyYWdYICYmIGRyYWdZKSB7XHJcblx0XHRcdFx0XHRcdGRyYWdYID0gcmF3RFggPj0gdW5pO1xyXG5cdFx0XHRcdFx0XHRkcmFnWSA9IHJhd0RZID49IHVuaTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGZvcmNlIHVuaWRpcmVjdGlvbmFsaXR5IHdoZW4gYm90aCBhcmUgdW5kZXIgdW5pIGxpbWl0XHJcblx0XHRcdFx0XHRcdGlmICghZHJhZ1ggJiYgIWRyYWdZKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHJhd0RZID4gcmF3RFgpXHJcblx0XHRcdFx0XHRcdFx0XHRkcmFnWSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRcdFx0ZHJhZ1ggPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKGRyYWcueCAmJiBkcmFnLnkgJiYgKGRyYWdYIHx8IGRyYWdZKSlcclxuXHRcdFx0XHRcdC8vIGlmIG9tbmkgd2l0aCBubyB1bmkgdGhlbiBib3RoIGRyYWdYIC8gZHJhZ1kgc2hvdWxkIGJlIHRydWUgaWYgZWl0aGVyIGlzIHRydWVcclxuXHRcdFx0XHRcdGRyYWdYID0gZHJhZ1kgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRsZXQgcDAsIHAxO1xyXG5cclxuXHRcdFx0XHRpZiAoZHJhZ1gpIHtcclxuXHRcdFx0XHRcdGlmIChzY2FsZVgub3JpID09IDApIHtcclxuXHRcdFx0XHRcdFx0cDAgPSBtb3VzZUxlZnQwO1xyXG5cdFx0XHRcdFx0XHRwMSA9IG1vdXNlTGVmdDE7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0cDAgPSBtb3VzZVRvcDA7XHJcblx0XHRcdFx0XHRcdHAxID0gbW91c2VUb3AxO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHNldFNlbFgobWluKHAwLCBwMSksIGFicyhwMSAtIHAwKSk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCFkcmFnWSlcclxuXHRcdFx0XHRcdFx0c2V0U2VsWSgwLCB5RGltKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChkcmFnWSkge1xyXG5cdFx0XHRcdFx0aWYgKHNjYWxlWC5vcmkgPT0gMSkge1xyXG5cdFx0XHRcdFx0XHRwMCA9IG1vdXNlTGVmdDA7XHJcblx0XHRcdFx0XHRcdHAxID0gbW91c2VMZWZ0MTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRwMCA9IG1vdXNlVG9wMDtcclxuXHRcdFx0XHRcdFx0cDEgPSBtb3VzZVRvcDE7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0c2V0U2VsWShtaW4ocDAsIHAxKSwgYWJzKHAxIC0gcDApKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIWRyYWdYKVxyXG5cdFx0XHRcdFx0XHRzZXRTZWxYKDAsIHhEaW0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gdGhlIGRyYWcgZGlkbid0IHBhc3MgdGhlIGRpc3QgcmVxdWlyZW1lbnRcclxuXHRcdFx0XHRpZiAoIWRyYWdYICYmICFkcmFnWSkge1xyXG5cdFx0XHRcdFx0c2V0U2VsWCgwLCAwKTtcclxuXHRcdFx0XHRcdHNldFNlbFkoMCwgMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0ZHJhZy5feCA9IGRyYWdYO1xyXG5cdFx0ZHJhZy5feSA9IGRyYWdZO1xyXG5cclxuXHRcdGlmIChzcmMgPT0gbnVsbCkge1xyXG5cdFx0XHRpZiAoX3B1Yikge1xyXG5cdFx0XHRcdGlmIChzeW5jS2V5ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGxldCBbeFN5bmNLZXksIHlTeW5jS2V5XSA9IHN5bmNPcHRzLnNjYWxlcztcclxuXHJcblx0XHRcdFx0XHRzeW5jT3B0cy52YWx1ZXNbMF0gPSB4U3luY0tleSAhPSBudWxsID8gcG9zVG9WYWwoc2NhbGVYLm9yaSA9PSAwID8gbW91c2VMZWZ0MSA6IG1vdXNlVG9wMSwgeFN5bmNLZXkpIDogbnVsbDtcclxuXHRcdFx0XHRcdHN5bmNPcHRzLnZhbHVlc1sxXSA9IHlTeW5jS2V5ICE9IG51bGwgPyBwb3NUb1ZhbChzY2FsZVgub3JpID09IDEgPyBtb3VzZUxlZnQxIDogbW91c2VUb3AxLCB5U3luY0tleSkgOiBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cHViU3luYyhtb3VzZW1vdmUsIHNlbGYsIG1vdXNlTGVmdDEsIG1vdXNlVG9wMSwgcGxvdFdpZENzcywgcGxvdEhndENzcywgaWR4KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGN1cnNvckZvY3VzKSB7XHJcblx0XHRcdFx0bGV0IHNob3VsZFB1YiA9IF9wdWIgJiYgc3luY09wdHMuc2V0U2VyaWVzO1xyXG5cdFx0XHRcdGxldCBwID0gZm9jdXMucHJveDtcclxuXHJcblx0XHRcdFx0aWYgKGZvY3VzZWRTZXJpZXMgPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0aWYgKGNsb3Nlc3REaXN0IDw9IHApXHJcblx0XHRcdFx0XHRcdHNldFNlcmllcyhjbG9zZXN0U2VyaWVzLCBGT0NVU19UUlVFLCB0cnVlLCBzaG91bGRQdWIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdGlmIChjbG9zZXN0RGlzdCA+IHApXHJcblx0XHRcdFx0XHRcdHNldFNlcmllcyhudWxsLCBGT0NVU19UUlVFLCB0cnVlLCBzaG91bGRQdWIpO1xyXG5cdFx0XHRcdFx0ZWxzZSBpZiAoY2xvc2VzdFNlcmllcyAhPSBmb2N1c2VkU2VyaWVzKVxyXG5cdFx0XHRcdFx0XHRzZXRTZXJpZXMoY2xvc2VzdFNlcmllcywgRk9DVVNfVFJVRSwgdHJ1ZSwgc2hvdWxkUHViKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRfZmlyZSAhPT0gZmFsc2UgJiYgZmlyZShcInNldEN1cnNvclwiKTtcclxuXHR9XHJcblxyXG5cdGxldCByZWN0ID0gbnVsbDtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsICdyZWN0Jywge1xyXG5cdFx0Z2V0KCkge1xyXG5cdFx0XHRpZiAocmVjdCA9PSBudWxsKVxyXG5cdFx0XHRcdHN5bmNSZWN0KGZhbHNlKTtcclxuXHJcblx0XHRcdHJldHVybiByZWN0O1xyXG5cdFx0fSxcclxuXHR9KTtcclxuXHJcblx0ZnVuY3Rpb24gc3luY1JlY3QoZGVmZXIgPSBmYWxzZSkge1xyXG5cdFx0aWYgKGRlZmVyKVxyXG5cdFx0XHRyZWN0ID0gbnVsbDtcclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRyZWN0ID0gb3Zlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHRcdFx0ZmlyZShcInN5bmNSZWN0XCIsIHJlY3QpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gbW91c2VNb3ZlKGUsIHNyYywgX2wsIF90LCBfdywgX2gsIF9pKSB7XHJcblx0XHRpZiAoY3Vyc29yLl9sb2NrKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0Ly8gQ2hyb21lIG9uIFdpbmRvd3MgaGFzIGEgYnVnIHdoaWNoIHRyaWdnZXJzIGEgc3RyYXkgbW91c2Vtb3ZlIGV2ZW50IGFmdGVyIGFuIGluaXRpYWwgbW91c2Vkb3duIGV2ZW50XHJcblx0XHQvLyB3aGVuIGNsaWNraW5nIGludG8gYSBwbG90IGFzIHBhcnQgb2YgcmUtZm9jdXNpbmcgdGhlIGJyb3dzZXIgd2luZG93LlxyXG5cdFx0Ly8gd2UgZ290dGEgaWdub3JlIGl0IHRvIGF2b2lkIHRyaWdnZXJpbmcgYSBwaGFudG9tIGRyYWcgLyBzZXRTZWxlY3RcclxuXHRcdC8vIEhvd2V2ZXIsIG9uIHRvdWNoLW9ubHkgZGV2aWNlcyBDaHJvbWUtYmFzZWQgYnJvd3NlcnMgdHJpZ2dlciBhIDAtZGlzdGFuY2UgbW91c2Vtb3ZlIGJlZm9yZSBtb3VzZWRvd25cclxuXHRcdC8vIHNvIHdlIGRvbid0IGlnbm9yZSBpdCB3aGVuIG1vdXNlZG93biBoYXMgc2V0IHRoZSBkcmFnZ2luZyBmbGFnXHJcblx0XHRpZiAoZHJhZ2dpbmcgJiYgZSAhPSBudWxsICYmIGUubW92ZW1lbnRYID09IDAgJiYgZS5tb3ZlbWVudFkgPT0gMClcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdGNhY2hlTW91c2UoZSwgc3JjLCBfbCwgX3QsIF93LCBfaCwgX2ksIGZhbHNlLCBlICE9IG51bGwpO1xyXG5cclxuXHRcdGlmIChlICE9IG51bGwpXHJcblx0XHRcdHVwZGF0ZUN1cnNvcihudWxsLCB0cnVlLCB0cnVlKTtcclxuXHRcdGVsc2VcclxuXHRcdFx0dXBkYXRlQ3Vyc29yKHNyYywgdHJ1ZSwgZmFsc2UpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY2FjaGVNb3VzZShlLCBzcmMsIF9sLCBfdCwgX3csIF9oLCBfaSwgaW5pdGlhbCwgc25hcCkge1xyXG5cdFx0aWYgKHJlY3QgPT0gbnVsbClcclxuXHRcdFx0c3luY1JlY3QoZmFsc2UpO1xyXG5cclxuXHRcdHNldEN1cnNvckV2ZW50KGUpO1xyXG5cclxuXHRcdGlmIChlICE9IG51bGwpIHtcclxuXHRcdFx0X2wgPSBlLmNsaWVudFggLSByZWN0LmxlZnQ7XHJcblx0XHRcdF90ID0gZS5jbGllbnRZIC0gcmVjdC50b3A7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0aWYgKF9sIDwgMCB8fCBfdCA8IDApIHtcclxuXHRcdFx0XHRtb3VzZUxlZnQxID0gLTEwO1xyXG5cdFx0XHRcdG1vdXNlVG9wMSA9IC0xMDtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBbeEtleSwgeUtleV0gPSBzeW5jT3B0cy5zY2FsZXM7XHJcblxyXG5cdFx0XHRsZXQgc3luY09wdHNTcmMgPSBzcmMuY3Vyc29yLnN5bmM7XHJcblx0XHRcdGxldCBbeFZhbFNyYywgeVZhbFNyY10gPSBzeW5jT3B0c1NyYy52YWx1ZXM7XHJcblx0XHRcdGxldCBbeEtleVNyYywgeUtleVNyY10gPSBzeW5jT3B0c1NyYy5zY2FsZXM7XHJcblx0XHRcdGxldCBbbWF0Y2hYS2V5cywgbWF0Y2hZS2V5c10gPSBzeW5jT3B0cy5tYXRjaDtcclxuXHJcblx0XHRcdGxldCByb3RTcmMgPSBzcmMuYXhlc1swXS5zaWRlICUgMiA9PSAxO1xyXG5cclxuXHRcdFx0bGV0IHhEaW0gPSBzY2FsZVgub3JpID09IDAgPyBwbG90V2lkQ3NzIDogcGxvdEhndENzcyxcclxuXHRcdFx0XHR5RGltID0gc2NhbGVYLm9yaSA9PSAxID8gcGxvdFdpZENzcyA6IHBsb3RIZ3RDc3MsXHJcblx0XHRcdFx0X3hEaW0gPSByb3RTcmMgPyBfaCA6IF93LFxyXG5cdFx0XHRcdF95RGltID0gcm90U3JjID8gX3cgOiBfaCxcclxuXHRcdFx0XHRfeFBvcyA9IHJvdFNyYyA/IF90IDogX2wsXHJcblx0XHRcdFx0X3lQb3MgPSByb3RTcmMgPyBfbCA6IF90O1xyXG5cclxuXHRcdFx0aWYgKHhLZXlTcmMgIT0gbnVsbClcclxuXHRcdFx0XHRfbCA9IG1hdGNoWEtleXMoeEtleSwgeEtleVNyYykgPyBnZXRQb3MoeFZhbFNyYywgc2NhbGVzW3hLZXldLCB4RGltLCAwKSA6IC0xMDtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdF9sID0geERpbSAqIChfeFBvcy9feERpbSk7XHJcblxyXG5cdFx0XHRpZiAoeUtleVNyYyAhPSBudWxsKVxyXG5cdFx0XHRcdF90ID0gbWF0Y2hZS2V5cyh5S2V5LCB5S2V5U3JjKSA/IGdldFBvcyh5VmFsU3JjLCBzY2FsZXNbeUtleV0sIHlEaW0sIDApIDogLTEwO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0X3QgPSB5RGltICogKF95UG9zL195RGltKTtcclxuXHJcblx0XHRcdGlmIChzY2FsZVgub3JpID09IDEpIHtcclxuXHRcdFx0XHRsZXQgX19sID0gX2w7XHJcblx0XHRcdFx0X2wgPSBfdDtcclxuXHRcdFx0XHRfdCA9IF9fbDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzbmFwKSB7XHJcblx0XHRcdGlmIChfbCA8PSAxIHx8IF9sID49IHBsb3RXaWRDc3MgLSAxKVxyXG5cdFx0XHRcdF9sID0gaW5jclJvdW5kKF9sLCBwbG90V2lkQ3NzKTtcclxuXHJcblx0XHRcdGlmIChfdCA8PSAxIHx8IF90ID49IHBsb3RIZ3RDc3MgLSAxKVxyXG5cdFx0XHRcdF90ID0gaW5jclJvdW5kKF90LCBwbG90SGd0Q3NzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaW5pdGlhbCkge1xyXG5cdFx0XHRyYXdNb3VzZUxlZnQwID0gX2w7XHJcblx0XHRcdHJhd01vdXNlVG9wMCA9IF90O1xyXG5cclxuXHRcdFx0W21vdXNlTGVmdDAsIG1vdXNlVG9wMF0gPSBjdXJzb3IubW92ZShzZWxmLCBfbCwgX3QpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdG1vdXNlTGVmdDEgPSBfbDtcclxuXHRcdFx0bW91c2VUb3AxID0gX3Q7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRjb25zdCBfaGlkZVByb3BzID0ge1xyXG5cdFx0d2lkdGg6IDAsXHJcblx0XHRoZWlnaHQ6IDAsXHJcblx0XHRsZWZ0OiAwLFxyXG5cdFx0dG9wOiAwLFxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGhpZGVTZWxlY3QoKSB7XHJcblx0XHRzZXRTZWxlY3QoX2hpZGVQcm9wcywgZmFsc2UpO1xyXG5cdH1cclxuXHJcblx0bGV0IGRvd25TZWxlY3RMZWZ0O1xyXG5cdGxldCBkb3duU2VsZWN0VG9wO1xyXG5cdGxldCBkb3duU2VsZWN0V2lkdGg7XHJcblx0bGV0IGRvd25TZWxlY3RIZWlnaHQ7XHJcblxyXG5cdGZ1bmN0aW9uIG1vdXNlRG93bihlLCBzcmMsIF9sLCBfdCwgX3csIF9oLCBfaSkge1xyXG5cdFx0ZHJhZ2dpbmcgPSB0cnVlO1xyXG5cdFx0ZHJhZ1ggPSBkcmFnWSA9IGRyYWcuX3ggPSBkcmFnLl95ID0gZmFsc2U7XHJcblxyXG5cdFx0Y2FjaGVNb3VzZShlLCBzcmMsIF9sLCBfdCwgX3csIF9oLCBfaSwgdHJ1ZSwgZmFsc2UpO1xyXG5cclxuXHRcdGlmIChlICE9IG51bGwpIHtcclxuXHRcdFx0b25Nb3VzZShtb3VzZXVwLCBkb2MsIG1vdXNlVXAsIGZhbHNlKTtcclxuXHRcdFx0cHViU3luYyhtb3VzZWRvd24sIHNlbGYsIG1vdXNlTGVmdDAsIG1vdXNlVG9wMCwgcGxvdFdpZENzcywgcGxvdEhndENzcywgbnVsbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHsgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IH0gPSBzZWxlY3Q7XHJcblxyXG5cdFx0ZG93blNlbGVjdExlZnQgICA9IGxlZnQ7XHJcblx0XHRkb3duU2VsZWN0VG9wICAgID0gdG9wO1xyXG5cdFx0ZG93blNlbGVjdFdpZHRoICA9IHdpZHRoO1xyXG5cdFx0ZG93blNlbGVjdEhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHRoaWRlU2VsZWN0KCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBtb3VzZVVwKGUsIHNyYywgX2wsIF90LCBfdywgX2gsIF9pKSB7XHJcblx0XHRkcmFnZ2luZyA9IGRyYWcuX3ggPSBkcmFnLl95ID0gZmFsc2U7XHJcblxyXG5cdFx0Y2FjaGVNb3VzZShlLCBzcmMsIF9sLCBfdCwgX3csIF9oLCBfaSwgZmFsc2UsIHRydWUpO1xyXG5cclxuXHRcdGxldCB7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB9ID0gc2VsZWN0O1xyXG5cclxuXHRcdGxldCBoYXNTZWxlY3QgPSB3aWR0aCA+IDAgfHwgaGVpZ2h0ID4gMDtcclxuXHRcdGxldCBjaGdTZWxlY3QgPSAoXHJcblx0XHRcdGRvd25TZWxlY3RMZWZ0ICAgIT0gbGVmdCAgIHx8XHJcblx0XHRcdGRvd25TZWxlY3RUb3AgICAgIT0gdG9wICAgIHx8XHJcblx0XHRcdGRvd25TZWxlY3RXaWR0aCAgIT0gd2lkdGggIHx8XHJcblx0XHRcdGRvd25TZWxlY3RIZWlnaHQgIT0gaGVpZ2h0XHJcblx0XHQpO1xyXG5cclxuXHRcdGhhc1NlbGVjdCAmJiBjaGdTZWxlY3QgJiYgc2V0U2VsZWN0KHNlbGVjdCk7XHJcblxyXG5cdFx0aWYgKGRyYWcuc2V0U2NhbGUgJiYgaGFzU2VsZWN0ICYmIGNoZ1NlbGVjdCkge1xyXG5cdFx0Ly9cdGlmIChzeW5jS2V5ICE9IG51bGwpIHtcclxuXHRcdC8vXHRcdGRyYWdYID0gZHJhZy54O1xyXG5cdFx0Ly9cdFx0ZHJhZ1kgPSBkcmFnLnk7XHJcblx0XHQvL1x0fVxyXG5cclxuXHRcdFx0bGV0IHhPZmYgPSBsZWZ0LFxyXG5cdFx0XHRcdHhEaW0gPSB3aWR0aCxcclxuXHRcdFx0XHR5T2ZmID0gdG9wLFxyXG5cdFx0XHRcdHlEaW0gPSBoZWlnaHQ7XHJcblxyXG5cdFx0XHRpZiAoc2NhbGVYLm9yaSA9PSAxKSB7XHJcblx0XHRcdFx0eE9mZiA9IHRvcCxcclxuXHRcdFx0XHR4RGltID0gaGVpZ2h0LFxyXG5cdFx0XHRcdHlPZmYgPSBsZWZ0LFxyXG5cdFx0XHRcdHlEaW0gPSB3aWR0aDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGRyYWdYKSB7XHJcblx0XHRcdFx0X3NldFNjYWxlKHhTY2FsZUtleSxcclxuXHRcdFx0XHRcdHBvc1RvVmFsKHhPZmYsIHhTY2FsZUtleSksXHJcblx0XHRcdFx0XHRwb3NUb1ZhbCh4T2ZmICsgeERpbSwgeFNjYWxlS2V5KVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChkcmFnWSkge1xyXG5cdFx0XHRcdGZvciAobGV0IGsgaW4gc2NhbGVzKSB7XHJcblx0XHRcdFx0XHRsZXQgc2MgPSBzY2FsZXNba107XHJcblxyXG5cdFx0XHRcdFx0aWYgKGsgIT0geFNjYWxlS2V5ICYmIHNjLmZyb20gPT0gbnVsbCAmJiBzYy5taW4gIT0gaW5mKSB7XHJcblx0XHRcdFx0XHRcdF9zZXRTY2FsZShrLFxyXG5cdFx0XHRcdFx0XHRcdHBvc1RvVmFsKHlPZmYgKyB5RGltLCBrKSxcclxuXHRcdFx0XHRcdFx0XHRwb3NUb1ZhbCh5T2ZmLCBrKVxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aGlkZVNlbGVjdCgpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoY3Vyc29yLmxvY2spIHtcclxuXHRcdFx0Y3Vyc29yLl9sb2NrID0gIWN1cnNvci5fbG9jaztcclxuXHJcblx0XHRcdGlmICghY3Vyc29yLl9sb2NrKVxyXG5cdFx0XHRcdHVwZGF0ZUN1cnNvcihudWxsLCB0cnVlLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGUgIT0gbnVsbCkge1xyXG5cdFx0XHRvZmZNb3VzZShtb3VzZXVwLCBkb2MpO1xyXG5cdFx0XHRwdWJTeW5jKG1vdXNldXAsIHNlbGYsIG1vdXNlTGVmdDEsIG1vdXNlVG9wMSwgcGxvdFdpZENzcywgcGxvdEhndENzcywgbnVsbCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBtb3VzZUxlYXZlKGUsIHNyYywgX2wsIF90LCBfdywgX2gsIF9pKSB7XHJcblx0XHRpZiAoY3Vyc29yLl9sb2NrKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0c2V0Q3Vyc29yRXZlbnQoZSk7XHJcblxyXG5cdFx0bGV0IF9kcmFnZ2luZyA9IGRyYWdnaW5nO1xyXG5cclxuXHRcdGlmIChkcmFnZ2luZykge1xyXG5cdFx0XHQvLyBoYW5kbGUgY2FzZSB3aGVuIG1vdXNlbW92ZSBhcmVuJ3QgZmlyZWQgYWxsIHRoZSB3YXkgdG8gZWRnZXMgYnkgYnJvd3NlclxyXG5cdFx0XHRsZXQgc25hcEggPSB0cnVlO1xyXG5cdFx0XHRsZXQgc25hcFYgPSB0cnVlO1xyXG5cdFx0XHRsZXQgc25hcFByb3ggPSAxMDtcclxuXHJcblx0XHRcdGxldCBkcmFnSCwgZHJhZ1Y7XHJcblxyXG5cdFx0XHRpZiAoc2NhbGVYLm9yaSA9PSAwKSB7XHJcblx0XHRcdFx0ZHJhZ0ggPSBkcmFnWDtcclxuXHRcdFx0XHRkcmFnViA9IGRyYWdZO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGRyYWdIID0gZHJhZ1k7XHJcblx0XHRcdFx0ZHJhZ1YgPSBkcmFnWDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGRyYWdIICYmIGRyYWdWKSB7XHJcblx0XHRcdFx0Ly8gbWF5YmUgb21uaSBjb3JuZXIgc25hcFxyXG5cdFx0XHRcdHNuYXBIID0gbW91c2VMZWZ0MSA8PSBzbmFwUHJveCB8fCBtb3VzZUxlZnQxID49IHBsb3RXaWRDc3MgLSBzbmFwUHJveDtcclxuXHRcdFx0XHRzbmFwViA9IG1vdXNlVG9wMSAgPD0gc25hcFByb3ggfHwgbW91c2VUb3AxICA+PSBwbG90SGd0Q3NzIC0gc25hcFByb3g7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChkcmFnSCAmJiBzbmFwSClcclxuXHRcdFx0XHRtb3VzZUxlZnQxID0gbW91c2VMZWZ0MSA8IG1vdXNlTGVmdDAgPyAwIDogcGxvdFdpZENzcztcclxuXHJcblx0XHRcdGlmIChkcmFnViAmJiBzbmFwVilcclxuXHRcdFx0XHRtb3VzZVRvcDEgPSBtb3VzZVRvcDEgPCBtb3VzZVRvcDAgPyAwIDogcGxvdEhndENzcztcclxuXHJcblx0XHRcdHVwZGF0ZUN1cnNvcihudWxsLCB0cnVlLCB0cnVlKTtcclxuXHJcblx0XHRcdGRyYWdnaW5nID0gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0bW91c2VMZWZ0MSA9IC0xMDtcclxuXHRcdG1vdXNlVG9wMSA9IC0xMDtcclxuXHJcblx0XHQvLyBwYXNzaW5nIGEgbm9uLW51bGwgdGltZXN0YW1wIHRvIGZvcmNlIHN5bmMvbW91c2Vtb3ZlIGV2ZW50XHJcblx0XHR1cGRhdGVDdXJzb3IobnVsbCwgdHJ1ZSwgdHJ1ZSk7XHJcblxyXG5cdFx0aWYgKF9kcmFnZ2luZylcclxuXHRcdFx0ZHJhZ2dpbmcgPSBfZHJhZ2dpbmc7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkYmxDbGljayhlLCBzcmMsIF9sLCBfdCwgX3csIF9oLCBfaSkge1xyXG5cdFx0aWYgKGN1cnNvci5fbG9jaylcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdHNldEN1cnNvckV2ZW50KGUpO1xyXG5cclxuXHRcdGF1dG9TY2FsZVgoKTtcclxuXHJcblx0XHRoaWRlU2VsZWN0KCk7XHJcblxyXG5cdFx0aWYgKGUgIT0gbnVsbClcclxuXHRcdFx0cHViU3luYyhkYmxjbGljaywgc2VsZiwgbW91c2VMZWZ0MSwgbW91c2VUb3AxLCBwbG90V2lkQ3NzLCBwbG90SGd0Q3NzLCBudWxsKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHN5bmNQeFJhdGlvKCkge1xyXG5cdFx0YXhlcy5mb3JFYWNoKHN5bmNGb250U2l6ZSk7XHJcblx0XHRfc2V0U2l6ZShzZWxmLndpZHRoLCBzZWxmLmhlaWdodCwgdHJ1ZSk7XHJcblx0fVxyXG5cclxuXHRvbihkcHB4Y2hhbmdlLCB3aW4sIHN5bmNQeFJhdGlvKTtcclxuXHJcblx0Ly8gaW50ZXJuYWwgcHViL3N1YlxyXG5cdGNvbnN0IGV2ZW50cyA9IHt9O1xyXG5cclxuXHRldmVudHMubW91c2Vkb3duID0gbW91c2VEb3duO1xyXG5cdGV2ZW50cy5tb3VzZW1vdmUgPSBtb3VzZU1vdmU7XHJcblx0ZXZlbnRzLm1vdXNldXAgPSBtb3VzZVVwO1xyXG5cdGV2ZW50cy5kYmxjbGljayA9IGRibENsaWNrO1xyXG5cdGV2ZW50c1tcInNldFNlcmllc1wiXSA9IChlLCBzcmMsIGlkeCwgb3B0cykgPT4ge1xyXG5cdFx0bGV0IHNlcmllc0lkeE1hdGNoZXIgPSBzeW5jT3B0cy5tYXRjaFsyXTtcclxuXHRcdGlkeCA9IHNlcmllc0lkeE1hdGNoZXIoc2VsZiwgc3JjLCBpZHgpO1xyXG5cdFx0aWR4ICE9IC0xICYmIHNldFNlcmllcyhpZHgsIG9wdHMsIHRydWUsIGZhbHNlKTtcclxuXHR9O1xyXG5cclxuXHRpZiAoY3Vyc29yLnNob3cpIHtcclxuXHRcdG9uTW91c2UobW91c2Vkb3duLCAgb3ZlciwgbW91c2VEb3duKTtcclxuXHRcdG9uTW91c2UobW91c2Vtb3ZlLCAgb3ZlciwgbW91c2VNb3ZlKTtcclxuXHRcdG9uTW91c2UobW91c2VlbnRlciwgb3ZlciwgZSA9PiB7XHJcblx0XHRcdHNldEN1cnNvckV2ZW50KGUpO1xyXG5cdFx0XHRzeW5jUmVjdChmYWxzZSk7XHJcblx0XHR9KTtcclxuXHRcdG9uTW91c2UobW91c2VsZWF2ZSwgb3ZlciwgbW91c2VMZWF2ZSk7XHJcblxyXG5cdFx0b25Nb3VzZShkYmxjbGljaywgb3ZlciwgZGJsQ2xpY2spO1xyXG5cclxuXHRcdGN1cnNvclBsb3RzLmFkZChzZWxmKTtcclxuXHJcblx0XHRzZWxmLnN5bmNSZWN0ID0gc3luY1JlY3Q7XHJcblx0fVxyXG5cclxuXHQvLyBleHRlcm5hbCBvbi9vZmZcclxuXHRjb25zdCBob29rcyA9IHNlbGYuaG9va3MgPSBvcHRzLmhvb2tzIHx8IHt9O1xyXG5cclxuXHRmdW5jdGlvbiBmaXJlKGV2TmFtZSwgYTEsIGEyKSB7XHJcblx0XHRpZiAoZXZOYW1lIGluIGhvb2tzKSB7XHJcblx0XHRcdGhvb2tzW2V2TmFtZV0uZm9yRWFjaChmbiA9PiB7XHJcblx0XHRcdFx0Zm4uY2FsbChudWxsLCBzZWxmLCBhMSwgYTIpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdChvcHRzLnBsdWdpbnMgfHwgW10pLmZvckVhY2gocCA9PiB7XHJcblx0XHRmb3IgKGxldCBldk5hbWUgaW4gcC5ob29rcylcclxuXHRcdFx0aG9va3NbZXZOYW1lXSA9IChob29rc1tldk5hbWVdIHx8IFtdKS5jb25jYXQocC5ob29rc1tldk5hbWVdKTtcclxuXHR9KTtcclxuXHJcblx0Y29uc3Qgc2VyaWVzSWR4TWF0Y2hlciA9IChzZWxmLCBzcmMsIHNyY1Nlcmllc0lkeCkgPT4gc3JjU2VyaWVzSWR4O1xyXG5cclxuXHRjb25zdCBzeW5jT3B0cyA9IGFzc2lnbih7XHJcblx0XHRrZXk6IG51bGwsXHJcblx0XHRzZXRTZXJpZXM6IGZhbHNlLFxyXG5cdFx0ZmlsdGVyczoge1xyXG5cdFx0XHRwdWI6IHJldFRydWUsXHJcblx0XHRcdHN1YjogcmV0VHJ1ZSxcclxuXHRcdH0sXHJcblx0XHRzY2FsZXM6IFt4U2NhbGVLZXksIHNlcmllc1sxXSA/IHNlcmllc1sxXS5zY2FsZSA6IG51bGxdLFxyXG5cdFx0bWF0Y2g6IFtyZXRFcSwgcmV0RXEsIHNlcmllc0lkeE1hdGNoZXJdLFxyXG5cdFx0dmFsdWVzOiBbbnVsbCwgbnVsbF0sXHJcblx0fSwgY3Vyc29yLnN5bmMpO1xyXG5cclxuXHRpZiAoc3luY09wdHMubWF0Y2gubGVuZ3RoID09IDIpXHJcblx0XHRzeW5jT3B0cy5tYXRjaC5wdXNoKHNlcmllc0lkeE1hdGNoZXIpO1xyXG5cclxuXHRjdXJzb3Iuc3luYyA9IHN5bmNPcHRzO1xyXG5cclxuXHRjb25zdCBzeW5jS2V5ID0gc3luY09wdHMua2V5O1xyXG5cclxuXHRjb25zdCBzeW5jID0gX3N5bmMoc3luY0tleSk7XHJcblxyXG5cdGZ1bmN0aW9uIHB1YlN5bmModHlwZSwgc3JjLCB4LCB5LCB3LCBoLCBpKSB7XHJcblx0XHRpZiAoc3luY09wdHMuZmlsdGVycy5wdWIodHlwZSwgc3JjLCB4LCB5LCB3LCBoLCBpKSlcclxuXHRcdFx0c3luYy5wdWIodHlwZSwgc3JjLCB4LCB5LCB3LCBoLCBpKTtcclxuXHR9XHJcblxyXG5cdHN5bmMuc3ViKHNlbGYpO1xyXG5cclxuXHRmdW5jdGlvbiBwdWIodHlwZSwgc3JjLCB4LCB5LCB3LCBoLCBpKSB7XHJcblx0XHRpZiAoc3luY09wdHMuZmlsdGVycy5zdWIodHlwZSwgc3JjLCB4LCB5LCB3LCBoLCBpKSlcclxuXHRcdFx0ZXZlbnRzW3R5cGVdKG51bGwsIHNyYywgeCwgeSwgdywgaCwgaSk7XHJcblx0fVxyXG5cclxuXHRzZWxmLnB1YiA9IHB1YjtcclxuXHJcblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcclxuXHRcdHN5bmMudW5zdWIoc2VsZik7XHJcblx0XHRjdXJzb3JQbG90cy5kZWxldGUoc2VsZik7XHJcblx0XHRtb3VzZUxpc3RlbmVycy5jbGVhcigpO1xyXG5cdFx0b2ZmKGRwcHhjaGFuZ2UsIHdpbiwgc3luY1B4UmF0aW8pO1xyXG5cdFx0cm9vdC5yZW1vdmUoKTtcclxuXHRcdGxlZ2VuZFRhYmxlPy5yZW1vdmUoKTsgLy8gaW4gY2FzZSBtb3VudGVkIG91dHNpZGUgb2Ygcm9vdFxyXG5cdFx0ZmlyZShcImRlc3Ryb3lcIik7XHJcblx0fVxyXG5cclxuXHRzZWxmLmRlc3Ryb3kgPSBkZXN0cm95O1xyXG5cclxuXHRmdW5jdGlvbiBfaW5pdCgpIHtcclxuXHRcdGZpcmUoXCJpbml0XCIsIG9wdHMsIGRhdGEpO1xyXG5cclxuXHRcdHNldERhdGEoZGF0YSB8fCBvcHRzLmRhdGEsIGZhbHNlKTtcclxuXHJcblx0XHRpZiAocGVuZFNjYWxlc1t4U2NhbGVLZXldKVxyXG5cdFx0XHRzZXRTY2FsZSh4U2NhbGVLZXksIHBlbmRTY2FsZXNbeFNjYWxlS2V5XSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdGF1dG9TY2FsZVgoKTtcclxuXHJcblx0XHRzaG91bGRTZXRTZWxlY3QgPSBzZWxlY3Quc2hvdztcclxuXHRcdHNob3VsZFNldEN1cnNvciA9IHNob3VsZFNldExlZ2VuZCA9IHRydWU7XHJcblxyXG5cdFx0X3NldFNpemUob3B0cy53aWR0aCwgb3B0cy5oZWlnaHQpO1xyXG5cdH1cclxuXHJcblx0c2VyaWVzLmZvckVhY2goaW5pdFNlcmllcyk7XHJcblxyXG5cdGF4ZXMuZm9yRWFjaChpbml0QXhpcyk7XHJcblxyXG5cdGlmICh0aGVuKSB7XHJcblx0XHRpZiAodGhlbiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcblx0XHRcdHRoZW4uYXBwZW5kQ2hpbGQocm9vdCk7XHJcblx0XHRcdF9pbml0KCk7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHRcdHRoZW4oc2VsZiwgX2luaXQpO1xyXG5cdH1cclxuXHRlbHNlXHJcblx0XHRfaW5pdCgpO1xyXG5cclxuXHRyZXR1cm4gc2VsZjtcclxufVxyXG5cclxudVBsb3QuYXNzaWduID0gYXNzaWduO1xyXG51UGxvdC5mbXROdW0gPSBmbXROdW07XHJcbnVQbG90LnJhbmdlTnVtID0gcmFuZ2VOdW07XHJcbnVQbG90LnJhbmdlTG9nID0gcmFuZ2VMb2c7XHJcbnVQbG90LnJhbmdlQXNpbmggPSByYW5nZUFzaW5oO1xyXG51UGxvdC5vcmllbnQgICA9IG9yaWVudDtcclxudVBsb3QucHhSYXRpbyA9IHB4UmF0aW87XHJcblxyXG57XHJcblx0dVBsb3Quam9pbiA9IGpvaW47XHJcbn1cclxuXHJcbntcclxuXHR1UGxvdC5mbXREYXRlID0gZm10RGF0ZTtcclxuXHR1UGxvdC50ekRhdGUgID0gdHpEYXRlO1xyXG59XHJcblxyXG51UGxvdC5zeW5jID0gX3N5bmM7XHJcblxyXG57XHJcblx0dVBsb3QuYWRkR2FwID0gYWRkR2FwO1xyXG5cdHVQbG90LmNsaXBHYXBzID0gY2xpcEdhcHM7XHJcblxyXG5cdGxldCBwYXRocyA9IHVQbG90LnBhdGhzID0ge1xyXG5cdFx0cG9pbnRzLFxyXG5cdH07XHJcblxyXG5cdChwYXRocy5saW5lYXIgID0gbGluZWFyKTtcclxuXHQocGF0aHMuc3RlcHBlZCA9IHN0ZXBwZWQpO1xyXG5cdChwYXRocy5iYXJzICAgID0gYmFycyk7XHJcblx0KHBhdGhzLnNwbGluZSAgPSBtb25vdG9uZUN1YmljKTtcclxufVxyXG5cclxuZXhwb3J0IHsgdVBsb3QgYXMgZGVmYXVsdCB9O1xyXG4iLCJleHBvcnQgZnVuY3Rpb24gbG9hZGxpYihjYikge1xuICBsZXQgbWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7IGluaXRpYWw6IDIwNDgsIG1heGltdW06IDQwOTYgfSk7XG4gIGxldCBoZWFwID0gbmV3IFVpbnQ4QXJyYXkobWVtb3J5LmJ1ZmZlcik7XG4gIGxldCBpbXBvcnRzID0geyBlbnY6IHsgbWVtb3J5OiBtZW1vcnkgfSB9O1xuXG4gIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKGZldGNoKFwiLi9saWIud2FzbVwiKSwgaW1wb3J0cykudGhlbihmdW5jdGlvbihvYmopIHtcbiAgICAvLyBvbmUgd291bGQgdGhpbmsgdGhhdCBhIHByaW9yaXR5IGZvciB3YXNtIDEuMCB3b3VsZCBiZSBjb252ZW5pZW50IGludGVyb3Agd2l0aCBqYXZhc2NyaXB0IHR5cGVkIGFycmF5cyxcbiAgICAvLyBsaWtlIHdoeSBub3QgYWxsb3cgeW91IHRvIGp1c3QgcGFzcyBpbiBhbiBVaW50OEFycmF5IGFycmF5IGFzIGEgcGFyYW0gYW5kIGhhdmUgaXQgXCJtbWFwKClcIlxuICAgIC8vIHRoZSBhcnJheSBidWZmZXIgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZnVuY3Rpb24gY2FsbCB0byBzb21lIGhpZ2ggbWVtb3J5IGFkZHJlc3NcbiAgICAvLyBhbmQgcGFzcyBpdCBpbiBhcyBhIHBvaW50ZXIuIEJ1dCBhbGFzIG5vLCBvbmUgaXMgc3VwcG9zZWQgdG8gcGVyZm9ybSByaXR1YWxzIGxpa2UgdGhpc1xuICAgIG9iai5oZWFwID0gaGVhcDtcbiAgICBvYmouaW5idWZmZXIgPSBoZWFwLnN1YmFycmF5KDAsMTAyNCk7XG4gICAgb2JqLm91dGJ1ZmZlciA9IGhlYXAuc3ViYXJyYXkoMTAyNCwyMDQ4KTtcbiAgICBvYmouZm4gPSBvYmouaW5zdGFuY2UuZXhwb3J0cztcbiAgICBvYmoud3JhcF9hcnJheSA9IGZ1bmN0aW9uKGZuLCBzcmMpIHtcbiAgICAgIG9iai5pbmJ1ZmZlci5zZXQoc3JjKVxuICAgICAgbGV0IGxlbiA9IGZuKG9iai5vdXRidWZmZXIuYnl0ZU9mZnNldCwgb2JqLm91dGJ1ZmZlci5ieXRlTGVuZ3RoLCBvYmouaW5idWZmZXIuYnl0ZU9mZnNldCxzcmMubGVuZ3RoKTtcbiAgICAgIGlmIChsZW4gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCBhdCBjYWxsXCIgKyBmbiArIFwiOiBcIiArIGxlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkob2JqLm91dGJ1ZmZlci5zdWJhcnJheSgwLGxlbikpO1xuICAgIH1cbiAgICBjYihvYmopO1xuICB9KTtcbn1cblxuIiwiaW1wb3J0ICQgZnJvbSdqcXVlcnknO1xyXG5pbXBvcnQge2xvYWRsaWJ9IGZyb20gXCIuL2xpYi5qc1wiO1xyXG5cclxuLyoqIEB0eXBlIHtNSURJQWNjZXNzfSAqL1xyXG5sZXQgbWlkaSA9IG51bGw7XHJcbi8qKiBAdHlwZSB7TUlESUlucHV0fSAqL1xyXG5sZXQgZGVsdWdlSW4gPSBudWxsO1xyXG4vKiogQHR5cGUge01JRElPdXRwdXR9ICovXHJcbmxldCBkZWx1Z2VPdXQgPSBudWxsO1xyXG5cclxubGV0IHN5c0V4Q2FsbGJhY2s7XHJcbmV4cG9ydCB2YXIgc3lzRXhSdW5uaW5nID0gZmFsc2U7XHJcblxyXG5mdW5jdGlvbiBzZXRzdGF0dXModGV4dCkge1xyXG4gICQoXCIjbWlkaVN0YXR1c1wiKS50ZXh0KHRleHQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwb3B1bGF0ZURldmljZXMoKSB7XHJcbiAgZm9yIChjb25zdCBlbnRyeSBvZiBtaWRpLmlucHV0cykge1xyXG4gICAgY29uc3QgcG9ydCA9IGVudHJ5WzFdO1xyXG4gICAgY29uc3Qgb3B0ID0gbmV3IE9wdGlvbihwb3J0Lm5hbWUsIHBvcnQuaWQpO1xyXG4gICAgJChcIiNjaG9vc2VJblwiKS5hcHBlbmQob3B0KTtcclxuICAgIGlmIChwb3J0Lm5hbWUuaW5jbHVkZXMoXCJNSURJSU4yIChEZWx1Z2UpXCIpKSB7XHJcbiAgICAgIG9wdC5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgIHNldElucHV0KHBvcnQpO1xyXG4gICAgfVxyXG4gIH1cclxuICBmb3IgKGNvbnN0IGVudHJ5IG9mIG1pZGkub3V0cHV0cykge1xyXG4gICAgY29uc3QgcG9ydCA9IGVudHJ5WzFdO1xyXG4gICAgY29uc3Qgb3B0ID0gbmV3IE9wdGlvbihwb3J0Lm5hbWUsIHBvcnQuaWQpO1xyXG4gICAgJChcIiNjaG9vc2VPdXRcIikuYXBwZW5kKG9wdCk7XHJcbiAgICBpZiAocG9ydC5uYW1lLmluY2x1ZGVzKFwiTUlESU9VVDIgKERlbHVnZSlcIikpIHtcclxuICAgICAgb3B0LnNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgZGVsdWdlT3V0ID0gcG9ydDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldElucHV0KGlucHV0KSB7XHJcbiAgaWYgKGRlbHVnZUluID09IGlucHV0KSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIGlmIChkZWx1Z2VJbiAhPSBudWxsKSB7XHJcbiAgICBkZWx1Z2VJbi5yZW1vdmVFdmVudExpc3RlbmVyKFwibWlkaW1lc3NhZ2VcIiwgaGFuZGxlRGF0YSk7XHJcbiAgfVxyXG4gIGRlbHVnZUluID0gaW5wdXQ7XHJcbiAgaWYgKGRlbHVnZUluICE9IG51bGwpIHtcclxuICAgIC8vaGFuZGxlRGF0YS5vbihcIm1pZGltZXNzYWdlXCIsIGhhbmRsZURhdGEpO1xyXG4gICAgZGVsdWdlSW4uYWRkRXZlbnRMaXN0ZW5lcihcIm1pZGltZXNzYWdlXCIsIGhhbmRsZURhdGEpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gb25DaGFuZ2VJbihldikge1xyXG4gIGNvbnN0IGlkID0gZXYudGFyZ2V0LnZhbHVlO1xyXG4gIHNldElucHV0KG1pZGkuaW5wdXRzLmdldChpZCkpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uQ2hhbmdlT3V0KGV2KSB7XHJcbiAgY29uc3QgaWQgPSBldi50YXJnZXQudmFsdWU7XHJcbiAgY29uc29sZS5sb2coXCJjaG9vc2UgdGhlIGlkOlwiICsgaWQpXHJcbiAgZGVsdWdlT3V0ID0gbWlkaS5vdXRwdXRzLmdldChpZCkgfHwgbnVsbDtcclxuICBjb25zb2xlLmxvZyhcImNob29zZSB0aGUgcG9ydDpcIiArIGRlbHVnZU91dClcclxufVxyXG5cclxuZnVuY3Rpb24gb25TdGF0ZUNoYW5nZShldikge1xyXG4gIGNvbnN0IHBvcnQgPSBldi5wb3J0O1xyXG4gIGNvbnN0IGRlbGV0ID0gKHBvcnQuc3RhdGUgPT0gXCJkaXNjb25uZWN0ZWRcIik7XHJcbiAgaWYgKHBvcnQudHlwZSA9PSBcImlucHV0XCIpIHtcclxuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xyXG4gICAgbGV0IGNoaWxkcmVuID0gJChcIiNjaG9vc2VJblwiKS5jaGlsZHJlbigpO1xyXG4gICAgZm9yIChsZXQgaT0wOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKGNoaWxkcmVuW2ldLnZhbHVlID09IHBvcnQuaWQpIHtcclxuICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGRlbGV0KSB7XHJcbiAgICAgICAgICBjaGlsZHJlbltpXS5yZW1vdmUoKTtcclxuICAgICAgICAgIGlmIChwb3J0ID09IGRlbHVnZUluKSB7XHJcbiAgICAgICAgICAgICQoXCJub25lSW5wdXRcIikuc2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyBvciBtYXliZSBub3QsIGlmIGlkOiBhcmUgcHJlc2VydmVkIGR1cmluZyBhIGRpc2Nvbm5lY3QvY29ubmVjdCBjeWNsZVxyXG4gICAgICAgICAgICBzZXRJbnB1dChudWxsKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFmb3VuZCAmJiAhZGVsZXQpIHtcclxuICAgICAgY29uc3Qgb3B0ID0gbmV3IE9wdGlvbihwb3J0Lm5hbWUsIHBvcnQuaWQpO1xyXG4gICAgICAkKFwiI2Nob29zZUluXCIpLmFwcGVuZChvcHQpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcclxuICAgIGxldCBjaGlsZHJlbiA9ICQoXCIjY2hvb3NlT3V0XCIpLmNoaWxkcmVuKCk7XHJcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoY2hpbGRyZW5baV0udmFsdWUgPT0gcG9ydC5pZCkge1xyXG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICBpZiAoZGVsZXQpIHtcclxuICAgICAgICAgIGNoaWxkcmVuW2ldLnJlbW92ZSgpO1xyXG4gICAgICAgICAgaWYgKHBvcnQgPT0gZGVsdWdlT3V0KSB7XHJcbiAgICAgICAgICAgICQoXCIjbm9uZU91dHB1dFwiKS5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIG9yIG1heWJlIG5vdCwgaWYgaWQ6IGFyZSBwcmVzZXJ2ZWQgZHVyaW5nIGEgZGlzY29ubmVjdC9jb25uZWN0IGN5Y2xlXHJcbiAgICAgICAgICAgIGRlbHVnZU91dCA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghZm91bmQgJiYgIWRlbGV0KSB7XHJcbiAgICAgIGNvbnN0IG9wdCA9IG5ldyBPcHRpb24ocG9ydC5uYW1lLCBwb3J0LmlkKTtcclxuICAgICAgJChcIiNjaG9vc2VPdXRcIikuYXBwZW5kKG9wdCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBvbk1JRElTdWNjZXNzKG1pZGlBY2Nlc3MpIHtcclxuICBzZXRzdGF0dXMoXCJ3ZWJtaWRpIHJlYWR5XCIpO1xyXG4gIG1pZGkgPSBtaWRpQWNjZXNzOyAvLyBzdG9yZSBpbiB0aGUgZ2xvYmFsIChpbiByZWFsIHVzYWdlLCB3b3VsZCBwcm9iYWJseSBrZWVwIGluIGFuIG9iamVjdCBpbnN0YW5jZSlcclxuICBwb3B1bGF0ZURldmljZXMoKVxyXG4gIG1pZGkuYWRkRXZlbnRMaXN0ZW5lcihcInN0YXRlY2hhbmdlXCIsIG9uU3RhdGVDaGFuZ2UpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9uTUlESUZhaWx1cmUobXNnKSB7XHJcbiAgc2V0c3RhdHVzKGBGYWlsZWQgdG8gZ2V0IE1JREkgYWNjZXNzIDooIC0gJHttc2d9YCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERlYnVnKCkge1xyXG4gICAgZGVsdWdlT3V0LnNlbmQoWzB4ZjAsIDB4N2QsIDB4MDMsIDB4MDAsIDB4MDEsIDB4ZjddKTtcclxuICAgIHN5c0V4UnVubmluZyA9IHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0b3BEZWJ1ZygpIHtcclxuICAgIGRlbHVnZU91dC5zZW5kKFsweGYwLCAweDdkLCAweDAzLCAweDAwLCAweDAwLCAweGY3XSk7XHJcbiAgICBzeXNFeFJ1bm5pbmcgPSBmYWxzZTtcclxufVxyXG5cclxuXHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XHJcbiAgaWYgKG5hdmlnYXRvci5yZXF1ZXN0TUlESUFjY2Vzcykge1xyXG4gICAgbmF2aWdhdG9yLnJlcXVlc3RNSURJQWNjZXNzKHsgc3lzZXg6IHRydWUgfSkudGhlbiggb25NSURJU3VjY2Vzcywgb25NSURJRmFpbHVyZSApO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzZXRzdGF0dXMoXCJ3ZWJtaWRpIHVuYXZhaWwsIGNoZWNrIGJyb3dzZXIgcGVybWlzc2lvbnNcIik7XHJcbiAgfVxyXG5cclxuICAkKFwiI2dldERlYnVnQnV0dG9uXCIpLm9uKFwiY2xpY2tcIiwgZ2V0RGVidWcpO1xyXG4gICQoXCIjc3RvcERlYnVnQnV0dG9uXCIpLm9uKFwiY2xpY2tcIiwgc3RvcERlYnVnKTtcclxuICAkKFwiI2Nob29zZUluXCIpLm9uKFwiY2hhbmdlXCIsIG9uQ2hhbmdlSW4pO1xyXG4gICQoXCIjY2hvb3NlT3V0XCIpLm9uKFwiY2hhbmdlXCIsIG9uQ2hhbmdlT3V0KTtcclxuICByZXR1cm47XHJcbn0pO1xyXG5cclxubGV0IGxhc3Rtc2c7XHJcblxyXG4vKiogQHBhcmFtIHtNSURJTWVzc2FnZUV2ZW50fSBtc2cgKi9cclxuZnVuY3Rpb24gaGFuZGxlRGF0YShtc2cpIHtcclxuICBsYXN0bXNnID0gbXNnXHJcbiAgLy8gY29uc29sZS5sb2cobXNnLmRhdGEpO1xyXG4gIGlmIChtc2cuZGF0YS5sZW5ndGggPiA4KSB7XHJcbiAgICAkKFwiZGF0YUxvZ1wiKS50ZXh0KFwic2l6ZTogXCIgKyBtc2cuZGF0YS5sZW5ndGgpO1xyXG4gIH1cclxuICBkZWNvZGUobXNnLmRhdGEpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlY29kZShkYXRhKSB7XHJcbiAgaWYgKGRhdGEubGVuZ3RoIDwgMyB8fCBkYXRhWzBdICE9IDB4ZjAgfHwgZGF0YVsxXSAhPSAweDdkKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcImZvcmVpZ24gc3lzZXg/XCIpO1xyXG4vLyAgY29uc29sZS5sb2coZGF0YSk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gICAgaWYgKGRhdGEubGVuZ3RoID49IDUgJiYgZGF0YVsyXSA9PSAweDAzICYmIGRhdGFbM10gPT0gMHg0MCkge1xyXG4gICAgbGV0IG1zZ2J1ZiA9IGRhdGEuc3ViYXJyYXkoNSwgZGF0YS5sZW5ndGgtMSk7XHJcbiAgICBsZXQgbWVzc2FnZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShtc2didWYpO1xyXG4gICAgaWYgKHN5c0V4Q2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBcdGlmIChzeXNFeFJ1bm5pbmcpIHN5c0V4Q2FsbGJhY2sobWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBsZXQgY2h1bmtzID0gbWVzc2FnZS5zcGxpdCgnXFxuJyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAkKCcjZGVidWdPdXRwdXQnKVswXS5pbnNlcnRBZGphY2VudFRleHQoJ2JlZm9yZWVuZCcsIGNodW5rc1tpXSlcclxuICAgICAgaWYgKGkgPCBjaHVua3MubGVuZ3RoLTEpIHtcclxuICAgICAgICAkKCcjZGVidWdPdXRwdXQnKVswXS5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2JlZm9yZWVuZCcsIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2V0U3lzRXhDYWxsYmFjayhjYWxsYmFjaylcclxue3ZhciB0aGVJbnRlcnZhbDtcclxuLy8gTm90IHVzZWQgeWV0LlxyXG5mdW5jdGlvbiBzZXRSZWZyZXNoKCkge1xyXG4gIGlmICh0aGVJbnRlcnZhbCAhPSBudWxsKSB7XHJcbiAgICBjbGVhckludGVydmFsKHRoZUludGVydmFsKVxyXG4gICAgdGhlSW50ZXJ2YWwgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgdGhlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHsgcmVuZGVyQmxvY2s7IH0sIDEwMCk7XHJcbn1cclxuXHJcblx0c3lzRXhDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbiAgICBcclxuaW1wb3J0ICQgZnJvbSdqcXVlcnknO1xyXG5cclxuaW1wb3J0IHVQbG90IGZyb20gXCIuL2pzL3VQbG90LmVzbS5qc1wiO1xyXG5pbXBvcnQgUXVhZHRyZWUgZnJvbSBcIi4vanMvcXVhZHRyZWUuanNcIjtcclxuXHJcbmNsYXNzIFRhZ0luZm8ge1xyXG5cdCAgY29uc3RydWN0b3IoKSB7XHJcblx0ICBcdHRoaXMueWJhc2UgPSAwO1xyXG5cdFx0XHR0aGlzLnJlc2V0KCk7XHJcblx0ICB9XHJcblxyXG5cdCAgcmVzZXQoKSB7XHJcblx0ICBcdHRoaXMubWluVGltZSA9IE51bWJlci5NQVhfVkFMVUU7XHJcblx0ICBcdHRoaXMubWF4VGltZSA9IE51bWJlci5NSU5fVkFMVUU7XHJcblx0ICBcdHRoaXMubWluUmFuZ2UgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG5cdCAgXHR0aGlzLm1heFJhbmdlID0gTnVtYmVyLk1JTl9WQUxVRTtcclxuXHQgIFx0dGhpcy5ldmVudENvdW50ID0gMDtcclxuXHQgIFx0dGhpcy5oYXNUU0RhdGEgPSBmYWxzZTtcclxuXHQgIH1cclxuXHJcblx0XHR1cGRhdGVGb3JFdmVudChldnQpIHtcclxuXHRcdFx0XHRpZiAoZXZ0LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMuaGFzVFNEYXRhID0gdHJ1ZTtcclxuICAgICAgICAgIGlmIChldnQudmFsdWUgPCB0aGlzLm1pblJhbmdlKSB7XHJcbiAgICAgICAgICBcdFx0dGhpcy5taW5SYW5nZSA9IGV2dC52YWx1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChldnQudmFsdWUgPiB0aGlzLm1heFJhbmdlKSB7XHJcbiAgICAgICAgICBcdFx0dGhpcy5tYXhSYW5nZSA9IGV2dC52YWx1ZTsgXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgaWYgKGV2dC5hYnNUaW1lIDwgdGhpcy5taW5UaW1lKSB7XHJcbiAgICAgICAgICB0aGlzLm1pblRpbWUgPSBldnQuYWJzVGltZTtcclxuICAgICAgIH1cclxuICAgICAgIGlmIChldnQuYWJzVGltZSA+IHRoaXMubWF4VGltZSkge1xyXG4gICAgICAgICAgdGhpcy5tYXhUaW1lID0gZXZ0LmFic1RpbWU7IFxyXG4gICAgICAgfVxyXG4gICAgICB0aGlzLmV2ZW50Q291bnQrKztcclxuXHRcdH1cclxufVxyXG5cclxuXHRsZXQgY29sb3JUYWIgPSBbXHJcblx0IFwicmVkXCIsXHJcblx0IFwiZ3JlZW5cIixcclxuXHQgXCJibHVlXCIsXHJcblx0IFwieWVsbG93XCIsXHJcblx0IFwiYmxhY2tcIixcclxuXHQgXCJvcmFuZ2VcIixcclxuXHQgXCJjeWFuXCIsXHJcblx0IFwiZ3JheVwiXHJcblx0XTtcclxuXHRcclxuXHJcblx0XHRcdGxldCBjdXJzTGVmdCA9IC0xMDtcclxuXHRcdFx0bGV0IGN1cnNUb3AgPSAtMTA7XHJcblxyXG5cdFx0XHRjb25zdCBjdXJzb3JNZW1vID0ge1xyXG5cdFx0XHRcdHNldDogKGxlZnQsIHRvcCkgPT4ge1xyXG5cdFx0XHRcdFx0Y3Vyc0xlZnQgPSBsZWZ0O1xyXG5cdFx0XHRcdFx0Y3Vyc1RvcCA9IHRvcDtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGdldDogKCkgPT4gKHtsZWZ0OiBjdXJzTGVmdCwgdG9wOiBjdXJzVG9wfSksXHJcblx0XHRcdH07XHJcblxyXG4gXHRcdFx0ZnVuY3Rpb24gdG9vbHRpcHNQbHVnaW4ob3B0cykge1xyXG5cdFx0XHRcdGxldCBjdXJzb3J0dDtcclxuXHRcdFx0XHRsZXQgc2VyaWVzdHQ7XHJcblx0XHRcdFx0bGV0IHtldmVudEFycmF5LCBpZHhPZmZzZXR9ID0gb3B0cztcclxuXHRcdFx0XHRmdW5jdGlvbiBpbml0KHUsIG9wdHMsIGRhdGEpIHtcclxuXHRcdFx0XHRcdGxldCBvdmVyID0gdS5vdmVyO1xyXG4vKlxyXG5cdFx0XHRcdFx0bGV0IHR0ID0gY3Vyc29ydHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cdFx0XHRcdFx0dHQuY2xhc3NOYW1lID0gXCJ0b29sdGlwXCI7XHJcblx0XHRcdFx0XHR0dC50ZXh0Q29udGVudCA9IFwiKHgseSlcIjtcclxuXHRcdFx0XHRcdHR0LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcclxuXHRcdFx0XHRcdHR0LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG5cdFx0XHRcdFx0dHQuc3R5bGUuYmFja2dyb3VuZCA9IFwicmdiYSgwLDAsMjU1LDAuMSlcIjtcclxuXHRcdFx0XHRcdG92ZXIuYXBwZW5kQ2hpbGQodHQpO1xyXG4qL1xyXG5cdFx0XHRcdFx0c2VyaWVzdHQgPSBvcHRzLnNlcmllcy5tYXAoKHMsIGkpID0+IHtcclxuXHRcdFx0XHRcdFx0aWYgKGkgPT0gMCkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdFx0bGV0IHR0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuXHRcdFx0XHRcdFx0dHQuY2xhc3NOYW1lID0gXCJ0b29sdGlwXCI7XHJcblx0XHRcdFx0XHRcdHR0LnRleHRDb250ZW50ID0gXCJUb29sdGlwIVwiO1xyXG5cdFx0XHRcdFx0XHR0dC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XHJcblx0XHRcdFx0XHRcdHR0LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG5cdFx0XHRcdFx0XHR0dC5zdHlsZS5iYWNrZ3JvdW5kID0gXCJyZ2JhKDAsMCwwLDAuMSlcIjtcclxuXHRcdFx0XHRcdFx0dHQuc3R5bGUuY29sb3IgPSBzLmNvbG9yO1xyXG5cdFx0XHRcdFx0XHRvdmVyLmFwcGVuZENoaWxkKHR0KTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHR0O1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdFx0ZnVuY3Rpb24gaGlkZVRpcHMoKSB7XHJcblx0XHRcdFx0XHRcdC8vY3Vyc29ydHQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG5cdFx0XHRcdFx0XHRzZXJpZXN0dC5mb3JFYWNoKCh0dCwgaSkgPT4ge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChpID09IDApIHJldHVybjtcclxuXHJcblx0XHRcdFx0XHRcdFx0dHQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRmdW5jdGlvbiBzaG93VGlwcygpIHtcclxuXHRcdFx0XHRcdFx0Ly9jdXJzb3J0dC5zdHlsZS5kaXNwbGF5ID0gbnVsbDtcclxuXHRcdFx0XHRcdFx0c2VyaWVzdHQuZm9yRWFjaCgodHQsIGkpID0+IHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoaSA9PSAwKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0XHRcdGxldCBzID0gdS5zZXJpZXNbaV07XHJcblx0XHRcdFx0XHRcdFx0dHQuc3R5bGUuZGlzcGxheSA9IHMuc2hvdyA/IG51bGwgOiBcIm5vbmVcIjtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0b3Zlci5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoKSA9PiB7XHJcblx0XHRcdFx0XHRcdGlmICghdS5jdXJzb3IuX2xvY2spIHtcclxuXHRcdFx0XHRcdFx0Ly9cdHUuc2V0Q3Vyc29yKHtsZWZ0OiAtMTAsIHRvcDogLTEwfSk7XHJcblx0XHRcdFx0XHRcdFx0aGlkZVRpcHMoKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdFx0b3Zlci5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCAoKSA9PiB7XHJcblx0XHRcdFx0XHRcdHNob3dUaXBzKCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0XHRpZiAodS5jdXJzb3IubGVmdCA8IDApXHJcblx0XHRcdFx0XHRcdGhpZGVUaXBzKCk7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdHNob3dUaXBzKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmdW5jdGlvbiBzZXRDdXJzb3IodSkge1xyXG5cdFx0XHRcdFx0Y29uc3Qge2xlZnQsIHRvcCwgaWR4fSA9IHUuY3Vyc29yO1xyXG5cclxuXHRcdFx0XHRcdG9wdHM/LmN1cnNvck1lbW8/LnNldChsZWZ0LCB0b3ApO1xyXG5cclxuXHRcdFx0XHRcdC8vIHRoaXMgaXMgaGVyZSB0byBoYW5kbGUgaWYgaW5pdGlhbCBjdXJzb3IgcG9zaXRpb24gaXMgc2V0XHJcblx0XHRcdFx0XHQvLyBub3QgZ3JlYXQgKGNhbiBiZSBvcHRpbWl6ZWQgYnkgZG9pbmcgbW9yZSBlbnRlci9sZWF2ZSBzdGF0ZSB0cmFuc2l0aW9uIHRyYWNraW5nKVxyXG5cdFx0XHRcdC8vXHRpZiAobGVmdCA+IDApXHJcblx0XHRcdFx0Ly9cdFx0dS5jdXJzb3J0dC5zdHlsZS5kaXNwbGF5ID0gbnVsbDtcclxuXHJcblx0XHRcdFx0XHQvL2N1cnNvcnR0LnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xyXG5cdFx0XHRcdFx0Ly9jdXJzb3J0dC5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XHJcblx0XHRcdFx0XHQvL2N1cnNvcnR0LnRleHRDb250ZW50ID0gXCIoXCIgKyB1LnBvc1RvVmFsKGxlZnQsIFwieFwiKS50b0ZpeGVkKDIpICsgXCIsIFwiICsgdS5wb3NUb1ZhbCh0b3AsIFwieVwiKS50b0ZpeGVkKDIpICsgXCIpXCI7XHJcblxyXG5cdFx0XHRcdFx0Ly8gY2FuIG9wdGltaXplIGZ1cnRoZXIgYnkgbm90IGFwcGx5aW5nIHN0eWxlcyBpZiBpZHggZGlkIG5vdCBjaGFuZ2VcclxuXHRcdFx0XHRcdHNlcmllc3R0LmZvckVhY2goKHR0LCBpKSA9PiB7XHJcblx0XHRcdFx0XHRcdGlmIChpID09IDApIHJldHVybjtcclxuXHJcblx0XHRcdFx0XHRcdGxldCBzID0gdS5zZXJpZXNbaV07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAocy5zaG93KSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBpcyBoZXJlIHRvIGhhbmRsZSBpZiBpbml0aWFsIGN1cnNvciBwb3NpdGlvbiBpcyBzZXRcclxuXHRcdFx0XHRcdFx0XHQvLyBub3QgZ3JlYXQgKGNhbiBiZSBvcHRpbWl6ZWQgYnkgZG9pbmcgbW9yZSBlbnRlci9sZWF2ZSBzdGF0ZSB0cmFuc2l0aW9uIHRyYWNraW5nKVxyXG5cdFx0XHRcdFx0XHQvL1x0aWYgKGxlZnQgPiAwKVxyXG5cdFx0XHRcdFx0XHQvL1x0XHR0dC5zdHlsZS5kaXNwbGF5ID0gbnVsbDtcclxuXHJcblx0XHRcdFx0XHRcdFx0bGV0IHhWYWwgPSB1LmRhdGFbMF1baWR4XTtcclxuXHRcdFx0XHRcdFx0XHRsZXQgeVZhbCA9IHUuZGF0YVtpXVtpZHhdO1xyXG5cdFx0XHRcdFx0XHRcdGlmICh1LmRhdGFbaSwgMF0gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWR4LS07XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGxldCBldnQ7XHJcblx0XHRcdFx0XHRcdFx0bGV0IGlkeE9mZiA9IGlkeCArIGlkeE9mZnNldDtcclxuXHRcdFx0XHRcdFx0XHRpZiAoaWR4T2ZmID49IDAgJiYgaWR4T2ZmIDwgZXZlbnRBcnJheS5sZW5ndGgpIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ICBldnQgPSBldmVudEFycmF5W2lkeE9mZl07XHJcblx0XHRcdFx0XHRcdFx0ICBjb25zb2xlLmxvZyhldnQpOyBjb25zb2xlLmxvZyhpZHhPZmYpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZiAoZXZ0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHR0LnRleHRDb250ZW50ID0gZXZ0LmJvZHk7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdHR0LnRleHRDb250ZW50ID0gXCJcIjtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0dHQuc3R5bGUubGVmdCA9IE1hdGgucm91bmQodS52YWxUb1Bvcyh4VmFsLCAneCcpKSArIFwicHhcIjtcclxuXHRcdFx0XHRcdFx0XHR0dC5zdHlsZS50b3AgPSBNYXRoLnJvdW5kKHUudmFsVG9Qb3MoeVZhbCwgcy5zY2FsZSkpICsgXCJweFwiO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRob29rczoge1xyXG5cdFx0XHRcdFx0XHRpbml0LFxyXG5cdFx0XHRcdFx0XHRzZXRDdXJzb3IsXHJcblx0XHRcdFx0XHRcdC8vZHJhd0NsZWFyOiBcdGRyYXdDbGVhckZ1bmN0aW9uLFxyXG5cdFx0XHRcdFx0XHRzZXRTY2FsZTogW1xyXG5cdFx0XHRcdFx0XHRcdCh1LCBrZXkpID0+IHtcclxuXHRcdFx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ3NldFNjYWxlJywga2V5KTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdF0sXHJcblx0XHRcdFx0XHRcdHNldFNlcmllczogW1xyXG5cdFx0XHRcdFx0XHRcdCh1LCBpZHgpID0+IHtcclxuXHRcdFx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ3NldFNlcmllcycsIGlkeCk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRdLFxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblxyXG5jbGFzcyB1UGxvdHRlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHZpZXdlcikge1xyXG4gIFx0dGhpcy52aWV3ZXIgPSB2aWV3ZXI7XHJcbiAgXHR0aGlzLnNjYWxlRmFjdG9yICA9IHZpZXdlci50aW1lU2NhbGU7XHJcbiAgfVxyXG4gXHJcblx0XHRcdFxyXG5cdGdlblRTQXJyYXkoZXZlbnRzLCB0YWdJbmZvLCBpbmRleEFycmF5KSB7XHJcblxyXG5cdCAgaWYgKGV2ZW50cy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHRcdGxldCB0YWdDb3VudCA9IHRhZ0luZm8udGFnTGlzdC5sZW5ndGg7XHJcblx0XHRsZXQgdHNBcnJheSA9IG5ldyBBcnJheSh0YWdDb3VudCArIDEpO1xyXG5cdFx0Zm9yIChsZXQgdCA9IDA7IHQgPCB0c0FycmF5Lmxlbmd0aDsgKyt0KVxyXG5cdFx0XHR0c0FycmF5W3RdID0gW107XHJcblx0XHJcblx0XHRsZXQgZXggPSAwO1xyXG5cclxuXHRcdGxldCB0eCA9IDA7XHJcblxyXG5cdFx0d2hpbGUgKGV4IDwgZXZlbnRzLmxlbmd0aClcclxuXHRcdHtcclxuXHRcdFx0bGV0IGV2dCA9IGV2ZW50c1tleF07XHJcblx0XHRcdGxldCBub3dUID0gKGV2dC5hYnNTdGFydCAtIHRoaXMudmlld2VyLm1pbkFic1RpbWUpIC8gdGhpcy5zY2FsZUZhY3RvcjtcclxuXHRcdFx0XHQvLyBmaWxsIGluIHRoZSBhcnJheSBmb3IgdGhlIGN1cnJlbnQgdGltZSBzdGVwOlxyXG5cdFx0XHR0c0FycmF5WzBdW3R4XSA9IG5vd1Q7XHJcblx0XHRcdFxyXG5cdFx0XHRcdC8vIGZpcnN0LCBhc3N1bWUgbW9zdGx5IG1pc3NpbmcgZGF0YS5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0YWdDb3VudDsgKytpKSB7XHJcblx0XHRcdFx0XHR0c0FycmF5W2kgKyAxXVt0eF0gPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHJcblx0XHRcdGxldCBkb25lID0gZmFsc2U7XHJcblx0XHRcdHdoaWxlIChleCA8IGV2ZW50cy5sZW5ndGggJiYgIWRvbmUpIHtcclxuXHRcdFx0XHRsZXQgZXYyID0gZXZlbnRzW2V4XVxyXG5cdFx0XHRcdGxldCB0aGlzVCA9IChldjIuYWJzU3RhcnQgLSB0aGlzLnZpZXdlci5taW5BYnNUaW1lKSAvIHRoaXMuc2NhbGVGYWN0b3I7XHJcblx0XHRcdFx0aWYgKHRoaXNUIDw9IG5vd1QpIHtcclxuXHRcdFx0XHRcdFx0bGV0IHRhZyA9IGV2Mi50YWc7XHJcblx0XHRcdFx0XHRcdGxldCB0YWdYID0gdGFnSW5mby50YWdNYXAuZ2V0KHRhZyk7XHJcblx0XHRcdFx0XHRcdHRzQXJyYXlbdGFnWF1bdHhdID0gZXYyLnZhbHVlO1xyXG5cdFx0XHRcdFx0XHRpbmRleEFycmF5W3R4XSA9IGV2Mi5pbmRleDtcclxuXHRcdFx0XHRcdFx0ZXgrKztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0ZG9uZSA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHR4Kys7IC8vIHRvIG5leHQgdGltZSBjb2x1bW5cclxuXHRcdH1cclxuXHRcdHJldHVybiB0c0FycmF5O1xyXG5cdH1cclxuXHJcblx0bWFrZUxpbmVDaGFydChvLCBkLCB0YWdJbmZvLCBpbmRleEFycmF5LCBhcHBlbmRUb0VsZW1lbnQpIHtcclxuXHRcdFx0XHRcdGlmIChkID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsZXQgc2VyaWVzSW5mbyA9IG5ldyBBcnJheSgpO1xyXG5cdFx0XHRcdFx0bGV0IGF4aXNJbmZvICA9IG5ldyBBcnJheSh7fSk7XHJcblx0XHRcdFx0XHRsZXQgdGl0bGUgPSB0YWdJbmZvLnRhZ0xpc3RbMF07XHJcblxyXG5cdFx0XHRcdFx0c2VyaWVzSW5mby5wdXNoKHtsYWJlbDogdGl0bGV9KTtcclxuXHRcclxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGFnSW5mby50YWdMaXN0Lmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdFx0XHRcdGxldCB0YWcgPSB0YWdJbmZvLnRhZ0xpc3RbaV07XHJcblx0XHRcdFx0XHRcdGxldCBnbGluZSA9IHtcclxuXHRcdFx0XHRcdFx0XHRsYWJlbDogdGFnLFxyXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiAyLFxyXG5cdFx0XHRcdFx0XHRcdHNwYW5HYXBzOiB0cnVlLFxyXG5cdFx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdC8vIHNlcmllcyBzdHlsZVxyXG4gICAgICBcdFx0XHRzdHJva2U6IGNvbG9yVGFiW2kgJSBjb2xvclRhYi5sZW5ndGhdLFxyXG4gICAgICBcdFx0XHQvL2ZpbGw6IFwicmdiYSgyNTUsIDAsIDAsIDAuMylcIixcclxuICAgICAgXHRcdFx0Ly9kYXNoOiBbMTAsIDVdLFxyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHRzZXJpZXNJbmZvLnB1c2goZ2xpbmUpO1xyXG5cdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0bGV0IGFJbmZvID0ge1xyXG5cdFx0XHRcdFx0XHRcdHNjYWxlOiB0YWcsXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRheGlzSW5mby5wdXNoKGFJbmZvKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdGNvbnN0IG9wdHMgPSB7XHJcblx0XHRcdFx0XHR3aWR0aDogIHdpbmRvdy5pbm5lcldpZHRoLFxyXG5cdFx0XHRcdFx0aGVpZ2h0OiB0aGlzLnZpZXdlci5wbG90SGVpZ2h0LFxyXG5cdFx0XHRcdFx0dGl0bGU6IG8udGl0bGUgPz8gdGl0bGUsXHJcblx0XHRcdFx0XHRkcmF3T3JkZXI6IFtcInNlcmllc1wiLCBcImF4ZXNcIl0sXHJcblx0XHJcblx0XHRcdFx0XHRzY2FsZXM6IHtcclxuXHRcdFx0XHRcdFx0eDoge1xyXG5cdFx0XHRcdFx0XHRcdHRpbWU6IG8udGltZSA/PyBmYWxzZSxcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdGF4ZXM6IFtcclxuXHRcdFx0XHRcdFx0e30sXHJcblx0XHRcdFx0XHRcdHt9LFxyXG5cdFx0XHRcdFx0XSxcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0bGVnZW5kOiB7XHJcblx0XHRcdFx0XHQvL1x0bGl2ZTogZmFsc2UsXHJcblx0XHRcdFx0XHRcdG1hcmtlcnM6IHtcclxuXHRcdFx0XHRcdFx0XHR3aWR0aDogMCxcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSxcclxuXHRcclxuXHRcdFx0XHQvL1x0cGFkZGluZzogW251bGwsIDAsIG51bGwsIDBdLFxyXG5cdFx0XHRcdFx0c2VyaWVzOiBzZXJpZXNJbmZvLFxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGxldCB1ID0gbmV3IHVQbG90KG9wdHMsIGQsIGFwcGVuZFRvRWxlbWVudCk7XHJcblx0XHRcdH1cclxuXHJcbmdlblRMQXJyYXkoZXZlbnRzLCB0YWdJbmZvLCBpbmRleEFycmF5KSB7XHJcblx0bGV0IHN5bWJvbHMgPSBbXTtcclxuXHRsZXQgbWluVGltZSA9IHRoaXMudmlld2VyLm1pbkFic1RpbWU7XHJcblx0Ly9jb25zb2xlLmxvZyhldmVudHMpO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgKytpKSB7XHJcblx0XHRsZXQgZXZ0ID0gZXZlbnRzW2ldO1xyXG5cdFx0c3ltYm9scy5wdXNoKHt0aW1lOiBldnQuYWJzU3RhcnQgLSBtaW5UaW1lLCBkdXI6IGV2dC5kdXJhdGlvbiwgdGFnOiBldnQudGFnLCBpbmRleDogZXZ0LmluZGV4fSk7XHJcblx0fVxyXG5cdHN5bWJvbHMuc29ydCgoYSwgYik9PiB7XHJcblx0XHRcdFx0aWYgKGEudGltZSA9PT0gYi50aW1lKSByZXR1cm4gMDtcclxuXHRcdFx0XHRyZXR1cm4gKGEudGltZSA8IGIudGltZSkgPyAtMSA6IDE7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdGxldCB0aW1lQSA9IFtdO1xyXG5cdFx0bGV0IHlBID0gW107XHJcblx0XHRsZXQgZHVyQSA9IFtdO1xyXG5cdFx0bGV0IHN5bUIgPSBbXTtcclxuXHJcblx0ICBmb3IgKGxldCBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyArK2kpIHtcclxuXHQgIFx0bGV0IHN5bWIgPSBzeW1ib2xzW2ldO1xyXG5cdCAgXHR0aW1lQS5wdXNoKHN5bWIudGltZSAvIHRoaXMuc2NhbGVGYWN0b3IpO1xyXG5cdCAgXHRsZXQgdGFnWCA9IHRhZ0luZm8udGFnTWFwLmdldChzeW1iLnRhZyk7XHJcblx0ICBcdGluZGV4QXJyYXkucHVzaChzeW1iLmluZGV4KTtcclxuXHQgIFx0eUEucHVzaCh0YWdYKTtcclxuXHQgIFx0bGV0IGR1ciA9IDA7XHJcblx0ICBcdGlmIChzeW1iLmR1ciAhPT0gdW5kZWZpbmVkICYmIHN5bWIuZHVyICE9PSAwKSB7XHJcblx0ICBcdFx0ZHVyID0gc3ltYi5kdXI7XHJcblx0ICBcdH1cclxuXHQgIFx0ZHVyQS5wdXNoKGR1ciAvIHRoaXMuc2NhbGVGYWN0b3IpO1xyXG5cdCAgXHRzeW1CLnB1c2goc3ltYm9scy5pbmRleCk7XHJcblx0ICB9XHJcblx0XHJcblx0XHRsZXQgdGxBcnJheSA9IFt0aW1lQSwgeUEsIGR1ckFdO1xyXG5cdFx0cmV0dXJuIHRsQXJyYXk7XHJcbn07XHJcblxyXG5cclxuXHRtYWtlVGltZWxpbmVDaGFydChvLCBkLCB0YWdJbmZvLCBldmVudEFycmF5KSB7XHJcblx0XHRcdFx0XHRpZiAoZCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdFx0JChcIiN1cGxvdGxcIikuZW1wdHkoKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQ7XHJcblx0XHRcdFx0XHRsZXQgc2VyaWVzSW5mbyA9IG5ldyBBcnJheSgpO1xyXG5cdFx0XHRcdFx0Ly9sZXQgcXQ7XHJcblx0XHRcdFx0XHRsZXQgZHByID0gZGV2aWNlUGl4ZWxSYXRpbztcclxuXHRcdFx0XHRcdC8vIFNpbmNlIHdlIG1heSBoYXZlIGFkZGVkIGFuIGVtcHR5IGNvbHVtbiB0byB0aGUgZnJvbnQgb2YgdGhlIGRhdGEgYXJyYXlcclxuXHRcdFx0XHRcdC8vIGZvciB0aW1pbmcgYWxpZ25tZW50LCB0aGF0IGNhbiB0aHJvdyBvZmZcclxuXHRcdFx0XHRcdC8vIG91ciBpbmRleCBieSAxLCBjaGVjayBmb3IgdGhhdCBub3cgYW5kIHNldHVwIGFkanVzdG1lbnQuXHJcblx0XHRcdFx0XHRsZXQgaW5kZXhPZmZzZXQgPSAtMTtcclxuXHRcdFx0XHRcdGZvciAobGV0IHggPSAxOyB4IDwgZC5sZW5ndGg7ICsreCkge1xyXG5cdFx0XHRcdFx0XHRpZiAoZFt4XVswXSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpbmRleE9mZnNldCA9IDA7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRmdW5jdGlvbiBkcmF3UG9pbnRzKHUsIHNpZHgsIGkwLCBpMSkge1xyXG5cclxuXHRcdFx0XHRcdGxldCB7IGN0eCwgd2lkdGggfSA9IHU7XHJcblx0XHRcdFx0XHRsZXQgeyBfc3Ryb2tlLCBzY2FsZSwgbWluLCBtYXh9ID0gdS5zZXJpZXNbc2lkeF07XHJcblx0XHRcdFx0XHRsZXQgeFIgPSBtYXggLSBtaW47XHJcblx0XHRcdFx0XHQvL2xldCBzY2FsZUZhY3QgPSB0aGlzLnZpZXdlci5zY2FsZUZhY3RvcjtcclxuXHRcdFx0XHRcdGN0eC5zYXZlKCk7XHJcblxyXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IF9zdHJva2U7XHJcblxyXG5cdFx0XHRcdFx0bGV0IGogPSBpMDtcclxuXHJcblx0XHRcdFx0XHRsZXQgeE9mZiA9IHUuYmJveC5sZWZ0O1xyXG5cdFx0XHRcdFx0bGV0IHlPZmYgPSB1LmJib3gudG9wO1xyXG5cclxuXHRcdFx0XHRcdHdoaWxlIChqIDw9IGkxKSB7XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHRsZXQge21pbiwgbWF4fSA9IHUuc2NhbGVzW1wieFwiXTtcclxuXHRcdFx0XHRcdFx0bGV0IHZhbCA9IHUuZGF0YVtzaWR4XVtqXTtcclxuXHRcdFx0XHRcdFx0aWYgKHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbCkge1xyXG4gIFx0XHRcdFx0XHRcdGxldCBkdXIgPSB1LmRhdGFbc2lkeCArIDFdW2pdO1xyXG4gIFx0XHRcdFx0XHRcdGlmIChkdXIgPT09IHVuZGVmaW5lZCB8fCBkdXIgPT09IG51bGwpIGR1ciA9IDA7XHJcbiAgXHRcdFx0XHRcdFx0bGV0IHhSYXcgPSB1LmRhdGFbMF1bal07XHJcbiAgXHRcdFx0XHRcdFx0bGV0IHhSYXdFbmQgPSB4UmF3ICsgZHVyO1xyXG4gIFxyXG4gIFx0XHRcdFx0XHRcdGxldCBjeCA9IE1hdGgucm91bmQodS52YWxUb1Bvcyh4UmF3LCAneCcsIHRydWUpKTtcclxuICBcdFx0XHRcdFx0XHRsZXQgY3hlbmQgPSBNYXRoLnJvdW5kKHUudmFsVG9Qb3MoeFJhd0VuZCwgJ3gnLCB0cnVlKSk7XHJcbiAgXHRcdFx0XHRcdFx0bGV0IHhEdXIgPSBjeGVuZCAtIGN4O1xyXG4gIFxyXG4gIFx0XHRcdFx0XHRcdGxldCBjeSA9IE1hdGgucm91bmQodS52YWxUb1Bvcyh2YWwsIHNjYWxlLCB0cnVlKSk7XHJcblxyXG4gIFx0XHRcdFx0XHRcdGN0eC5zYXZlKCk7XHJcbiAgXHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGNvbG9yVGFiW3ZhbCAlIGNvbG9yVGFiLmxlbmd0aF07XHJcbiAgXHRcdFx0XHRcdFx0bGV0IHcgPSBNYXRoLm1heCg4LCB4RHVyKTtcclxuIFxyXG4gIFx0XHRcdFx0XHRcdGN0eC5maWxsUmVjdChjeCwgY3kgLSA4LCB3LCAxNik7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGxldCB4VCA9IE1hdGgucm91bmQoY3ggLSB4T2ZmKTtcclxuXHRcdFx0XHRcdFx0XHRsZXQgeVQgPSBNYXRoLnJvdW5kKGN5IC0geU9mZik7XHJcblx0XHRcdFx0XHRcdFx0bGV0IGV2YSA9IGV2ZW50QXJyYXlbal07XHJcblx0XHRcdFx0XHRcdFx0bGV0IHR2ID0gXCJcIjtcclxuXHRcdFx0XHRcdFx0XHRpZiAoZXZhICE9PSB1bmRlZmluZWQpIHR2ID1ldmEudGFnO1xyXG5cdFx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coXCJ4IFwiICsgeFQgKyBcIiBZIFwiICsgeVQgKyBcIiBXIFwiICsgdyArIFwiIGRpZHggXCIgKyBqICsgXCIgXCIgKyB0dik7XHJcbi8qXHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRpZiAocXQgIT09IHVuZGVmaW5lZClcclxuICBcdFx0XHRcdFx0XHRxdC5hZGQoe1xyXG5cdFx0XHRcdFx0XHRcdFx0eDogeFQsXHJcblx0XHRcdFx0XHRcdFx0XHR5OiB5VCxcclxuXHRcdFx0XHRcdFx0XHRcdHc6IHcsXHJcblx0XHRcdFx0XHRcdFx0XHRoOiAxNixcclxuXHRcdFx0XHRcdFx0XHRcdHNpZHg6IHNpZHgsXHJcblx0XHRcdFx0XHRcdFx0XHRkaWR4OiBqXHJcblx0XHRcdFx0XHRcdFx0fSk7XHJcbiovXHJcbiAgXHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aisrO1xyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdFx0XHRcdHNlcmllc0luZm8ucHVzaCh7bGFiZWw6IFwiRXZlbnRzXCJ9KTtcclxuXHRcdFx0XHRcdGxldCBnbGluZSA9IHtcclxuXHRcdFx0XHRcdFx0XHR3aWR0aDogMyxcclxuXHRcdFx0XHRcdFx0XHRsYWJlbDogXCJldmVudHNcIixcclxuXHRcdFx0XHRcdFx0XHRzcGFuR2FwczogZmFsc2UsXHJcblx0XHRcdFx0XHRcdFx0cG9pbnRzOiB7XHJcblx0XHRcdFx0XHRcdFx0XHRzaG93OiBkcmF3UG9pbnRzLFxyXG5cdFx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdCAvLyBmaWxsOiAgIChzZXJpZXNJZHgsIGRhdGFJZHgsIHZhbHVlKSA9PiBjb2xvclRhYlswICUgY29sb3JUYWIubGVuZ3RoXSxcclxuXHRcdFx0XHRcdFx0XHQgc3Ryb2tlOiAoc2VyaWVzSWR4LCBkYXRhSWR4KSA9PiB7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gY29sb3JUYWJbMSAlIGNvbG9yVGFiLmxlbmd0aF07XHJcblx0XHRcdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRcdHBhdGhzOiAoYSwgYiwgYywgZCwgZSwgZik9PiB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdCBudWxsIC8vIHN0b3BzIGxpbmUgZHJhd2luZyBhY3Jvc3MgZXZlbnRzLlxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0XHRcdFx0bGluZUludGVycG9sYXRpb246IG51bGwsXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0c2VyaWVzSW5mby5wdXNoKGdsaW5lKTtcclxuXHRcclxuXHRcdFx0XHRsZXQgdGxoID0gdGFnSW5mby50YWdMaXN0Lmxlbmd0aCAqIDIwICsgNTA7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0bGV0IHRhZ05hbWVzID0gdGFnSW5mby50YWdMaXN0O1xyXG5cdFx0XHRcdGxldCB0YWdZcyA9IFtdO1xyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGFnSW5mby50YWdMaXN0Lmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdFx0XHR0YWdZcy5wdXNoKHRhZ0luZm8udGFnTWFwLmdldCh0YWdJbmZvLnRhZ0xpc3RbaV0pKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxldCBpZHhPZmZzZXQgPSAwO1xyXG5cdFx0XHRcdGlmIChkLmxlbmd0aCA+IDEgJiYgKGRbMV1bMF0gPT09IHVuZGVmaW5lZCB8fCBkWzFdWzBdID09PSBudWxsKSkgaWR4T2Zmc2V0ID0gLTE7XHJcblx0XHJcblx0XHRcdFx0bGV0IG9wdHMgPSB7XHJcblx0XHRcdFx0XHR3aWR0aDogIHdpbmRvdy5pbm5lcldpZHRoLFxyXG5cdFx0XHRcdFx0aGVpZ2h0OiB0bGgsXHJcblx0XHRcdFx0XHR0aXRsZTogby50aXRsZSA/PyBcIkV2ZW50c1wiLFxyXG5cdFx0XHRcdFx0ZHJhd09yZGVyOiBbXCJzZXJpZXNcIiwgXCJheGVzXCJdLFxyXG5cdC8qXHJcblx0XHRcdFx0XHRjdXJzb3I6IHtcclxuXHRcdFx0XHRcdFx0XHRkYXRhSWR4OiAodSwgc2VyaWVzSWR4LCBjbG9zZXN0SWR4LCB4VmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bGV0IGN4ID0gTWF0aC5yb3VuZCh1LmN1cnNvci5sZWZ0ICogZHByKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bGV0IGN5ID0gTWF0aC5yb3VuZCh1LmN1cnNvci50b3AgKiBkcHIpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoc2VyaWVzSWR4ID09IDAgfHwgcXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNsb3Nlc3RJZHg7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwic2Vla2luZzogXCIgKyBjbG9zZXN0SWR4ICsgXCIgXCIgKyAgZXZlbnRBcnJheVtjbG9zZXN0SWR4XS50YWcgKyBcIiB4IFwiICsgY3ggKyBcIiB5IFwiICsgY3kpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRxdC5nZXQoY3gsIGN5LCAxLCAxLCBvID0+IHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAocG9pbnRXaXRoaW4oY3gsIGN5LCBvLngsIG8ueSwgby54ICsgby53LCBvLnkgKyBvLmgpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChvLmRpZHggIT09IHVuZGVmaW5lZClcdHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgY29uc29sZS5sb2coXCJmb3VuZCA6XCIgKyBvLmRpZHgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG8uZGlkeDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVsc2UgcmV0dXJuIGNsb3Nlc3RJZHg7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSAvLyBpZlxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9KTsgLy8gY2JcclxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNsb3Nlc3RJZHg7XHJcblx0XHRcdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0fSwgLy8gZW5kIGN1cnNvciBcclxuKi9cclxuXHRcdFx0XHRcdHNwYW5HYXBzOiBmYWxzZSxcclxuXHRcdFx0XHRcdHNjYWxlczoge1xyXG5cdFx0XHRcdFx0XHR4OiB7XHJcblx0XHRcdFx0XHRcdFx0dGltZTogby50aW1lID8/IGZhbHNlLFxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0YXhlczogW1xyXG5cdFx0XHRcdFx0XHR7fSxcclxuXHRcdFx0XHRcdFx0e3ZhbHVlczogKHUsIHNwbGl0cyk9PntcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGFnTmFtZXM7XHJcblx0XHRcdFx0XHRcdCAgfSxcclxuXHRcdFx0XHRcdFx0IHNwbGl0czogKCkgPT4geyByZXR1cm4gdGFnWXN9XHJcblx0XHRcdFx0XHRcdH0gXHJcblx0XHRcdFx0XHRdLFxyXG5cclxuXHRcdFx0XHRcdGxlZ2VuZDoge1xyXG5cdFx0XHRcdFx0XHRzaG93OiBmYWxzZSxcclxuXHRcdFx0XHRcdFx0bWFya2Vyczoge1xyXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiAyLFxyXG5cdFx0XHRcdFx0XHR9LFx0XHRcdFxyXG5cdFx0XHRcdFx0fSxcclxuXHRcclxuXHRcdFx0XHRcdHBsdWdpbnM6IFtcclxuXHRcdFx0XHRcdFx0dG9vbHRpcHNQbHVnaW4oe1xyXG5cdFx0XHRcdFx0XHRcdGV2ZW50QXJyYXksXHJcblx0XHRcdFx0XHRcdFx0Y3Vyc29yTWVtbyxcclxuXHRcdFx0XHRcdFx0XHRpZHhPZmZzZXQsXHJcblx0XHRcdFx0XHRcdFx0LypcclxuXHRcdFx0XHRcdFx0XHRkcmF3Q2xlYXJGdW5jdGlvbjogZnVuY3Rpb24odSkgIHtcclxuXHRcdFx0XHRcdFx0XHRcdHF0ID0gcXQgfHwgbmV3IFF1YWR0cmVlKDAsIDAsIHUuYmJveC53aWR0aCwgdS5iYm94LmhlaWdodCk7XHJcblx0XHRcdFx0XHRcdFx0XHRxdC5jbGVhcigpO1xyXG5cdFx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdFx0Ki9cclxuXHRcdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRcdF0sXHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdHNlcmllczogc2VyaWVzSW5mbyxcclxuXHRcdFx0XHR9OyAvLyBlbmQgb3B0c1xyXG5cclxuXHRcdFx0XHQkKFwiI3VwbG90bFwiKS5lbXB0eSgpO1xyXG5cdFx0XHRcdGxldCB1ID0gbmV3IHVQbG90KG9wdHMsIGQsICQoXCIjdXBsb3RsXCIpWzBdKTtcclxuXHRcdFx0fVxyXG5cclxuICB0YWdNaW5NYXgoZXZlbnRzKSB7XHJcbiAgXHRsZXQgdGFnVGFiID0gbmV3IE1hcCgpO1xyXG4gXHQgXHRcdGZvciAobGV0IGk9MDsgaSA8IGV2ZW50cy5sZW5ndGg7ICsraSkge1xyXG4gXHQgXHRcdFx0bGV0IGV2dCA9IGV2ZW50c1tpXTtcclxuXHQgXHRcdFx0bGV0IHRhZyA9IGV2dC50YWc7XHJcblx0IFx0XHRcdGlmICh0YWcgIT09IHVuZGVmaW5lZCAmJiAhdGFnVGFiLmhhcyh0YWcpKSB7XHJcblx0IFx0XHRcdFx0dGFnVGFiLnNldCh0YWcsIG5ldyBUYWdJbmZvKCkpO1xyXG5cdCBcdFx0XHR9XHJcblx0XHJcbiAgXHRcdGxldCB0aW5mbyA9IHRhZ1RhYi5nZXQodGFnKTtcclxuICBcdFx0dGluZm8udXBkYXRlRm9yRXZlbnQoZXZ0KTtcclxuICBcdH1cclxuICBcdHJldHVybiB0YWdUYWI7XHJcbiAgfVxyXG5cclxuXHRmaWx0ZXJFdmVudHMoZmlsdGZ1bikge1xyXG5cdFx0XHRsZXQgZmlsdGVyZWQgPSBbXTtcclxuXHRcdFx0Zm9yIChsZXQgaT0wOyBpIDwgdGhpcy52aWV3ZXIuZXZlbnRzLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdFx0bGV0IGV2dCA9IHRoaXMudmlld2VyLmV2ZW50c1tpXTtcclxuXHRcdFx0XHRpZiAoZmlsdGZ1bihldnQpKSB7XHJcblx0XHRcdFx0XHRmaWx0ZXJlZC5wdXNoKGV2dCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHQgIGZpbHRlcmVkLnNvcnQoKGEsIGIpPT4ge1xyXG5cdFx0XHRcdGlmIChhLmFic1N0YXJ0ID09PSBiLmFic1N0YXJ0KSByZXR1cm4gMDtcclxuXHRcdFx0XHRyZXR1cm4gKGEuYWJzU3RhcnQgPCBiLmFic1N0YXJ0KSA/IC0xIDogMTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMudmlld2VyLm1hdGNoRW5kaW5ncyhmaWx0ZXJlZCk7XHJcblx0XHRcdC8vbGV0IHRzQXJyYXkgPSB0aGlzLmdlblRTQXJyYXkoZmlsdGVyZWQpO1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKHRzQXJyYXkpO1xyXG5cdFx0XHRyZXR1cm4gZmlsdGVyZWQ7XHJcblx0fVxyXG5cclxuXHQgZ2VuVGFnVGFibGVzKGV2ZW50cylcclxuXHQge1xyXG5cdCBcdCAgbGV0IHRhZ0luZm9MaXN0ID0gdGhpcy50YWdNaW5NYXgoZXZlbnRzKTtcclxuXHJcblx0IFx0XHRsZXQgdGFnTGlzdCA9IEFycmF5LmZyb20odGFnSW5mb0xpc3Qua2V5cygpKTtcclxuXHQgXHRcdHRhZ0xpc3Quc29ydCgpO1xyXG5cdFxyXG5cdFx0XHRsZXQgdGFnTWFwID0gbmV3IE1hcCgpO1xyXG5cdCBcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0YWdMaXN0Lmxlbmd0aDsgKytpKSB7XHJcblx0IFx0XHRcdHRhZ01hcC5zZXQodGFnTGlzdFtpXSwgaSArIDEpO1xyXG5cdCBcdFx0fVxyXG5cdCBcdFx0cmV0dXJuIHt0YWdMaXN0LCB0YWdNYXAsIHRhZ0luZm9MaXN0fTtcclxuXHQgfVxyXG5cclxuXHRhbGlnblRpbWVzKHRtKSB7XHJcblx0XHRsZXQgbWluViA9IE51bWJlci5NQVhfVkFMVUU7XHJcblx0XHRsZXQgbWF4ViA9IE51bWJlci5NSU5fVkFMVUU7XHJcblx0XHRmb3IgKGxldCBsbSA9IDA7IGxtIDwgdG0ubGVuZ3RoOyArK2xtKSB7XHJcblx0XHRcdGxldCBtID0gdG1bbG1dO1xyXG5cdFx0XHRpZiAobSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcclxuXHRcdFx0aWYgKG1bMF1bMF0gPCBtaW5WKSB7XHJcblx0XHRcdFx0bWluViA9IG1bMF1bMF07XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IGxhc3RYID0gbVswXS5sZW5ndGggLSAxO1xyXG5cdFx0XHRpZiAobVswXVtsYXN0WF0gPiBtYXhWKSB7XHJcblx0XHRcdFx0bWF4ViA9IG1bMF1bbGFzdFhdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChsZXQgbG0gPSAwOyBsbSA8IHRtLmxlbmd0aDsgKytsbSkge1xyXG5cdFx0XHRsZXQgbSA9IHRtW2xtXTtcclxuXHRcdFx0aWYgKG0gPT09IHVuZGVmaW5lZCkgY29udGludWU7XHJcblx0XHRcdGlmIChtWzBdWzBdID4gbWluVikge1xyXG5cdFx0XHRcdG1bMF0udW5zaGlmdChtaW5WKTtcclxuXHRcdFx0XHRmb3IgKGxldCByID0gMTsgciA8IG0ubGVuZ3RoOyArK3IpIHtcclxuXHRcdFx0XHRcdG1bcl0udW5zaGlmdChudWxsKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IGxhc3RYID0gbVswXS5sZW5ndGggLSAxO1xyXG5cdFx0XHRpZiAobVswXVtsYXN0WF0gPCBtYXhWKSB7XHJcblx0XHRcdFx0XHRtWzBdLnB1c2gobWF4Vik7XHJcblx0XHRcdFx0XHRmb3IgKGxldCByID0gMTsgciA8IG0ubGVuZ3RoOyArK3IpIHtcclxuXHRcdFx0XHRcdFx0bVtyXS5wdXNoKG51bGwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcbiAgcGxvdEV2ZXJ5dGhpbmcoKSB7XHJcbiAgXHRsZXQgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2U7XHJcbiAgICBsZXQgcnN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgXHRsZXQgdHNFdmVudHMgPSB0aGlzLmZpbHRlckV2ZW50cygoZXZ0KT0+ZXZ0LnZhbHVlICE9IHVuZGVmaW5lZCAmJiBldnQudmFsdWUgPj0gMCk7XHJcbiAgXHRcclxuICBcdGxldCBhbGxUU1RhZ3MgPSB0aGlzLmdlblRhZ1RhYmxlcyh0c0V2ZW50cyk7XHJcblx0XHJcblx0XHRsZXQgYWxsUGxvdHNNYWRlID0gW107XHJcblx0XHRsZXQgYWxsVFNQbG90RGF0YSA9IFtdO1xyXG5cdFx0Ly8gRm9yIGVhY2ggdGFiIGluIHRoZSB2YWx1ZXMgdGFibGUgbGlzdCwgYnJlYWsgaW50byBzdWJwbG90c1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhbGxUU1RhZ3MudGFnTGlzdC5sZW5ndGg7ICsraSkge1xyXG5cdFx0XHRsZXQgYVRhZ1RvRG8gPSBhbGxUU1RhZ3MudGFnTGlzdFtpXTtcclxuXHRcdFx0bGV0IGFUYWdFdmVudHMgPSB0aGlzLmZpbHRlckV2ZW50cygoZXZ0KT0+ZXZ0LnRhZyA9PT0gYVRhZ1RvRG8pO1xyXG5cdFx0XHRsZXQgdGFnVGFibGVmb3IxID0gdGhpcy5nZW5UYWdUYWJsZXMoYVRhZ0V2ZW50cyk7XHJcblx0XHRcdGxldCBpbmRleEFycmF5ID0gW107XHJcblx0XHRcdGxldCBhVmFsdWVQbG90QXJyYXkgPSB0aGlzLmdlblRTQXJyYXkoYVRhZ0V2ZW50cywgdGFnVGFibGVmb3IxLCBpbmRleEFycmF5KTtcclxuXHRcdFx0YWxsVFNQbG90RGF0YS5wdXNoKHthVmFsdWVQbG90QXJyYXksIHRhZ1RhYmxlZm9yMSwgaW5kZXhBcnJheX0pO1xyXG5cdFx0XHRhbGxQbG90c01hZGUucHVzaChhVmFsdWVQbG90QXJyYXkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0bEV2ZW50cyA9IHRoaXMuZmlsdGVyRXZlbnRzKChldnQpPT5ldnQudmFsdWUgPT09IHVuZGVmaW5lZCk7XHJcblx0XHRsZXQgdGFnVGFibGUyID0gdGhpcy5nZW5UYWdUYWJsZXModGxFdmVudHMpO1xyXG5cdFx0bGV0IGluZGV4QXJyYXkgPSBbXTtcclxuXHRcdGxldCB0bERhdGEgPSB0aGlzLmdlblRMQXJyYXkodGxFdmVudHMsIHRhZ1RhYmxlMiwgaW5kZXhBcnJheSk7XHJcblx0XHRhbGxQbG90c01hZGUucHVzaCh0bERhdGEpO1xyXG5cdFx0dGhpcy5hbGlnblRpbWVzKGFsbFBsb3RzTWFkZSk7XHJcblx0XHQkKFwiI3VwbG90XCIpLmVtcHR5KCk7XHJcblx0XHRmb3IgKGxldCB4ID0gMDsgeCA8IGFsbFRTUGxvdERhdGEubGVuZ3RoOyArK3gpIHtcclxuICBcdFx0XHR0aGlzLm1ha2VMaW5lQ2hhcnQoe21vZGU6IDF9LCBhbGxUU1Bsb3REYXRhW3hdLmFWYWx1ZVBsb3RBcnJheSwgYWxsVFNQbG90RGF0YVt4XS50YWdUYWJsZWZvcjEsIGFsbFRTUGxvdERhdGFbeF0uaW5kZXhBcnJheSwgJChcIiN1cGxvdFwiKVswXSk7XHJcbiAgXHR9XHJcblxyXG5cdFx0dGhpcy5tYWtlVGltZWxpbmVDaGFydCh7bW9kZTogMSwgc3BhbkdhcHM6IGZhbHNlfSwgdGxEYXRhLCB0YWdUYWJsZTIsIHRsRXZlbnRzKTtcclxuXHRcdGxldCByZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAvL2NvbnNvbGUubG9nKFwiVGltZSB0byByZW5kZXIgdVBsb3Q6IFwiICsgKHJlbmQgLSByc3RhcnQpKTtcclxuICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBwb2ludFdpdGhpbihweCwgcHksIHJsZnQsIHJ0b3AsIHJyZ3QsIHJidG0pIHtcclxuICAgIHJldHVybiBweCA+PSBybGZ0ICYmIHB4IDw9IHJyZ3QgJiYgcHkgPj0gcnRvcCAmJiBweSA8PSByYnRtO1xyXG59XHJcblxyXG5leHBvcnQge3VQbG90dGVyLCBUYWdJbmZvfTtcclxuXHQiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbmltcG9ydCAkIGZyb20nanF1ZXJ5JztcclxuaW1wb3J0IHtzZXRTeXNFeENhbGxiYWNrLCBzeXNFeFJ1bm5pbmd9IGZyb20gXCIuL21pZGlkcml2ZXIuanNcIjtcclxuaW1wb3J0IHVQbG90IGZyb20gXCIuL2pzL3VQbG90LmVzbS5qc1wiO1xyXG5pbXBvcnQge3VQbG90dGVyLCBUYWdJbmZvfSBmcm9tIFwiLi91UGxvdHRlci5qc1wiO1xyXG5pbXBvcnQge2pQbG90fSBmcm9tIFwiLi9qUGxvdC5qc1wiO1xyXG5cclxudmFyIGFjdGl2ZVZpZXc7XHJcbi8vIFdlIG11c3QgYWxzbyB1cGRhdGUgdGhlICdzZWxlY3RlZCcgYXR0cmlidXRlIGluIHRoZSBkcm9wZG93biBlbGVtZW50IGluIHRoZSBodG1sIGZpbGUuXHJcbnZhciBsYXN0VGltZVNjYWxlID0gNDAwMDAwMDAwO1xyXG5cclxudmFyIGxhc3RQbG90SGVpZ2h0ID0gMTAwO1xyXG5cclxuLy8gVGVzdCBkYXRhOlxyXG5sZXQgcnR0Y2FwdHVyZSA9XHJcbmAwMD4gNjRFNzU3NkUsMDAyMDAwMDAgTWVvd1xyXG4wMD4gNjRFNzZDMDAgY293c1xyXG4wMD4gNjRFNzZDMUUgdVMgcGVyIDMyMCBzYW1wbGVzOiAxNVxyXG4wMD4gNjUwNUEwMDAgfmNvd3NcclxuMDA+IDY1MDVBQkNBIHVTIHBlciAzMjAgc2FtcGxlczogMTFcclxuMDA+IDY1Q0M1OTkwIHVTIHBlciAzMjAgc2FtcGxlczogNDlcclxuMDA+IDY2NUYwMUU5IHVTIHBlciAzMjAgc2FtcGxlczogMTU5XHJcbjAwPiA2NjVGMzFFOSBmdXIgMTAwXHJcbjAwPiA2NjVGMzIwMCBDYXRzXHJcbjAwPiA2NjVGMzJGRiB1UyBwZXIgMzIwIHNhbXBsZXM6IDExMlxyXG4wMD4gNjZFNzRDMDAsMDAxMDAwMDAgZnVyXHJcbjAwPiA2NkU3NjFFOSBmdXIgMjBcclxuMDA+IDY2RTc2QzFFIHVTIHBlciAzMjAgc2FtcGxlczogMTVcclxuMDA+IDY2RTdBMDAwIH5jb3dzXHJcbjAwPiA2NkU3QTA0MCwwMDAxMDAwMCBDYWxsaWVcclxuMDA+IDY2RkYzMjAwLDAwMjAwMDAwIENhdHNcclxuMDA+IDY2RkY4MjAwIFB1cnJzXHJcbjAwPiA2N0ZGODkwMCBmdXIgMTMwXHJcbmBcclxuXHJcbmxldCBzaW1wbGVjYXAgPVxyXG5gMDA+IDY0RTc1NzZFLDAwMjAwMDAwIE1lb3dcclxuMDA+IDY1Q0M1OTkwIHVTIHBlciAzMjAgc2FtcGxlczogNDlcclxuMDA+IDY2NUYwMUU5IHVTIHBlciAzMjAgc2FtcGxlczogMTU5XHJcbjAwPiA2NkU3QTA0MCwwMDAxMDAwMCBDYWxsaWVcclxuMDA+IDY0RTc2QzAwIGNvd3NcclxuMDA+IDY0RTc2QzFFIHVTIHBlciAzMjAgc2FtcGxcclxuYFxyXG5sZXQgcmVnZXggPSAvWzAtOUEtRmEtZl17OH0vZztcclxuZnVuY3Rpb24gcGFyc2VIZXgoc3RyaW5nKVxyXG57XHJcbiAgaWYgKHN0cmluZy5tYXRjaChyZWdleCkpIHtcclxuICAgIHJldHVybiBwYXJzZUludChzdHJpbmcsIDE2KTtcclxuICB9XHJcbiAgcmV0dXJuIE5hTjtcclxufVxyXG5cclxuLy8gQ2hlY2sgZm9yIGEgdmFsaWQgbnVtYmVyIGluIGEgc3RyaW5nLlxyXG4vLyB0aGFua3MgdG8gaHR0cHM6Ly9tYWtlcnNhaWQuY29tL2NoZWNrLWlmLXN0cmluZy1pcy1udW1iZXItamF2YXNjcmlwdC8jZ29vZ2xlX3ZpZ25ldHRlIFxyXG5mdW5jdGlvbiBpc1N0cmljdGx5TnVtZXJpYyh2YWwpIHtcclxuICAgIGlmKHZhbCA9PT0gXCJcIiB8fCB2YWwgPT09IFwiIFwiIHx8IHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gIWlzTmFOKE51bWJlcih2YWwpKTtcclxufVxyXG5cclxuXHJcbmNvbnN0IG1hdGNoMSA9IC9eKFswLTlBLUZhLWZdezh9KS87XHJcbmNvbnN0IG1hdGNoMiA9IC9eKFswLTlBLUZhLWZdezh9KSwoWzAtOUEtRmEtZl17OH0pLztcclxuY29uc3Qgc3BsaXRzcGFjZW9yY29tbWEgPSAvW1xccyxdKy87XHJcblxyXG5jbGFzcyBFdmVudFNjYW5uZXJcclxue1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG5cclxuICAgIHRoaXMuZXZlbnRzID0gW10gO1xyXG4gICAgdGhpcy5maXJzdFRpbWUgPSB0cnVlO1xyXG4gICAgdGhpcy5iYXNlVGltZSA9IDA7XHJcbiAgICB0aGlzLmxhc3RCYXNlVGltZSA9IDA7XHJcbiAgICB0aGlzLmFybWVkID0gZmFsc2U7XHJcbiAgICB0aGlzLnByZXZpb3VzU3RhbXAgPSAwO1xyXG4gICAgdGhpcy50cmFja1NldCA9IG5ldyBTZXQoKTtcclxuICAgIHRoaXMudHJhY2tPcmRlciA9IFtdO1xyXG4gICAgdGhpcy50cmFja01hcCA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMudGFnSW5mb1RhYmxlID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy50YWdPcmRlck9mQXBwZWFyYW5jZSA9IFtdO1xyXG4gICAgdGhpcy50YWdzVG9UcmFja051bWJlciA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMudGltZVNlcmllc1RhZ3MgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLnRpbWVMaW5lVGFncyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMubWF4UmFuZ2UgPSBuZXcgTWFwKCk7XHJcbiAgICB0aGlzLm1pblJhbmdlID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5taW5BYnNUaW1lID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIHRoaXMubWF4QWJzVGltZSA9IE51bWJlci5NSU5fVkFMVUU7XHJcbiAgICB0aGlzLmZsaXBwZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5tYXhZID0gMDtcclxuICAgIHRoaXMucGxvdEhlaWdodCA9IGxhc3RQbG90SGVpZ2h0O1xyXG4gICAgdGhpcy5sYW5lSGVpZ2h0ID0gMTY7XHJcbiAgICB0aGlzLnRpbWVTY2FsZSA9IGxhc3RUaW1lU2NhbGU7XHJcbiAgICB0aGlzLmNhcHR1cmVTdGFydCA9IERhdGUubm93KCk7XHJcblxyXG4gIH1cclxuXHJcbiAgcGFyc2VMaW5lKGluYnVmZmVyKVxyXG4gIHtcclxuICAgIGxldCBtYXhMZW4gPSBpbmJ1ZmZlci5sZW5ndGg7XHJcbiAgXHJcbiAgICBpZiAoIGluYnVmZmVyLmxlbmd0aCA8IDQpIHJldHVybjtcclxuICAgIC8vIElmIHdlIGFyZSBkZWFsaW5nIHdpdGggUlRUIGRhdGEsIHNraXAgdGhlIHRlcm1pbmFsIGluZGljYXRvciBwYXJ0LlxyXG4gICAgaWYgKGluYnVmZmVyWzJdID09PSAnPicpIHtcclxuICAgIFx0aW5idWZmZXIgPSBpbmJ1ZmZlci5zdWJzdHJpbmcoNCwgaW5idWZmZXIubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcblx0XHRsZXQgY2hhck9mZiA9IDA7XHJcblx0XHRsZXQgdHNhLCB0c2IgPSAwO1xyXG5cdFx0bGV0IGtpbmQgPSAwO1xyXG5cclxuICBcdGxldCBtYXRjaGVzID0gaW5idWZmZXIubWF0Y2gobWF0Y2gyKTtcclxuICBcdGlmIChtYXRjaGVzICE9PSBudWxsICYmIG1hdGNoZXMubGVuZ3RoID49IDIpXHJcbiAgXHR7XHJcbiAgXHRcdGNoYXJPZmYgPSAxNzsga2luZCA9IDI7XHJcbiAgXHRcdHRzYSA9IHBhcnNlSGV4KG1hdGNoZXNbMV0pO1xyXG4gIFx0XHR0c2IgPSBwYXJzZUhleChtYXRjaGVzWzJdKTtcclxuICBcdH0gZWxzZSB7XHJcbiAgXHRcdG1hdGNoZXMgPSBpbmJ1ZmZlci5tYXRjaChtYXRjaDEpO1xyXG4gIFx0XHRpZiAobWF0Y2hlcyAhPT0gbnVsbCAmJiBtYXRjaGVzLmxlbmd0aCA+IDEpIHtcclxuICBcdFx0XHRjaGFyT2ZmID0gODsga2luZCA9IDE7XHJcbiAgXHRcdFx0dHNhID0gcGFyc2VIZXgobWF0Y2hlc1sxXSk7XHJcbiAgXHRcdH1cclxuICBcdH1cclxuXHRcdGlmIChtYXRjaGVzID09PSBudWxsKSByZXR1cm47XHJcbiAgICBsZXQgYm9keSA9IGluYnVmZmVyLnN1YnN0cmluZyhjaGFyT2ZmLCBpbmJ1ZmZlci5sZW5ndGgpLnRyaW0oKTtcclxuXHRcdGxldCBpbmdlc3RlZCA9IERhdGUubm93KCk7XHJcbiAgICBsZXQgZXZlbnQgPSB7XHJcblxyXG5cdFx0ICBzdGFydDpcdCAgICB0c2EsXHJcblx0XHQgIGR1cmF0aW9uOiAgIHRzYixcclxuXHRcdCAgYm9keTogICAgICAgYm9keSxcclxuXHRcdCAgbnVtYmVyOlx0XHRcdHRoaXMuZXZlbnRzLmxlbmd0aCxcclxuXHRcdCAgaW5nZXN0ZWQ6XHRcdGluZ2VzdGVkLFxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmV2ZW50cy5wdXNoKGV2ZW50KTtcclxuICB9XHJcblxyXG4gIHJlYWRMaW5lcyh0ZXh0KVxyXG4gIHtcclxuICAgIGxldCBzcGxpdHMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHNwbGl0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsZXQgbGluZSA9IHNwbGl0c1tpXTtcclxuICAgICAgdGhpcy5wYXJzZUxpbmUobGluZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9jb25zb2xlLmxvZyh0aGlzLmV2ZW50cyk7XHJcbiAgfVxyXG5cclxuICBvdmVyRmxvd0NoZWNrKHRpbWUpXHJcbiAge1xyXG4gICAgaWYodGhpcy5hcm1lZCkge1xyXG4gICAgICBpZiAodGhpcy5wcmV2aW91c1N0YW1wID4gMHhBMDAwMDAwMCAmJiB0aW1lIDwgMHg2MDAwMDAwMCkge1xyXG4gICAgICAgIHRoaXMuYmFzZVRpbWUgKz0gMHgxMDAwMDAwMDA7XHJcbiAgICAgICAgdGhpcy5hcm1lZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgeyAvL3VuYXJtZWRcclxuICAgICAgaWYodGltZSA+IDB4NjAwMDAwMDApIHtcclxuICAgICAgICB0aGlzLmxhc3RCYXNlVGltZSA9IHRoaXMuYmFzZVRpbWU7XHJcbiAgICAgICAgdGhpcy5hcm1lZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMucHJldmlvdXNTdGFtcCA9IHRpbWU7XHJcbiAgfVxyXG5cclxuICBleHRlbmRUaW1lKHRpbWUpXHJcbiAge1xyXG4gICAgaWYgKHRpbWUgPiAweEEwMDAwMDAwKVxyXG4gICAgICByZXR1cm4gdGltZSArIHRoaXMubGFzdEJhc2VUaW1lO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aW1lICsgdGhpcy5iYXNlVGltZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGV4dHJhY3RJbmZvKGV2dCkge1xyXG4gICAgbGV0IGJvZHkgPSBldnQuYm9keTtcclxuICAgIGxldCB0YWcgPSBcIlwiO1xyXG4gICAgbGV0IGZpcnN0Yml0ID0gXCJcIjtcclxuICAgIGxldCBsYXN0Yml0ID0gXCJcIjtcclxuXHRcdGxldCBlbmRFdmVudCA9IGZhbHNlO1xyXG5cdFxyXG4gICAgbGV0IHNwbCA9IGJvZHkuc3BsaXQoXCJ8XCIpO1xyXG4gICAgaWYgKHNwbC5sZW5ndGggPiAxKSB7XHJcbiAgICAgIGxhc3RiaXQgPSBzcGxbMV07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNwbC5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGZpcnN0Yml0ID0gc3BsWzBdO1xyXG4gICAgfVxyXG5cclxuXHRcdGxldCBzZW50ID0gYm9keS5zcGxpdChzcGxpdHNwYWNlb3Jjb21tYSk7XHJcblxyXG5cdFx0bGV0IHdvcmRzID0gW107XHJcblx0XHRsZXQgbnVtYnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNlbnQubGVuZ3RoOyArK2kpIHtcclxuXHRcdFx0bGV0IHRva2VuID0gc2VudFtpXTtcclxuXHRcdFx0aWYgKGlzU3RyaWN0bHlOdW1lcmljKHRva2VuKSkge1xyXG5cdFx0XHRcdG51bWJzLnB1c2godG9rZW4pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHdvcmRzLnB1c2godG9rZW4pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHJcbiAgICBpZiAod29yZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0YWcgPSB3b3Jkc1swXTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHRhZy5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGFnID0gYm9keTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGFnLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0YWcgPSBldnQuYm9keTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGFnLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0YWcgPSBcIl9cIjtcclxuICAgIH1cclxuXHJcblx0XHRpZiAodGFnLmluZGV4T2YoJ34nKSA+PSAwKSB7XHJcblx0XHRcdHRhZyA9IHRhZy5yZXBsYWNlKCd+JywgJycpO1xyXG5cdFx0XHRlbmRFdmVudCA9IHRydWU7XHJcblx0XHR9XHJcblx0XHQvLyBFeHRyYWN0IGxhc3QgdmFsdWUgZnJvbSBib2R5IGZvciB0aW1lIHNlcmllcyBwbG90dGluZ1xyXG4gICAgLy8gRm9yIG5vdywgZ28gd2l0aCB0aGUgbGFzdCBudW1iZXJcclxuICAgIGlmIChudW1icy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGxldCBzdHIgPSBudW1ic1tudW1icy5sZW5ndGggLSAxXTtcclxuICAgICAgbGV0IG51bSA9IE51bWJlcihzdHIpO1xyXG4gICAgICBldnRbXCJ2YWx1ZVwiXSA9IG51bTtcclxuICAgIH1cclxuXHJcbiAgICBldnRbXCJ0YWdcIl0gPSB0YWc7XHJcbiAgICBldnRbXCJzcGxpdFwiXSA9IGxhc3RiaXQ7XHJcbiAgICBldnRbXCJlbmRFdmVudFwiXSA9IGVuZEV2ZW50O1xyXG4gXHJcbiAgICBpZighdGhpcy50cmFja1NldC5oYXModGFnKSlcclxuICAgIHtcclxuICAgICAgdGhpcy50cmFja09yZGVyLnB1c2godGFnKTtcclxuICAgICAgbGV0IGtpbmQgPSBldnQudmFsdWUgIT0gdW5kZWZpbmVkID8gMSA6IDA7XHJcbiAgICAgIGxldCB0YWdJbmZvID0gbmV3IFRhZ0luZm8oa2luZCk7XHJcbiAgICAgIHRoaXMudGFnSW5mb1RhYmxlLnNldCh0YWcsIHRhZ0luZm8pO1xyXG4gICAgICB0aGlzLnRhZ09yZGVyT2ZBcHBlYXJhbmNlLnB1c2godGFnSW5mbyk7XHJcbiBcclxuICAgICAgdGhpcy50YWdzVG9UcmFja051bWJlci5zZXQodGFnLCB0aGlzLnRyYWNrT3JkZXIubGVuZ3RoKTtcclxuICAgICAgdGhpcy50cmFja1NldC5hZGQodGFnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuIHNlYXJjaEZvclByZXZpb3VzRXZlbnQoZXZlbnRzLCBpbmRleCwgdGFnKVxyXG57XHJcblx0Zm9yIChsZXQgaSA9IGluZGV4IC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHRcdGlmIChldmVudHNbaV0udGFnID09PSB0YWcpIHJldHVybiBpO1xyXG5cdH1cclxuXHRcdHJldHVybiAtMTtcclxufVxyXG5cclxuICByZWZsb3dUaW1lKCkge1xyXG4gICAgLy8gVGhlIGZvbGxvd2luZyBhc3N1bWVzIHRoYXQgcG9pbnQgZXZlbnRzIGFkdmFuY2UgbW9ub3RvbmljYWxseVxyXG4gICAgLy8gd2hpbGUgZHVyYXRpb24gZXZlbnRzIGFyZSBhZGRlZCB0byB0aGUgdGltZWxpbmUgYXQgdGhlaXIgc3RhcnRUaW1lK2R1cmF0aW9uIChBS0EgZW5kaW5nIHRpbWUpXHJcbiAgICBpZiAodGhpcy5ldmVudHMubGVuZ3RoID09IDApIHJldHVybjtcclxuICAgIHRoaXMubWluQWJzVGltZSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICB0aGlzLm1heEFic1RpbWUgPSBOdW1iZXIuTUlOX1ZBTFVFO1xyXG5cclxuICAgIHRoaXMudGFnSW5mb1RhYmxlLmZvckVhY2goKHYsIGspPT52LnJlc2V0KCkpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmV2ZW50cy5sZW5ndGg7ICsraSkge1xyXG5cclxuICAgICAgbGV0IGV2dCA9IHRoaXMuZXZlbnRzW2ldO1xyXG4gICAgICBsZXQgdGltZSA9IGV2dC5zdGFydDtcclxuICAgICAgdGhpcy5vdmVyRmxvd0NoZWNrKHRpbWUpO1xyXG4gICAgICBsZXQgYWJzU3RhcnQgPSB0aGlzLmV4dGVuZFRpbWUodGltZSk7XHJcbiAgICAgIGV2dFtcImFic1N0YXJ0XCJdID0gYWJzU3RhcnQ7XHJcbiAgICAgIHRoaXMuZXh0cmFjdEluZm8oZXZ0KTtcclxuIFxyXG4gICAgICBsZXQgdGFnID0gZXZ0LnRhZztcclxuICAgICAgbGV0IHRhZ0luZm8gPSB0aGlzLnRhZ0luZm9UYWJsZS5nZXQodGFnKTtcclxuICAgICAgdGFnSW5mby5ldmVudENvdW50Kys7XHJcblxyXG4gXHRcdFx0aWYgKGFic1N0YXJ0IDwgdGhpcy5taW5BYnNUaW1lKSB0aGlzLm1pbkFic1RpbWUgPSBhYnNTdGFydDtcclxuIFx0XHRcdGlmICgoYWJzU3RhcnQgKyBldnQuZHVyYXRpb24pID4gdGhpcy5tYXhBYnNUaW1lKSB0aGlzLm1heEFic1RpbWUgPSBhYnNTdGFydCArIGV2dC5kdXJhdGlvbjtcclxuXHRcclxuICAgICAgaWYoZXZ0LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoIXRoaXMubWluUmFuZ2UuaGFzKGV2dC50YWcpKSB7XHJcbiAgICAgICAgICB0aGlzLm1pblJhbmdlLnNldChldnQudGFnLCBldnQudmFsdWUpO1xyXG4gICAgICAgICAgdGhpcy5tYXhSYW5nZS5zZXQoZXZ0LnRhZywgZXZ0LnZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKHRoaXMubWluUmFuZ2UuZ2V0KGV2dC50YWcpID4gZXZ0LnZhbHVlKSB7XHJcbiAgICAgICAgICBcdFx0dGhpcy5taW5SYW5nZS5zZXQoZXZ0LnRhZywgZXZ0LnZhbHVlKTtcclxuICAgICAgICAgIFx0fVxyXG4gICAgICAgICAgaWYgKHRoaXMubWF4UmFuZ2UuZ2V0KGV2dC50YWcpIDwgZXZ0LnZhbHVlKSB7IFxyXG4gICAgICAgICAgXHRcdHRoaXMubWF4UmFuZ2Uuc2V0KGV2dC50YWcsIGV2dC52YWx1ZSk7ICAgIFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gLy8gZW5kIGhhc1xyXG4gICAgICAgIGxldCB2YWwgPSBldnQudmFsdWU7XHJcblx0XHRcdFx0aWYgKHZhbCA+IHRhZ0luZm8ubWF4UmFuZ2UpIHRhZ0luZm8ubWF4UmFuZ2UgPSB2YWw7XHJcblx0XHRcdCAgIGVsc2UgaWYgKHZhbCA8IHRhZ0luZm8ubWluUmFuZ2UpIHRhZ0luZm8ubWluUmFuZ2UgPSB2YWw7XHJcblxyXG5cdFx0XHQgIFxyXG4gICAgICB9IC8vIGVuZCB1bmRlZmluZWQgdmFsdWVcclxuXHRcdFx0ICBsZXQgZW5kID0gYWJzU3RhcnQgKyBldnQuZHVyYXRpb247XHJcbiAgICAgIFx0aWYgKGVuZCA+IHRhZ0luZm8ubWF4VGltZSkgdGFnSW5mby5tYXhUaW1lID0gZW5kO1xyXG5cdFx0XHQgIGlmIChhYnNTdGFydCA8IHRhZ0luZm8ubWluVGltZSkgdGFnSW5mby5taW5UaW1lID0gYWJzU3RhcnQ7XHJcbiAgICB9IC8vIGVuZCBsb29wXHJcbiAgfVxyXG5cclxuICByZXBvcnQoKVxyXG4gIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ldmVudHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgbGV0IGV2dCA9IHRoaXMuZXZlbnRzW2ldO1xyXG4gICAgICBjb25zb2xlLmxvZyhldnQuYWJzU3RhcnQgKyBcIiBcIiArIGV2dC5zdGFydCArIFwiIFwiICsgZXZ0LmR1cmF0aW9uICsgXCIgTDogXCJcclxuICAgICAgICAgICAgICAgICAgKyBldnQuYm9keSArIFwiIFQ6IFwiICsgZXZ0LnRhZyArIFwiIFM6IFwiICsgZXZ0LnNwbGl0ICsgXCIgQzogXCIgKyBldnQuY29sb3IgKyBcIiBWOiBcIiArIGV2dC52YWx1ZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBtYXRjaEVuZGluZ3MoZXZlbnRMaXN0KSB7XHJcbiAgXHRmb3IgKGxldCBpID0gZXZlbnRMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgXHRcdGxldCBldnQgPSBldmVudExpc3RbaV07XHJcbiAgXHRcdGlmIChldnQuZW5kRXZlbnQpIHtcclxuICBcdFx0XHRsZXQgbGFzdEV4ID0gdGhpcy5zZWFyY2hGb3JQcmV2aW91c0V2ZW50KGV2ZW50TGlzdCwgaSwgZXZ0LnRhZyk7XHJcbiAgXHRcdFx0aWYgKGxhc3RFeCA+PSAwKSB7XHJcbiAgXHRcdFx0XHRsZXQgbGFzdEV2dCA9IGV2ZW50TGlzdFtsYXN0RXhdO1xyXG4gIFx0XHRcdFx0ZXZlbnRMaXN0W2xhc3RFeF0uZHVyYXRpb24gPSBldnQuYWJzU3RhcnQgLSBsYXN0RXZ0LmFic1N0YXJ0O1xyXG4gIFx0XHRcdH1cclxuICBcdFx0fVxyXG4gIFx0fVxyXG4gIH1cclxuICBcclxuICBcclxuICBhc3NpZ25Sb3dzKCkge1xyXG4gICAgdGhpcy50cmFja01hcC5jbGVhcigpO1xyXG4gICAgbGV0IHkgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYWNrT3JkZXIubGVuZ3RoOyArK2kpXHJcbiAgICB7XHJcbiAgICAgIGxldCB0YWcgPSB0aGlzLnRyYWNrT3JkZXJbaV07XHJcbiAgICAgIHRoaXMudHJhY2tNYXAuc2V0KHRhZywgeSk7XHJcbiAgICAgIHkgKz0gdGhpcy5taW5SYW5nZS5oYXModGFnKSA/IHRoaXMucGxvdEhlaWdodCArICAodGhpcy5sYW5lSGVpZ2h0IC8gMikgOiB0aGlzLmxhbmVIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMubWF4WSA9IHk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBvcGVuTG9jYWwoZXZ0KSB7XHJcbiAgdmFyIGZpbGVzID0gZXZ0LnRhcmdldC5maWxlcztcclxuICB2YXIgZiA9IGZpbGVzWzBdO1xyXG4gIGlmIChmID09PSB1bmRlZmluZWQpIHJldHVybjtcclxuICAkKCcjaW5zdHJ1Y3Rpb25zJykuZW1wdHkoKTtcclxuXHJcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbi8vIENsb3N1cmUgdG8gY2FwdHVyZSB0aGUgZmlsZSBpbmZvcm1hdGlvbi5cclxuICByZWFkZXIub25sb2FkID0gKGZ1bmN0aW9uKHRoZUZpbGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XHJcbiAgICAgIC8vIERpc3BsYXkgY29udGVudHMgb2YgZmlsZVxyXG4gICAgICBsZXQgdCA9IGUudGFyZ2V0LnJlc3VsdDtcclxuICAgICAgc2V0RXZlbnREYXRhKHRoZUZpbGUsIHQpO1xyXG4gICAgfTtcclxuICB9KShmKTtcclxuXHJcbiAgLy8gYWN0dWFsbHkgcmVhZCBpbiB0aGUgdGV4IGZpbGUuXHJcbiAgcmVhZGVyLnJlYWRBc1RleHQoZik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldEV2ZW50RGF0YShmaWxlTmFtZSwgdGV4dCkge1xyXG4gICQoXCIjcGxvdFwiKS5lbXB0eSgpO1xyXG4gIGxldCBlcyA9IG5ldyBFdmVudFNjYW5uZXIoKTtcclxuICBhY3RpdmVWaWV3ID0gZXM7XHJcbiAgYWN0aXZlVmlldy5iYXNlVGltZSA9IDA7XHJcbiAgYWN0aXZlVmlldy5sYXN0QmFzZVRpbWUgPSAwO1xyXG4gIGVzLnJlYWRMaW5lcyh0ZXh0KTtcclxuICBlcy5yZWZsb3dUaW1lKCk7XHJcbiAgZXMuYXNzaWduUm93cygpO1xyXG4gIC8vZXMucmVwb3J0KCk7XHJcbiAgbGV0IHVwID0gbmV3IHVQbG90dGVyKGVzKTtcclxuICB1cC5wbG90RXZlcnl0aGluZygpO1xyXG5cclxuXHQvL2xldCBqcCA9IG5ldyBqUGxvdChlcyk7XHJcbiAvLyBqcC5yZW5kZXIoKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNsZWFyQWN0aXZlVmlldyhldmVudCkge1xyXG4gIGxldCBlcyA9IG5ldyBFdmVudFNjYW5uZXIoKTtcclxuICBhY3RpdmVWaWV3ID0gZXM7XHJcbiAgJChcIiNkZWJ1Z091dHB1dFwiKS5lbXB0eSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGFuZ2VTY2FsZShldmVudClcclxue1xyXG4gIGxldCBzY2FsZVN0cmluZyA9IG5ldyBTdHJpbmcoZXZlbnQudGFyZ2V0LnZhbHVlKTtcclxuICBsZXQgdHMgPSA0MDAwMDAwMDA7XHJcbiAgaWYgKHNjYWxlU3RyaW5nID09IFwibWljcm9zZWNvbmRzXCIpIHtcclxuICBcdHRzID0gNDAwO1xyXG4gIH0gZWxzZSBpZiAoc2NhbGVTdHJpbmcgPT0gXCJtaWxsaXNlY29uZHNcIikge1xyXG4gIFx0dHMgPSA0MDAwMDA7XHJcbiAgfVxyXG5cdGxhc3RUaW1lU2NhbGUgPSB0cztcclxuXHRpZiAoYWN0aXZlVmlldyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XHJcblx0YWN0aXZlVmlldy50aW1lU2NhbGUgPSB0cztcclxuXHRhY3RpdmVWaWV3LnJlbmRlcigpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGFuZ2VQbG90SGVpZ2h0KGV2ZW50KSB7XHJcblx0bGV0IGFzTnVtID0gTnVtYmVyKGV2ZW50LnRhcmdldC52YWx1ZSk7XHJcblx0bGFzdFBsb3RIZWlnaHQgPSBhc051bTtcclxuXHRpZiAoYWN0aXZlVmlldyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XHJcblx0YWN0aXZlVmlldy5wbG90SGVpZ2h0ID0gYXNOdW07XHJcblx0Ly9hY3RpdmVWaWV3LnJlbmRlcigpO1xyXG5cdH1cclxuXHJcbmxldCBjYWxsYmFja0J1ZmZlciA9IFwiXCI7XHJcblxyXG5mdW5jdGlvbiByZW5kZXJCbG9jaygpXHJcbntcclxuXHRpZiAoIWFjdGl2ZVZpZXcpIHJldHVybjtcclxuXHQvL2lmICghc3lzRXhSdW5uaW5nICYmICF0aXBweUFjdGl2ZSkge1xyXG5cdC8vXHRhY3RpdmF0ZVRpcHB5KCk7XHJcblx0Ly99XHJcblxyXG5cdGlmIChjYWxsYmFja0J1ZmZlci5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHRsZXQgbGFzdE5MID0gY2FsbGJhY2tCdWZmZXIubGFzdEluZGV4T2YoXCJcXG5cIik7XHJcblx0aWYgKGxhc3ROTCA+PSAwKSB7XHJcblx0XHRcdGxldCBjb21wbGV0ZXMgPSBjYWxsYmFja0J1ZmZlci5zdWJzdHJpbmcoMCwgbGFzdE5MICsgMSk7XHJcblx0XHRcdGNhbGxiYWNrQnVmZmVyID0gIGNhbGxiYWNrQnVmZmVyLnN1YnN0cmluZyhsYXN0TkwgKyAxLCBjYWxsYmFja0J1ZmZlci5sZW5ndGgpO1xyXG5cdCAgICAkKFwiI3Bsb3RcIikuZW1wdHkoKTtcclxuXHQgICAgYWN0aXZlVmlldy5iYXNlVGltZSA9IDA7XHJcbiAgICBcdGFjdGl2ZVZpZXcubGFzdEJhc2VUaW1lID0gMDtcclxuXHRcdCAgYWN0aXZlVmlldy5yZWFkTGluZXMoY29tcGxldGVzKTtcclxuICBcdFx0YWN0aXZlVmlldy5yZWZsb3dUaW1lKCk7XHJcbiAgXHRcdGFjdGl2ZVZpZXcuYXNzaWduUm93cygpO1xyXG5cclxuLypcclxuICBcdFx0bGV0IHRzRGF0YSA9IGFjdGl2ZVZpZXcudVBsb3R0ZXIoKTtcclxuICBcdFx0YWN0aXZlVmlldy5tYWtlQ2hhcnQoe21vZGU6IDF9LCB0c0RhdGEpO1xyXG4qL1xyXG4gIFx0bGV0IHVwID0gbmV3IHVQbG90dGVyKGFjdGl2ZVZpZXcpO1xyXG4gIFx0dXAucGxvdEV2ZXJ5dGhpbmcoKTtcclxuXHR9XHJcbn1cclxuXHJcbnZhciB0aGVJbnRlcnZhbDtcclxuXHJcbi8vIFJlZ3VsYXIgcmVuZGVyIGxvb3A7XHJcbmZ1bmN0aW9uIHNldFJlZnJlc2goKSB7XHJcbiAgaWYgKHRoZUludGVydmFsICE9IG51bGwpIHtcclxuICAgIGNsZWFySW50ZXJ2YWwodGhlSW50ZXJ2YWwpXHJcbiAgICB0aGVJbnRlcnZhbCA9IG51bGw7XHJcbiAgfVxyXG5cclxuICB0aGVJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkgeyByZW5kZXJCbG9jaygpOyB9LCAxMDApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzeXNFeENhbGxiYWNrKHRleHQpIHtcclxuXHRpZiAoYWN0aXZlVmlldyA9PSB1bmRlZmluZWQpIHJldHVybjtcclxuXHJcblx0Y2FsbGJhY2tCdWZmZXIgPSBjYWxsYmFja0J1ZmZlci5jb25jYXQodGV4dCk7XHJcbn1cclxuXHJcbiQoXCIjY2xlYXJidXRcIikub24oJ2NsaWNrJywgY2xlYXJBY3RpdmVWaWV3KTtcclxuJChcIiNvcGVuZXJcIikub24oJ2NoYW5nZScsIG9wZW5Mb2NhbCk7XHJcbiQoXCIjc2NhbGVcIikub24oJ2NoYW5nZScsIGNoYW5nZVNjYWxlKTtcclxuJChcIiNwbG90SFwiKS5vbignY2hhbmdlJywgY2hhbmdlUGxvdEhlaWdodCk7XHJcblxyXG5zZXRTeXNFeENhbGxiYWNrKHN5c0V4Q2FsbGJhY2spOyBzZXRSZWZyZXNoKCk7XHJcbnNldEV2ZW50RGF0YShcInRlc3RcIiwgXCJcIik7IC8vIG5vIHF1b3Rlcy4gcnR0Y2FwdHVyZSBvciBcIlwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9